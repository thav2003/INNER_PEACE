/* tslint:disable */
/* eslint-disable */
/**
 * spoonacular API
 * The spoonacular Nutrition, Recipe, and Food API allows you to access over thousands of recipes, thousands of ingredients, 800,000 food products, over 100,000 menu items, and restaurants. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what\'s in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.
 *
 * The version of the OpenAPI document: 1.1
 * Contact: mail@spoonacular.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base";

/**
 *
 * @export
 * @interface AddMealPlanTemplate200Response
 */
export interface AddMealPlanTemplate200Response {
  /**
   *
   * @type {string}
   * @memberof AddMealPlanTemplate200Response
   */
  name: string;
  /**
   *
   * @type {Set<AddMealPlanTemplate200ResponseItemsInner>}
   * @memberof AddMealPlanTemplate200Response
   */
  items: Set<AddMealPlanTemplate200ResponseItemsInner>;
  /**
   *
   * @type {boolean}
   * @memberof AddMealPlanTemplate200Response
   */
  publishAsPublic: boolean;
}
/**
 *
 * @export
 * @interface AddMealPlanTemplate200ResponseItemsInner
 */
export interface AddMealPlanTemplate200ResponseItemsInner {
  /**
   *
   * @type {number}
   * @memberof AddMealPlanTemplate200ResponseItemsInner
   */
  day: number;
  /**
   *
   * @type {number}
   * @memberof AddMealPlanTemplate200ResponseItemsInner
   */
  slot: number;
  /**
   *
   * @type {number}
   * @memberof AddMealPlanTemplate200ResponseItemsInner
   */
  position: number;
  /**
   *
   * @type {string}
   * @memberof AddMealPlanTemplate200ResponseItemsInner
   */
  type: string;
  /**
   *
   * @type {AddMealPlanTemplate200ResponseItemsInnerValue}
   * @memberof AddMealPlanTemplate200ResponseItemsInner
   */
  value?: AddMealPlanTemplate200ResponseItemsInnerValue;
}
/**
 *
 * @export
 * @interface AddMealPlanTemplate200ResponseItemsInnerValue
 */
export interface AddMealPlanTemplate200ResponseItemsInnerValue {
  /**
   *
   * @type {number}
   * @memberof AddMealPlanTemplate200ResponseItemsInnerValue
   */
  id?: number;
  /**
   *
   * @type {number}
   * @memberof AddMealPlanTemplate200ResponseItemsInnerValue
   */
  servings?: number;
  /**
   *
   * @type {string}
   * @memberof AddMealPlanTemplate200ResponseItemsInnerValue
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof AddMealPlanTemplate200ResponseItemsInnerValue
   */
  imageType?: string;
}
/**
 *
 * @export
 * @interface AddToMealPlanRequest
 */
export interface AddToMealPlanRequest {
  /**
   * The username.
   * @type {string}
   * @memberof AddToMealPlanRequest
   */
  username: string;
  /**
   * The private hash for the username.
   * @type {string}
   * @memberof AddToMealPlanRequest
   */
  hash: string;
}
/**
 *
 * @export
 * @interface AddToMealPlanRequest1
 */
export interface AddToMealPlanRequest1 {
  /**
   *
   * @type {number}
   * @memberof AddToMealPlanRequest1
   */
  date: number;
  /**
   *
   * @type {number}
   * @memberof AddToMealPlanRequest1
   */
  slot: number;
  /**
   *
   * @type {number}
   * @memberof AddToMealPlanRequest1
   */
  position: number;
  /**
   *
   * @type {string}
   * @memberof AddToMealPlanRequest1
   */
  type: string;
  /**
   *
   * @type {AddToMealPlanRequest1Value}
   * @memberof AddToMealPlanRequest1
   */
  value: AddToMealPlanRequest1Value;
}
/**
 *
 * @export
 * @interface AddToMealPlanRequest1Value
 */
export interface AddToMealPlanRequest1Value {
  /**
   *
   * @type {Set<AddToMealPlanRequest1ValueIngredientsInner>}
   * @memberof AddToMealPlanRequest1Value
   */
  ingredients: Set<AddToMealPlanRequest1ValueIngredientsInner>;
}
/**
 *
 * @export
 * @interface AddToMealPlanRequest1ValueIngredientsInner
 */
export interface AddToMealPlanRequest1ValueIngredientsInner {
  /**
   *
   * @type {string}
   * @memberof AddToMealPlanRequest1ValueIngredientsInner
   */
  name: string;
}
/**
 *
 * @export
 * @interface AddToShoppingListRequest
 */
export interface AddToShoppingListRequest {
  /**
   *
   * @type {string}
   * @memberof AddToShoppingListRequest
   */
  item: string;
  /**
   *
   * @type {string}
   * @memberof AddToShoppingListRequest
   */
  aisle: string;
  /**
   *
   * @type {boolean}
   * @memberof AddToShoppingListRequest
   */
  parse: boolean;
}
/**
 *
 * @export
 * @interface AnalyzeARecipeSearchQuery200Response
 */
export interface AnalyzeARecipeSearchQuery200Response {
  /**
   *
   * @type {Set<AnalyzeARecipeSearchQuery200ResponseDishesInner>}
   * @memberof AnalyzeARecipeSearchQuery200Response
   */
  dishes: Set<AnalyzeARecipeSearchQuery200ResponseDishesInner>;
  /**
   *
   * @type {Set<AnalyzeARecipeSearchQuery200ResponseIngredientsInner>}
   * @memberof AnalyzeARecipeSearchQuery200Response
   */
  ingredients: Set<AnalyzeARecipeSearchQuery200ResponseIngredientsInner>;
  /**
   *
   * @type {Array<string>}
   * @memberof AnalyzeARecipeSearchQuery200Response
   */
  cuisines: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof AnalyzeARecipeSearchQuery200Response
   */
  modifiers: Array<string>;
}
/**
 *
 * @export
 * @interface AnalyzeARecipeSearchQuery200ResponseDishesInner
 */
export interface AnalyzeARecipeSearchQuery200ResponseDishesInner {
  /**
   *
   * @type {string}
   * @memberof AnalyzeARecipeSearchQuery200ResponseDishesInner
   */
  image: string;
  /**
   *
   * @type {string}
   * @memberof AnalyzeARecipeSearchQuery200ResponseDishesInner
   */
  name: string;
}
/**
 *
 * @export
 * @interface AnalyzeARecipeSearchQuery200ResponseIngredientsInner
 */
export interface AnalyzeARecipeSearchQuery200ResponseIngredientsInner {
  /**
   *
   * @type {string}
   * @memberof AnalyzeARecipeSearchQuery200ResponseIngredientsInner
   */
  image: string;
  /**
   *
   * @type {boolean}
   * @memberof AnalyzeARecipeSearchQuery200ResponseIngredientsInner
   */
  include: boolean;
  /**
   *
   * @type {string}
   * @memberof AnalyzeARecipeSearchQuery200ResponseIngredientsInner
   */
  name: string;
}
/**
 *
 * @export
 * @interface AnalyzeRecipeInstructions200Response
 */
export interface AnalyzeRecipeInstructions200Response {
  /**
   *
   * @type {Set<AnalyzeRecipeInstructions200ResponseParsedInstructionsInner>}
   * @memberof AnalyzeRecipeInstructions200Response
   */
  parsedInstructions: Set<AnalyzeRecipeInstructions200ResponseParsedInstructionsInner>;
  /**
   *
   * @type {Set<AnalyzeRecipeInstructions200ResponseIngredientsInner>}
   * @memberof AnalyzeRecipeInstructions200Response
   */
  ingredients: Set<AnalyzeRecipeInstructions200ResponseIngredientsInner>;
  /**
   *
   * @type {Set<AnalyzeRecipeInstructions200ResponseIngredientsInner>}
   * @memberof AnalyzeRecipeInstructions200Response
   */
  equipment: Set<AnalyzeRecipeInstructions200ResponseIngredientsInner>;
}
/**
 *
 * @export
 * @interface AnalyzeRecipeInstructions200ResponseIngredientsInner
 */
export interface AnalyzeRecipeInstructions200ResponseIngredientsInner {
  /**
   *
   * @type {number}
   * @memberof AnalyzeRecipeInstructions200ResponseIngredientsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof AnalyzeRecipeInstructions200ResponseIngredientsInner
   */
  name: string;
}
/**
 *
 * @export
 * @interface AnalyzeRecipeInstructions200ResponseParsedInstructionsInner
 */
export interface AnalyzeRecipeInstructions200ResponseParsedInstructionsInner {
  /**
   *
   * @type {string}
   * @memberof AnalyzeRecipeInstructions200ResponseParsedInstructionsInner
   */
  name: string;
  /**
   *
   * @type {Set<AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner>}
   * @memberof AnalyzeRecipeInstructions200ResponseParsedInstructionsInner
   */
  steps?: Set<AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner>;
}
/**
 *
 * @export
 * @interface AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
 */
export interface AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner {
  /**
   *
   * @type {number}
   * @memberof AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
   */
  number: number;
  /**
   *
   * @type {string}
   * @memberof AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
   */
  step: string;
  /**
   *
   * @type {Set<AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner>}
   * @memberof AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
   */
  ingredients?: Set<AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner>;
  /**
   *
   * @type {Set<AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner>}
   * @memberof AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
   */
  equipment?: Set<AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner>;
}
/**
 *
 * @export
 * @interface AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
 */
export interface AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner {
  /**
   *
   * @type {number}
   * @memberof AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
   */
  localizedName: string;
  /**
   *
   * @type {string}
   * @memberof AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
   */
  image: string;
}
/**
 *
 * @export
 * @interface AnalyzeRecipeRequest
 */
export interface AnalyzeRecipeRequest {
  /**
   * The input language, either \"en\" or \"de\".
   * @type {string}
   * @memberof AnalyzeRecipeRequest
   */
  language?: string;
  /**
   * Whether nutrition data should be added to correctly parsed ingredients.
   * @type {boolean}
   * @memberof AnalyzeRecipeRequest
   */
  includeNutrition?: boolean;
  /**
   * Whether taste data should be added to correctly parsed ingredients.
   * @type {boolean}
   * @memberof AnalyzeRecipeRequest
   */
  includeTaste?: boolean;
}
/**
 *
 * @export
 * @interface AnalyzeRecipeRequest1
 */
export interface AnalyzeRecipeRequest1 {
  /**
   *
   * @type {string}
   * @memberof AnalyzeRecipeRequest1
   */
  title?: string;
  /**
   *
   * @type {number}
   * @memberof AnalyzeRecipeRequest1
   */
  servings?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof AnalyzeRecipeRequest1
   */
  ingredients?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof AnalyzeRecipeRequest1
   */
  instructions?: string;
}
/**
 *
 * @export
 * @interface AutocompleteIngredientSearch200ResponseInner
 */
export interface AutocompleteIngredientSearch200ResponseInner {
  /**
   *
   * @type {string}
   * @memberof AutocompleteIngredientSearch200ResponseInner
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof AutocompleteIngredientSearch200ResponseInner
   */
  image: string;
  /**
   *
   * @type {number}
   * @memberof AutocompleteIngredientSearch200ResponseInner
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof AutocompleteIngredientSearch200ResponseInner
   */
  aisle?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof AutocompleteIngredientSearch200ResponseInner
   */
  possibleUnits?: Array<string>;
}
/**
 *
 * @export
 * @interface AutocompleteMenuItemSearch200Response
 */
export interface AutocompleteMenuItemSearch200Response {
  /**
   *
   * @type {Set<AutocompleteProductSearch200ResponseResultsInner>}
   * @memberof AutocompleteMenuItemSearch200Response
   */
  results: Set<AutocompleteProductSearch200ResponseResultsInner>;
}
/**
 *
 * @export
 * @interface AutocompleteProductSearch200Response
 */
export interface AutocompleteProductSearch200Response {
  /**
   *
   * @type {Set<AutocompleteProductSearch200ResponseResultsInner>}
   * @memberof AutocompleteProductSearch200Response
   */
  results: Set<AutocompleteProductSearch200ResponseResultsInner>;
}
/**
 *
 * @export
 * @interface AutocompleteProductSearch200ResponseResultsInner
 */
export interface AutocompleteProductSearch200ResponseResultsInner {
  /**
   *
   * @type {number}
   * @memberof AutocompleteProductSearch200ResponseResultsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof AutocompleteProductSearch200ResponseResultsInner
   */
  title: string;
}
/**
 *
 * @export
 * @interface AutocompleteRecipeSearch200ResponseInner
 */
export interface AutocompleteRecipeSearch200ResponseInner {
  /**
   *
   * @type {number}
   * @memberof AutocompleteRecipeSearch200ResponseInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof AutocompleteRecipeSearch200ResponseInner
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof AutocompleteRecipeSearch200ResponseInner
   */
  imageType: string;
}
/**
 *
 * @export
 * @interface ClassifyCuisine200Response
 */
export interface ClassifyCuisine200Response {
  /**
   *
   * @type {string}
   * @memberof ClassifyCuisine200Response
   */
  cuisine: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ClassifyCuisine200Response
   */
  cuisines: Array<string>;
  /**
   *
   * @type {number}
   * @memberof ClassifyCuisine200Response
   */
  confidence: number;
}
/**
 *
 * @export
 * @interface ClassifyGroceryProduct200Response
 */
export interface ClassifyGroceryProduct200Response {
  /**
   *
   * @type {string}
   * @memberof ClassifyGroceryProduct200Response
   */
  cleanTitle: string;
  /**
   *
   * @type {string}
   * @memberof ClassifyGroceryProduct200Response
   */
  image: string;
  /**
   *
   * @type {string}
   * @memberof ClassifyGroceryProduct200Response
   */
  category: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ClassifyGroceryProduct200Response
   */
  breadcrumbs: Array<string>;
  /**
   *
   * @type {number}
   * @memberof ClassifyGroceryProduct200Response
   */
  usdaCode: number;
}
/**
 *
 * @export
 * @interface ClassifyGroceryProductBulk200ResponseInner
 */
export interface ClassifyGroceryProductBulk200ResponseInner {
  /**
   *
   * @type {string}
   * @memberof ClassifyGroceryProductBulk200ResponseInner
   */
  cleanTitle: string;
  /**
   *
   * @type {string}
   * @memberof ClassifyGroceryProductBulk200ResponseInner
   */
  image: string;
  /**
   *
   * @type {string}
   * @memberof ClassifyGroceryProductBulk200ResponseInner
   */
  category: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ClassifyGroceryProductBulk200ResponseInner
   */
  breadcrumbs: Array<string>;
  /**
   *
   * @type {number}
   * @memberof ClassifyGroceryProductBulk200ResponseInner
   */
  usdaCode: number;
}
/**
 *
 * @export
 * @interface ClassifyGroceryProductBulkRequestInner
 */
export interface ClassifyGroceryProductBulkRequestInner {
  /**
   *
   * @type {string}
   * @memberof ClassifyGroceryProductBulkRequestInner
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof ClassifyGroceryProductBulkRequestInner
   */
  upc: string;
  /**
   *
   * @type {string}
   * @memberof ClassifyGroceryProductBulkRequestInner
   */
  plu_code: string;
}
/**
 *
 * @export
 * @interface ClassifyGroceryProductRequest
 */
export interface ClassifyGroceryProductRequest {
  /**
   *
   * @type {string}
   * @memberof ClassifyGroceryProductRequest
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof ClassifyGroceryProductRequest
   */
  upc: string;
  /**
   *
   * @type {string}
   * @memberof ClassifyGroceryProductRequest
   */
  plu_code: string;
}
/**
 *
 * @export
 * @interface ClearMealPlanDayRequest
 */
export interface ClearMealPlanDayRequest {
  /**
   * The username.
   * @type {string}
   * @memberof ClearMealPlanDayRequest
   */
  username: string;
  /**
   * The date in the format yyyy-mm-dd.
   * @type {string}
   * @memberof ClearMealPlanDayRequest
   */
  date: string;
  /**
   * The private hash for the username.
   * @type {string}
   * @memberof ClearMealPlanDayRequest
   */
  hash: string;
}
/**
 *
 * @export
 * @interface ComputeGlycemicLoad200Response
 */
export interface ComputeGlycemicLoad200Response {
  /**
   *
   * @type {number}
   * @memberof ComputeGlycemicLoad200Response
   */
  totalGlycemicLoad: number;
  /**
   *
   * @type {Set<ComputeGlycemicLoad200ResponseIngredientsInner>}
   * @memberof ComputeGlycemicLoad200Response
   */
  ingredients: Set<ComputeGlycemicLoad200ResponseIngredientsInner>;
}
/**
 *
 * @export
 * @interface ComputeGlycemicLoad200ResponseIngredientsInner
 */
export interface ComputeGlycemicLoad200ResponseIngredientsInner {
  /**
   *
   * @type {number}
   * @memberof ComputeGlycemicLoad200ResponseIngredientsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof ComputeGlycemicLoad200ResponseIngredientsInner
   */
  original: string;
  /**
   *
   * @type {number}
   * @memberof ComputeGlycemicLoad200ResponseIngredientsInner
   */
  glycemicIndex: number;
  /**
   *
   * @type {number}
   * @memberof ComputeGlycemicLoad200ResponseIngredientsInner
   */
  glycemicLoad: number;
}
/**
 *
 * @export
 * @interface ComputeGlycemicLoadRequest
 */
export interface ComputeGlycemicLoadRequest {
  /**
   *
   * @type {Array<string>}
   * @memberof ComputeGlycemicLoadRequest
   */
  ingredients: Array<string>;
}
/**
 *
 * @export
 * @interface ComputeIngredientAmount200Response
 */
export interface ComputeIngredientAmount200Response {
  /**
   *
   * @type {number}
   * @memberof ComputeIngredientAmount200Response
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof ComputeIngredientAmount200Response
   */
  unit: string;
}
/**
 *
 * @export
 * @interface ConnectUser200Response
 */
export interface ConnectUser200Response {
  /**
   *
   * @type {string}
   * @memberof ConnectUser200Response
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof ConnectUser200Response
   */
  hash: string;
}
/**
 *
 * @export
 * @interface ConnectUserRequest
 */
export interface ConnectUserRequest {
  /**
   *
   * @type {string}
   * @memberof ConnectUserRequest
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof ConnectUserRequest
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof ConnectUserRequest
   */
  lastName: string;
  /**
   *
   * @type {string}
   * @memberof ConnectUserRequest
   */
  email: string;
}
/**
 *
 * @export
 * @interface ConvertAmounts200Response
 */
export interface ConvertAmounts200Response {
  /**
   *
   * @type {number}
   * @memberof ConvertAmounts200Response
   */
  sourceAmount: number;
  /**
   *
   * @type {string}
   * @memberof ConvertAmounts200Response
   */
  sourceUnit: string;
  /**
   *
   * @type {number}
   * @memberof ConvertAmounts200Response
   */
  targetAmount: number;
  /**
   *
   * @type {string}
   * @memberof ConvertAmounts200Response
   */
  targetUnit: string;
  /**
   *
   * @type {string}
   * @memberof ConvertAmounts200Response
   */
  answer: string;
}
/**
 *
 * @export
 * @interface CreateRecipeCard200Response
 */
export interface CreateRecipeCard200Response {
  /**
   *
   * @type {string}
   * @memberof CreateRecipeCard200Response
   */
  url: string;
}
/**
 *
 * @export
 * @interface DeleteFromMealPlanRequest
 */
export interface DeleteFromMealPlanRequest {
  /**
   * The username.
   * @type {string}
   * @memberof DeleteFromMealPlanRequest
   */
  username: string;
  /**
   * The shopping list item id.
   * @type {number}
   * @memberof DeleteFromMealPlanRequest
   */
  id: number;
  /**
   * The private hash for the username.
   * @type {string}
   * @memberof DeleteFromMealPlanRequest
   */
  hash: string;
}
/**
 *
 * @export
 * @interface DetectFoodInText200Response
 */
export interface DetectFoodInText200Response {
  /**
   *
   * @type {Set<DetectFoodInText200ResponseAnnotationsInner>}
   * @memberof DetectFoodInText200Response
   */
  annotations: Set<DetectFoodInText200ResponseAnnotationsInner>;
}
/**
 *
 * @export
 * @interface DetectFoodInText200ResponseAnnotationsInner
 */
export interface DetectFoodInText200ResponseAnnotationsInner {
  /**
   *
   * @type {string}
   * @memberof DetectFoodInText200ResponseAnnotationsInner
   */
  annotation: string;
  /**
   *
   * @type {string}
   * @memberof DetectFoodInText200ResponseAnnotationsInner
   */
  image: string;
  /**
   *
   * @type {string}
   * @memberof DetectFoodInText200ResponseAnnotationsInner
   */
  tag: string;
}
/**
 *
 * @export
 * @interface GenerateMealPlan200Response
 */
export interface GenerateMealPlan200Response {
  /**
   *
   * @type {Set<GetSimilarRecipes200ResponseInner>}
   * @memberof GenerateMealPlan200Response
   */
  meals: Set<GetSimilarRecipes200ResponseInner>;
  /**
   *
   * @type {GenerateMealPlan200ResponseNutrients}
   * @memberof GenerateMealPlan200Response
   */
  nutrients: GenerateMealPlan200ResponseNutrients;
}
/**
 *
 * @export
 * @interface GenerateMealPlan200ResponseNutrients
 */
export interface GenerateMealPlan200ResponseNutrients {
  /**
   *
   * @type {number}
   * @memberof GenerateMealPlan200ResponseNutrients
   */
  calories: number;
  /**
   *
   * @type {number}
   * @memberof GenerateMealPlan200ResponseNutrients
   */
  carbohydrates: number;
  /**
   *
   * @type {number}
   * @memberof GenerateMealPlan200ResponseNutrients
   */
  fat: number;
  /**
   *
   * @type {number}
   * @memberof GenerateMealPlan200ResponseNutrients
   */
  protein: number;
}
/**
 *
 * @export
 * @interface GenerateShoppingList200Response
 */
export interface GenerateShoppingList200Response {
  /**
   *
   * @type {Set<GetShoppingList200ResponseAislesInner>}
   * @memberof GenerateShoppingList200Response
   */
  aisles: Set<GetShoppingList200ResponseAislesInner>;
  /**
   *
   * @type {number}
   * @memberof GenerateShoppingList200Response
   */
  cost: number;
  /**
   *
   * @type {number}
   * @memberof GenerateShoppingList200Response
   */
  startDate: number;
  /**
   *
   * @type {number}
   * @memberof GenerateShoppingList200Response
   */
  endDate: number;
}
/**
 *
 * @export
 * @interface GenerateShoppingListRequest
 */
export interface GenerateShoppingListRequest {
  /**
   * The username.
   * @type {string}
   * @memberof GenerateShoppingListRequest
   */
  username: string;
  /**
   * The start date in the format yyyy-mm-dd.
   * @type {string}
   * @memberof GenerateShoppingListRequest
   */
  "start-date": string;
  /**
   * The end date in the format yyyy-mm-dd.
   * @type {string}
   * @memberof GenerateShoppingListRequest
   */
  "end-date": string;
  /**
   * The private hash for the username.
   * @type {string}
   * @memberof GenerateShoppingListRequest
   */
  hash: string;
}
/**
 *
 * @export
 * @interface GetARandomFoodJoke200Response
 */
export interface GetARandomFoodJoke200Response {
  /**
   *
   * @type {string}
   * @memberof GetARandomFoodJoke200Response
   */
  text: string;
}
/**
 *
 * @export
 * @interface GetAnalyzedRecipeInstructions200Response
 */
export interface GetAnalyzedRecipeInstructions200Response {
  /**
   *
   * @type {Set<GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner>}
   * @memberof GetAnalyzedRecipeInstructions200Response
   */
  parsedInstructions: Set<GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner>;
  /**
   *
   * @type {Set<GetAnalyzedRecipeInstructions200ResponseIngredientsInner>}
   * @memberof GetAnalyzedRecipeInstructions200Response
   */
  ingredients: Set<GetAnalyzedRecipeInstructions200ResponseIngredientsInner>;
  /**
   *
   * @type {Set<GetAnalyzedRecipeInstructions200ResponseIngredientsInner>}
   * @memberof GetAnalyzedRecipeInstructions200Response
   */
  equipment: Set<GetAnalyzedRecipeInstructions200ResponseIngredientsInner>;
}
/**
 *
 * @export
 * @interface GetAnalyzedRecipeInstructions200ResponseIngredientsInner
 */
export interface GetAnalyzedRecipeInstructions200ResponseIngredientsInner {
  /**
   *
   * @type {number}
   * @memberof GetAnalyzedRecipeInstructions200ResponseIngredientsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof GetAnalyzedRecipeInstructions200ResponseIngredientsInner
   */
  name: string;
}
/**
 *
 * @export
 * @interface GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner
 */
export interface GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner {
  /**
   *
   * @type {string}
   * @memberof GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner
   */
  name: string;
  /**
   *
   * @type {Set<GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner>}
   * @memberof GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner
   */
  steps?: Set<GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner>;
}
/**
 *
 * @export
 * @interface GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
 */
export interface GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner {
  /**
   *
   * @type {number}
   * @memberof GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
   */
  number: number;
  /**
   *
   * @type {string}
   * @memberof GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
   */
  step: string;
  /**
   *
   * @type {Set<GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner>}
   * @memberof GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
   */
  ingredients?: Set<GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner>;
  /**
   *
   * @type {Set<GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner>}
   * @memberof GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
   */
  equipment?: Set<GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner>;
}
/**
 *
 * @export
 * @interface GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
 */
export interface GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner {
  /**
   *
   * @type {number}
   * @memberof GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
   */
  localizedName: string;
  /**
   *
   * @type {string}
   * @memberof GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
   */
  image: string;
}
/**
 *
 * @export
 * @interface GetComparableProducts200Response
 */
export interface GetComparableProducts200Response {
  /**
   *
   * @type {GetComparableProducts200ResponseComparableProducts}
   * @memberof GetComparableProducts200Response
   */
  comparableProducts: GetComparableProducts200ResponseComparableProducts;
}
/**
 *
 * @export
 * @interface GetComparableProducts200ResponseComparableProducts
 */
export interface GetComparableProducts200ResponseComparableProducts {
  /**
   *
   * @type {Array<object>}
   * @memberof GetComparableProducts200ResponseComparableProducts
   */
  calories: Array<object>;
  /**
   *
   * @type {Array<object>}
   * @memberof GetComparableProducts200ResponseComparableProducts
   */
  likes: Array<object>;
  /**
   *
   * @type {Array<object>}
   * @memberof GetComparableProducts200ResponseComparableProducts
   */
  price: Array<object>;
  /**
   *
   * @type {Set<GetComparableProducts200ResponseComparableProductsProteinInner>}
   * @memberof GetComparableProducts200ResponseComparableProducts
   */
  protein: Set<GetComparableProducts200ResponseComparableProductsProteinInner>;
  /**
   *
   * @type {Set<GetComparableProducts200ResponseComparableProductsProteinInner>}
   * @memberof GetComparableProducts200ResponseComparableProducts
   */
  spoonacularScore: Set<GetComparableProducts200ResponseComparableProductsProteinInner>;
  /**
   *
   * @type {Array<object>}
   * @memberof GetComparableProducts200ResponseComparableProducts
   */
  sugar: Array<object>;
}
/**
 *
 * @export
 * @interface GetComparableProducts200ResponseComparableProductsProteinInner
 */
export interface GetComparableProducts200ResponseComparableProductsProteinInner {
  /**
   *
   * @type {number}
   * @memberof GetComparableProducts200ResponseComparableProductsProteinInner
   */
  difference: number;
  /**
   *
   * @type {number}
   * @memberof GetComparableProducts200ResponseComparableProductsProteinInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof GetComparableProducts200ResponseComparableProductsProteinInner
   */
  image: string;
  /**
   *
   * @type {string}
   * @memberof GetComparableProducts200ResponseComparableProductsProteinInner
   */
  title: string;
}
/**
 *
 * @export
 * @interface GetConversationSuggests200Response
 */
export interface GetConversationSuggests200Response {
  /**
   *
   * @type {GetConversationSuggests200ResponseSuggests}
   * @memberof GetConversationSuggests200Response
   */
  suggests: GetConversationSuggests200ResponseSuggests;
  /**
   *
   * @type {Array<any>}
   * @memberof GetConversationSuggests200Response
   */
  words: Array<any>;
}
/**
 *
 * @export
 * @interface GetConversationSuggests200ResponseSuggests
 */
export interface GetConversationSuggests200ResponseSuggests {
  /**
   *
   * @type {Set<GetConversationSuggests200ResponseSuggestsInner>}
   * @memberof GetConversationSuggests200ResponseSuggests
   */
  _: Set<GetConversationSuggests200ResponseSuggestsInner>;
}
/**
 *
 * @export
 * @interface GetConversationSuggests200ResponseSuggestsInner
 */
export interface GetConversationSuggests200ResponseSuggestsInner {
  /**
   *
   * @type {string}
   * @memberof GetConversationSuggests200ResponseSuggestsInner
   */
  name: string;
}
/**
 *
 * @export
 * @interface GetDishPairingForWine200Response
 */
export interface GetDishPairingForWine200Response {
  /**
   *
   * @type {Array<string>}
   * @memberof GetDishPairingForWine200Response
   */
  pairings: Array<string>;
  /**
   *
   * @type {string}
   * @memberof GetDishPairingForWine200Response
   */
  text: string;
}
/**
 *
 * @export
 * @interface GetIngredientInformation200Response
 */
export interface GetIngredientInformation200Response {
  /**
   *
   * @type {number}
   * @memberof GetIngredientInformation200Response
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof GetIngredientInformation200Response
   */
  original: string;
  /**
   *
   * @type {string}
   * @memberof GetIngredientInformation200Response
   */
  originalName: string;
  /**
   *
   * @type {string}
   * @memberof GetIngredientInformation200Response
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof GetIngredientInformation200Response
   */
  nameClean: string;
  /**
   *
   * @type {number}
   * @memberof GetIngredientInformation200Response
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof GetIngredientInformation200Response
   */
  unit: string;
  /**
   *
   * @type {string}
   * @memberof GetIngredientInformation200Response
   */
  unitShort: string;
  /**
   *
   * @type {string}
   * @memberof GetIngredientInformation200Response
   */
  unitLong: string;
  /**
   *
   * @type {Array<string>}
   * @memberof GetIngredientInformation200Response
   */
  possibleUnits: Array<string>;
  /**
   *
   * @type {ParseIngredients200ResponseInnerEstimatedCost}
   * @memberof GetIngredientInformation200Response
   */
  estimatedCost: ParseIngredients200ResponseInnerEstimatedCost;
  /**
   *
   * @type {string}
   * @memberof GetIngredientInformation200Response
   */
  consistency: string;
  /**
   *
   * @type {Array<string>}
   * @memberof GetIngredientInformation200Response
   */
  shoppingListUnits: Array<string>;
  /**
   *
   * @type {string}
   * @memberof GetIngredientInformation200Response
   */
  aisle: string;
  /**
   *
   * @type {string}
   * @memberof GetIngredientInformation200Response
   */
  image: string;
  /**
   *
   * @type {Array<object>}
   * @memberof GetIngredientInformation200Response
   */
  meta: Array<object>;
  /**
   *
   * @type {GetIngredientInformation200ResponseNutrition}
   * @memberof GetIngredientInformation200Response
   */
  nutrition: GetIngredientInformation200ResponseNutrition;
  /**
   *
   * @type {Array<string>}
   * @memberof GetIngredientInformation200Response
   */
  categoryPath: Array<string>;
}
/**
 *
 * @export
 * @interface GetIngredientInformation200ResponseNutrition
 */
export interface GetIngredientInformation200ResponseNutrition {
  /**
   *
   * @type {Set<ParseIngredients200ResponseInnerNutritionNutrientsInner>}
   * @memberof GetIngredientInformation200ResponseNutrition
   */
  nutrients: Set<ParseIngredients200ResponseInnerNutritionNutrientsInner>;
  /**
   *
   * @type {Set<ParseIngredients200ResponseInnerNutritionPropertiesInner>}
   * @memberof GetIngredientInformation200ResponseNutrition
   */
  properties: Set<ParseIngredients200ResponseInnerNutritionPropertiesInner>;
  /**
   *
   * @type {ParseIngredients200ResponseInnerNutritionCaloricBreakdown}
   * @memberof GetIngredientInformation200ResponseNutrition
   */
  caloricBreakdown: ParseIngredients200ResponseInnerNutritionCaloricBreakdown;
  /**
   *
   * @type {ParseIngredients200ResponseInnerNutritionWeightPerServing}
   * @memberof GetIngredientInformation200ResponseNutrition
   */
  weightPerServing: ParseIngredients200ResponseInnerNutritionWeightPerServing;
}
/**
 *
 * @export
 * @interface GetIngredientSubstitutes200Response
 */
export interface GetIngredientSubstitutes200Response {
  /**
   *
   * @type {string}
   * @memberof GetIngredientSubstitutes200Response
   */
  ingredient: string;
  /**
   *
   * @type {Array<string>}
   * @memberof GetIngredientSubstitutes200Response
   */
  substitutes: Array<string>;
  /**
   *
   * @type {string}
   * @memberof GetIngredientSubstitutes200Response
   */
  message: string;
}
/**
 *
 * @export
 * @interface GetMealPlanTemplate200Response
 */
export interface GetMealPlanTemplate200Response {
  /**
   *
   * @type {number}
   * @memberof GetMealPlanTemplate200Response
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof GetMealPlanTemplate200Response
   */
  name: string;
  /**
   *
   * @type {Set<GetMealPlanTemplate200ResponseDaysInner>}
   * @memberof GetMealPlanTemplate200Response
   */
  days: Set<GetMealPlanTemplate200ResponseDaysInner>;
}
/**
 *
 * @export
 * @interface GetMealPlanTemplate200ResponseDaysInner
 */
export interface GetMealPlanTemplate200ResponseDaysInner {
  /**
   *
   * @type {GetMealPlanWeek200ResponseDaysInnerNutritionSummary}
   * @memberof GetMealPlanTemplate200ResponseDaysInner
   */
  nutritionSummary?: GetMealPlanWeek200ResponseDaysInnerNutritionSummary;
  /**
   *
   * @type {GetMealPlanWeek200ResponseDaysInnerNutritionSummary}
   * @memberof GetMealPlanTemplate200ResponseDaysInner
   */
  nutritionSummaryBreakfast?: GetMealPlanWeek200ResponseDaysInnerNutritionSummary;
  /**
   *
   * @type {GetMealPlanWeek200ResponseDaysInnerNutritionSummary}
   * @memberof GetMealPlanTemplate200ResponseDaysInner
   */
  nutritionSummaryLunch?: GetMealPlanWeek200ResponseDaysInnerNutritionSummary;
  /**
   *
   * @type {GetMealPlanWeek200ResponseDaysInnerNutritionSummary}
   * @memberof GetMealPlanTemplate200ResponseDaysInner
   */
  nutritionSummaryDinner?: GetMealPlanWeek200ResponseDaysInnerNutritionSummary;
  /**
   *
   * @type {string}
   * @memberof GetMealPlanTemplate200ResponseDaysInner
   */
  day: string;
  /**
   *
   * @type {Set<GetMealPlanTemplate200ResponseDaysInnerItemsInner>}
   * @memberof GetMealPlanTemplate200ResponseDaysInner
   */
  items?: Set<GetMealPlanTemplate200ResponseDaysInnerItemsInner>;
}
/**
 *
 * @export
 * @interface GetMealPlanTemplate200ResponseDaysInnerItemsInner
 */
export interface GetMealPlanTemplate200ResponseDaysInnerItemsInner {
  /**
   *
   * @type {number}
   * @memberof GetMealPlanTemplate200ResponseDaysInnerItemsInner
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof GetMealPlanTemplate200ResponseDaysInnerItemsInner
   */
  slot: number;
  /**
   *
   * @type {number}
   * @memberof GetMealPlanTemplate200ResponseDaysInnerItemsInner
   */
  position: number;
  /**
   *
   * @type {string}
   * @memberof GetMealPlanTemplate200ResponseDaysInnerItemsInner
   */
  type: string;
  /**
   *
   * @type {GetMealPlanTemplate200ResponseDaysInnerItemsInnerValue}
   * @memberof GetMealPlanTemplate200ResponseDaysInnerItemsInner
   */
  value?: GetMealPlanTemplate200ResponseDaysInnerItemsInnerValue;
}
/**
 *
 * @export
 * @interface GetMealPlanTemplate200ResponseDaysInnerItemsInnerValue
 */
export interface GetMealPlanTemplate200ResponseDaysInnerItemsInnerValue {
  /**
   *
   * @type {number}
   * @memberof GetMealPlanTemplate200ResponseDaysInnerItemsInnerValue
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof GetMealPlanTemplate200ResponseDaysInnerItemsInnerValue
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof GetMealPlanTemplate200ResponseDaysInnerItemsInnerValue
   */
  imageType: string;
}
/**
 *
 * @export
 * @interface GetMealPlanTemplates200Response
 */
export interface GetMealPlanTemplates200Response {
  /**
   *
   * @type {Set<GetAnalyzedRecipeInstructions200ResponseIngredientsInner>}
   * @memberof GetMealPlanTemplates200Response
   */
  templates: Set<GetAnalyzedRecipeInstructions200ResponseIngredientsInner>;
}
/**
 *
 * @export
 * @interface GetMealPlanWeek200Response
 */
export interface GetMealPlanWeek200Response {
  /**
   *
   * @type {Set<GetMealPlanWeek200ResponseDaysInner>}
   * @memberof GetMealPlanWeek200Response
   */
  days: Set<GetMealPlanWeek200ResponseDaysInner>;
}
/**
 *
 * @export
 * @interface GetMealPlanWeek200ResponseDaysInner
 */
export interface GetMealPlanWeek200ResponseDaysInner {
  /**
   *
   * @type {GetMealPlanWeek200ResponseDaysInnerNutritionSummary}
   * @memberof GetMealPlanWeek200ResponseDaysInner
   */
  nutritionSummary?: GetMealPlanWeek200ResponseDaysInnerNutritionSummary;
  /**
   *
   * @type {GetMealPlanWeek200ResponseDaysInnerNutritionSummary}
   * @memberof GetMealPlanWeek200ResponseDaysInner
   */
  nutritionSummaryBreakfast?: GetMealPlanWeek200ResponseDaysInnerNutritionSummary;
  /**
   *
   * @type {GetMealPlanWeek200ResponseDaysInnerNutritionSummary}
   * @memberof GetMealPlanWeek200ResponseDaysInner
   */
  nutritionSummaryLunch?: GetMealPlanWeek200ResponseDaysInnerNutritionSummary;
  /**
   *
   * @type {GetMealPlanWeek200ResponseDaysInnerNutritionSummary}
   * @memberof GetMealPlanWeek200ResponseDaysInner
   */
  nutritionSummaryDinner?: GetMealPlanWeek200ResponseDaysInnerNutritionSummary;
  /**
   *
   * @type {number}
   * @memberof GetMealPlanWeek200ResponseDaysInner
   */
  date: number;
  /**
   *
   * @type {string}
   * @memberof GetMealPlanWeek200ResponseDaysInner
   */
  day: string;
  /**
   *
   * @type {Set<GetMealPlanWeek200ResponseDaysInnerItemsInner>}
   * @memberof GetMealPlanWeek200ResponseDaysInner
   */
  items?: Set<GetMealPlanWeek200ResponseDaysInnerItemsInner>;
}
/**
 *
 * @export
 * @interface GetMealPlanWeek200ResponseDaysInnerItemsInner
 */
export interface GetMealPlanWeek200ResponseDaysInnerItemsInner {
  /**
   *
   * @type {number}
   * @memberof GetMealPlanWeek200ResponseDaysInnerItemsInner
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof GetMealPlanWeek200ResponseDaysInnerItemsInner
   */
  slot: number;
  /**
   *
   * @type {number}
   * @memberof GetMealPlanWeek200ResponseDaysInnerItemsInner
   */
  position: number;
  /**
   *
   * @type {string}
   * @memberof GetMealPlanWeek200ResponseDaysInnerItemsInner
   */
  type: string;
  /**
   *
   * @type {GetMealPlanWeek200ResponseDaysInnerItemsInnerValue}
   * @memberof GetMealPlanWeek200ResponseDaysInnerItemsInner
   */
  value?: GetMealPlanWeek200ResponseDaysInnerItemsInnerValue;
}
/**
 *
 * @export
 * @interface GetMealPlanWeek200ResponseDaysInnerItemsInnerValue
 */
export interface GetMealPlanWeek200ResponseDaysInnerItemsInnerValue {
  /**
   *
   * @type {number}
   * @memberof GetMealPlanWeek200ResponseDaysInnerItemsInnerValue
   */
  servings: number;
  /**
   *
   * @type {number}
   * @memberof GetMealPlanWeek200ResponseDaysInnerItemsInnerValue
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof GetMealPlanWeek200ResponseDaysInnerItemsInnerValue
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof GetMealPlanWeek200ResponseDaysInnerItemsInnerValue
   */
  imageType: string;
}
/**
 *
 * @export
 * @interface GetMealPlanWeek200ResponseDaysInnerNutritionSummary
 */
export interface GetMealPlanWeek200ResponseDaysInnerNutritionSummary {
  /**
   *
   * @type {Set<GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner>}
   * @memberof GetMealPlanWeek200ResponseDaysInnerNutritionSummary
   */
  nutrients: Set<GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner>;
}
/**
 *
 * @export
 * @interface GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner
 */
export interface GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner {
  /**
   *
   * @type {string}
   * @memberof GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner
   */
  unit: string;
  /**
   *
   * @type {number}
   * @memberof GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner
   */
  percentDailyNeeds: number;
}
/**
 *
 * @export
 * @interface GetMenuItemInformation200Response
 */
export interface GetMenuItemInformation200Response {
  /**
   *
   * @type {number}
   * @memberof GetMenuItemInformation200Response
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof GetMenuItemInformation200Response
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof GetMenuItemInformation200Response
   */
  restaurantChain: string;
  /**
   *
   * @type {SearchGroceryProductsByUPC200ResponseNutrition}
   * @memberof GetMenuItemInformation200Response
   */
  nutrition: SearchGroceryProductsByUPC200ResponseNutrition;
  /**
   *
   * @type {Array<string>}
   * @memberof GetMenuItemInformation200Response
   */
  badges: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof GetMenuItemInformation200Response
   */
  breadcrumbs: Array<string>;
  /**
   *
   * @type {string}
   * @memberof GetMenuItemInformation200Response
   */
  generatedText?: string;
  /**
   *
   * @type {string}
   * @memberof GetMenuItemInformation200Response
   */
  imageType: string;
  /**
   *
   * @type {number}
   * @memberof GetMenuItemInformation200Response
   */
  likes: number;
  /**
   *
   * @type {SearchGroceryProductsByUPC200ResponseServings}
   * @memberof GetMenuItemInformation200Response
   */
  servings: SearchGroceryProductsByUPC200ResponseServings;
  /**
   *
   * @type {number}
   * @memberof GetMenuItemInformation200Response
   */
  price?: number;
  /**
   *
   * @type {number}
   * @memberof GetMenuItemInformation200Response
   */
  spoonacularScore?: number;
}
/**
 *
 * @export
 * @interface GetProductInformation200Response
 */
export interface GetProductInformation200Response {
  /**
   *
   * @type {number}
   * @memberof GetProductInformation200Response
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof GetProductInformation200Response
   */
  title: string;
  /**
   *
   * @type {Array<string>}
   * @memberof GetProductInformation200Response
   */
  breadcrumbs: Array<string>;
  /**
   *
   * @type {string}
   * @memberof GetProductInformation200Response
   */
  imageType: string;
  /**
   *
   * @type {Array<string>}
   * @memberof GetProductInformation200Response
   */
  badges: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof GetProductInformation200Response
   */
  importantBadges: Array<string>;
  /**
   *
   * @type {number}
   * @memberof GetProductInformation200Response
   */
  ingredientCount: number;
  /**
   *
   * @type {any}
   * @memberof GetProductInformation200Response
   */
  generatedText?: any;
  /**
   *
   * @type {string}
   * @memberof GetProductInformation200Response
   */
  ingredientList: string;
  /**
   *
   * @type {Array<GetProductInformation200ResponseIngredientsInner>}
   * @memberof GetProductInformation200Response
   */
  ingredients: Array<GetProductInformation200ResponseIngredientsInner>;
  /**
   *
   * @type {number}
   * @memberof GetProductInformation200Response
   */
  likes: number;
  /**
   *
   * @type {string}
   * @memberof GetProductInformation200Response
   */
  aisle: string;
  /**
   *
   * @type {SearchGroceryProductsByUPC200ResponseNutrition}
   * @memberof GetProductInformation200Response
   */
  nutrition: SearchGroceryProductsByUPC200ResponseNutrition;
  /**
   *
   * @type {number}
   * @memberof GetProductInformation200Response
   */
  price: number;
  /**
   *
   * @type {SearchGroceryProductsByUPC200ResponseServings}
   * @memberof GetProductInformation200Response
   */
  servings: SearchGroceryProductsByUPC200ResponseServings;
  /**
   *
   * @type {number}
   * @memberof GetProductInformation200Response
   */
  spoonacularScore: number;
}
/**
 *
 * @export
 * @interface GetProductInformation200ResponseIngredientsInner
 */
export interface GetProductInformation200ResponseIngredientsInner {
  /**
   *
   * @type {any}
   * @memberof GetProductInformation200ResponseIngredientsInner
   */
  description?: any;
  /**
   *
   * @type {string}
   * @memberof GetProductInformation200ResponseIngredientsInner
   */
  name: string;
  /**
   *
   * @type {any}
   * @memberof GetProductInformation200ResponseIngredientsInner
   */
  safety_level?: any;
}
/**
 *
 * @export
 * @interface GetRandomFoodTrivia200Response
 */
export interface GetRandomFoodTrivia200Response {
  /**
   *
   * @type {string}
   * @memberof GetRandomFoodTrivia200Response
   */
  text: string;
}
/**
 *
 * @export
 * @interface GetRandomRecipes200Response
 */
export interface GetRandomRecipes200Response {
  /**
   *
   * @type {Set<GetRandomRecipes200ResponseRecipesInner>}
   * @memberof GetRandomRecipes200Response
   */
  recipes: Set<GetRandomRecipes200ResponseRecipesInner>;
}
/**
 *
 * @export
 * @interface GetRandomRecipes200ResponseRecipesInner
 */
export interface GetRandomRecipes200ResponseRecipesInner {
  /**
   *
   * @type {number}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  image: string;
  /**
   *
   * @type {string}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  imageType: string;
  /**
   *
   * @type {number}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  servings: number;
  /**
   *
   * @type {number}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  readyInMinutes: number;
  /**
   *
   * @type {string}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  license: string;
  /**
   *
   * @type {string}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  sourceName: string;
  /**
   *
   * @type {string}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  sourceUrl: string;
  /**
   *
   * @type {string}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  spoonacularSourceUrl: string;
  /**
   *
   * @type {number}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  aggregateLikes: number;
  /**
   *
   * @type {number}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  healthScore: number;
  /**
   *
   * @type {number}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  spoonacularScore: number;
  /**
   *
   * @type {number}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  pricePerServing: number;
  /**
   *
   * @type {Array<object>}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  analyzedInstructions?: Array<object>;
  /**
   *
   * @type {boolean}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  cheap: boolean;
  /**
   *
   * @type {string}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  creditsText: string;
  /**
   *
   * @type {Array<string>}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  cuisines?: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  dairyFree: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  diets?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  gaps: string;
  /**
   *
   * @type {boolean}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  glutenFree: boolean;
  /**
   *
   * @type {string}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  instructions: string;
  /**
   *
   * @type {boolean}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  ketogenic: boolean;
  /**
   *
   * @type {boolean}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  lowFodmap: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  occasions?: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  sustainable: boolean;
  /**
   *
   * @type {boolean}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  vegan: boolean;
  /**
   *
   * @type {boolean}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  vegetarian: boolean;
  /**
   *
   * @type {boolean}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  veryHealthy: boolean;
  /**
   *
   * @type {boolean}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  veryPopular: boolean;
  /**
   *
   * @type {boolean}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  whole30: boolean;
  /**
   *
   * @type {number}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  weightWatcherSmartPoints: number;
  /**
   *
   * @type {Array<string>}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  dishTypes?: Array<string>;
  /**
   *
   * @type {Set<GetRecipeInformation200ResponseExtendedIngredientsInner>}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  extendedIngredients?: Set<GetRecipeInformation200ResponseExtendedIngredientsInner>;
  /**
   *
   * @type {string}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  summary: string;
  /**
   *
   * @type {GetRecipeInformation200ResponseWinePairing}
   * @memberof GetRandomRecipes200ResponseRecipesInner
   */
  winePairing?: GetRecipeInformation200ResponseWinePairing;
}
/**
 *
 * @export
 * @interface GetRecipeEquipmentByID200Response
 */
export interface GetRecipeEquipmentByID200Response {
  /**
   *
   * @type {Set<GetRecipeEquipmentByID200ResponseEquipmentInner>}
   * @memberof GetRecipeEquipmentByID200Response
   */
  equipment: Set<GetRecipeEquipmentByID200ResponseEquipmentInner>;
}
/**
 *
 * @export
 * @interface GetRecipeEquipmentByID200ResponseEquipmentInner
 */
export interface GetRecipeEquipmentByID200ResponseEquipmentInner {
  /**
   *
   * @type {string}
   * @memberof GetRecipeEquipmentByID200ResponseEquipmentInner
   */
  image: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipeEquipmentByID200ResponseEquipmentInner
   */
  name: string;
}
/**
 *
 * @export
 * @interface GetRecipeInformation200Response
 */
export interface GetRecipeInformation200Response {
  /**
   *
   * @type {number}
   * @memberof GetRecipeInformation200Response
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200Response
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200Response
   */
  image: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200Response
   */
  imageType: string;
  /**
   *
   * @type {number}
   * @memberof GetRecipeInformation200Response
   */
  servings: number;
  /**
   *
   * @type {number}
   * @memberof GetRecipeInformation200Response
   */
  readyInMinutes: number;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200Response
   */
  license: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200Response
   */
  sourceName: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200Response
   */
  sourceUrl: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200Response
   */
  spoonacularSourceUrl: string;
  /**
   *
   * @type {number}
   * @memberof GetRecipeInformation200Response
   */
  aggregateLikes: number;
  /**
   *
   * @type {number}
   * @memberof GetRecipeInformation200Response
   */
  healthScore: number;
  /**
   *
   * @type {number}
   * @memberof GetRecipeInformation200Response
   */
  spoonacularScore: number;
  /**
   *
   * @type {number}
   * @memberof GetRecipeInformation200Response
   */
  pricePerServing: number;
  /**
   *
   * @type {Array<object>}
   * @memberof GetRecipeInformation200Response
   */
  analyzedInstructions: Array<object>;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeInformation200Response
   */
  cheap: boolean;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200Response
   */
  creditsText: string;
  /**
   *
   * @type {Array<string>}
   * @memberof GetRecipeInformation200Response
   */
  cuisines: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeInformation200Response
   */
  dairyFree: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof GetRecipeInformation200Response
   */
  diets: Array<string>;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200Response
   */
  gaps: string;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeInformation200Response
   */
  glutenFree: boolean;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200Response
   */
  instructions: string;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeInformation200Response
   */
  ketogenic: boolean;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeInformation200Response
   */
  lowFodmap: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof GetRecipeInformation200Response
   */
  occasions: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeInformation200Response
   */
  sustainable: boolean;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeInformation200Response
   */
  vegan: boolean;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeInformation200Response
   */
  vegetarian: boolean;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeInformation200Response
   */
  veryHealthy: boolean;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeInformation200Response
   */
  veryPopular: boolean;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeInformation200Response
   */
  whole30: boolean;
  /**
   *
   * @type {number}
   * @memberof GetRecipeInformation200Response
   */
  weightWatcherSmartPoints: number;
  /**
   *
   * @type {Array<string>}
   * @memberof GetRecipeInformation200Response
   */
  dishTypes: Array<string>;
  /**
   *
   * @type {Set<GetRecipeInformation200ResponseExtendedIngredientsInner>}
   * @memberof GetRecipeInformation200Response
   */
  extendedIngredients: Set<GetRecipeInformation200ResponseExtendedIngredientsInner>;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200Response
   */
  summary: string;
  /**
   *
   * @type {GetRecipeInformation200ResponseWinePairing}
   * @memberof GetRecipeInformation200Response
   */
  winePairing: GetRecipeInformation200ResponseWinePairing;
}
/**
 *
 * @export
 * @interface GetRecipeInformation200ResponseExtendedIngredientsInner
 */
export interface GetRecipeInformation200ResponseExtendedIngredientsInner {
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200ResponseExtendedIngredientsInner
   */
  aisle: string;
  /**
   *
   * @type {number}
   * @memberof GetRecipeInformation200ResponseExtendedIngredientsInner
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200ResponseExtendedIngredientsInner
   */
  consitency: string;
  /**
   *
   * @type {number}
   * @memberof GetRecipeInformation200ResponseExtendedIngredientsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200ResponseExtendedIngredientsInner
   */
  image: string;
  /**
   *
   * @type {GetRecipeInformation200ResponseExtendedIngredientsInnerMeasures}
   * @memberof GetRecipeInformation200ResponseExtendedIngredientsInner
   */
  measures?: GetRecipeInformation200ResponseExtendedIngredientsInnerMeasures;
  /**
   *
   * @type {Array<string>}
   * @memberof GetRecipeInformation200ResponseExtendedIngredientsInner
   */
  meta?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200ResponseExtendedIngredientsInner
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200ResponseExtendedIngredientsInner
   */
  original: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200ResponseExtendedIngredientsInner
   */
  originalName: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200ResponseExtendedIngredientsInner
   */
  unit: string;
}
/**
 *
 * @export
 * @interface GetRecipeInformation200ResponseExtendedIngredientsInnerMeasures
 */
export interface GetRecipeInformation200ResponseExtendedIngredientsInnerMeasures {
  /**
   *
   * @type {GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric}
   * @memberof GetRecipeInformation200ResponseExtendedIngredientsInnerMeasures
   */
  metric: GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric;
  /**
   *
   * @type {GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric}
   * @memberof GetRecipeInformation200ResponseExtendedIngredientsInnerMeasures
   */
  us: GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric;
}
/**
 *
 * @export
 * @interface GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric
 */
export interface GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric {
  /**
   *
   * @type {number}
   * @memberof GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric
   */
  unitLong: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric
   */
  unitShort: string;
}
/**
 *
 * @export
 * @interface GetRecipeInformation200ResponseWinePairing
 */
export interface GetRecipeInformation200ResponseWinePairing {
  /**
   *
   * @type {Array<string>}
   * @memberof GetRecipeInformation200ResponseWinePairing
   */
  pairedWines: Array<string>;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200ResponseWinePairing
   */
  pairingText: string;
  /**
   *
   * @type {Set<GetRecipeInformation200ResponseWinePairingProductMatchesInner>}
   * @memberof GetRecipeInformation200ResponseWinePairing
   */
  productMatches: Set<GetRecipeInformation200ResponseWinePairingProductMatchesInner>;
}
/**
 *
 * @export
 * @interface GetRecipeInformation200ResponseWinePairingProductMatchesInner
 */
export interface GetRecipeInformation200ResponseWinePairingProductMatchesInner {
  /**
   *
   * @type {number}
   * @memberof GetRecipeInformation200ResponseWinePairingProductMatchesInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200ResponseWinePairingProductMatchesInner
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200ResponseWinePairingProductMatchesInner
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200ResponseWinePairingProductMatchesInner
   */
  price: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200ResponseWinePairingProductMatchesInner
   */
  imageUrl: string;
  /**
   *
   * @type {number}
   * @memberof GetRecipeInformation200ResponseWinePairingProductMatchesInner
   */
  averageRating: number;
  /**
   *
   * @type {number}
   * @memberof GetRecipeInformation200ResponseWinePairingProductMatchesInner
   */
  ratingCount: number;
  /**
   *
   * @type {number}
   * @memberof GetRecipeInformation200ResponseWinePairingProductMatchesInner
   */
  score: number;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformation200ResponseWinePairingProductMatchesInner
   */
  link: string;
}
/**
 *
 * @export
 * @interface GetRecipeInformationBulk200ResponseInner
 */
export interface GetRecipeInformationBulk200ResponseInner {
  /**
   *
   * @type {number}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  image: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  imageType: string;
  /**
   *
   * @type {number}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  servings: number;
  /**
   *
   * @type {number}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  readyInMinutes: number;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  license: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  sourceName: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  sourceUrl: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  spoonacularSourceUrl: string;
  /**
   *
   * @type {number}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  aggregateLikes: number;
  /**
   *
   * @type {number}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  healthScore: number;
  /**
   *
   * @type {number}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  spoonacularScore: number;
  /**
   *
   * @type {number}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  pricePerServing: number;
  /**
   *
   * @type {Array<string>}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  analyzedInstructions: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  cheap: boolean;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  creditsText: string;
  /**
   *
   * @type {Array<string>}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  cuisines: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  dairyFree: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  diets: Array<string>;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  gaps: string;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  glutenFree: boolean;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  instructions: string;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  ketogenic: boolean;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  lowFodmap: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  occasions: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  sustainable: boolean;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  vegan: boolean;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  vegetarian: boolean;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  veryHealthy: boolean;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  veryPopular: boolean;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  whole30: boolean;
  /**
   *
   * @type {number}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  weightWatcherSmartPoints: number;
  /**
   *
   * @type {Array<string>}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  dishTypes: Array<string>;
  /**
   *
   * @type {Set<GetRecipeInformation200ResponseExtendedIngredientsInner>}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  extendedIngredients: Set<GetRecipeInformation200ResponseExtendedIngredientsInner>;
  /**
   *
   * @type {string}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  summary: string;
  /**
   *
   * @type {GetRecipeInformation200ResponseWinePairing}
   * @memberof GetRecipeInformationBulk200ResponseInner
   */
  winePairing: GetRecipeInformation200ResponseWinePairing;
}
/**
 *
 * @export
 * @interface GetRecipeIngredientsByID200Response
 */
export interface GetRecipeIngredientsByID200Response {
  /**
   *
   * @type {Set<GetRecipeIngredientsByID200ResponseIngredientsInner>}
   * @memberof GetRecipeIngredientsByID200Response
   */
  ingredients: Set<GetRecipeIngredientsByID200ResponseIngredientsInner>;
}
/**
 *
 * @export
 * @interface GetRecipeIngredientsByID200ResponseIngredientsInner
 */
export interface GetRecipeIngredientsByID200ResponseIngredientsInner {
  /**
   *
   * @type {GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount}
   * @memberof GetRecipeIngredientsByID200ResponseIngredientsInner
   */
  amount?: GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount;
  /**
   *
   * @type {string}
   * @memberof GetRecipeIngredientsByID200ResponseIngredientsInner
   */
  image: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipeIngredientsByID200ResponseIngredientsInner
   */
  name: string;
}
/**
 *
 * @export
 * @interface GetRecipeNutritionWidgetByID200Response
 */
export interface GetRecipeNutritionWidgetByID200Response {
  /**
   *
   * @type {string}
   * @memberof GetRecipeNutritionWidgetByID200Response
   */
  calories: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipeNutritionWidgetByID200Response
   */
  carbs: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipeNutritionWidgetByID200Response
   */
  fat: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipeNutritionWidgetByID200Response
   */
  protein: string;
  /**
   *
   * @type {Set<GetRecipeNutritionWidgetByID200ResponseBadInner>}
   * @memberof GetRecipeNutritionWidgetByID200Response
   */
  bad: Set<GetRecipeNutritionWidgetByID200ResponseBadInner>;
  /**
   *
   * @type {Set<GetRecipeNutritionWidgetByID200ResponseGoodInner>}
   * @memberof GetRecipeNutritionWidgetByID200Response
   */
  good: Set<GetRecipeNutritionWidgetByID200ResponseGoodInner>;
}
/**
 *
 * @export
 * @interface GetRecipeNutritionWidgetByID200ResponseBadInner
 */
export interface GetRecipeNutritionWidgetByID200ResponseBadInner {
  /**
   *
   * @type {string}
   * @memberof GetRecipeNutritionWidgetByID200ResponseBadInner
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipeNutritionWidgetByID200ResponseBadInner
   */
  amount: string;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeNutritionWidgetByID200ResponseBadInner
   */
  indented: boolean;
  /**
   *
   * @type {number}
   * @memberof GetRecipeNutritionWidgetByID200ResponseBadInner
   */
  percentOfDailyNeeds: number;
}
/**
 *
 * @export
 * @interface GetRecipeNutritionWidgetByID200ResponseGoodInner
 */
export interface GetRecipeNutritionWidgetByID200ResponseGoodInner {
  /**
   *
   * @type {string}
   * @memberof GetRecipeNutritionWidgetByID200ResponseGoodInner
   */
  amount: string;
  /**
   *
   * @type {boolean}
   * @memberof GetRecipeNutritionWidgetByID200ResponseGoodInner
   */
  indented: boolean;
  /**
   *
   * @type {number}
   * @memberof GetRecipeNutritionWidgetByID200ResponseGoodInner
   */
  percentOfDailyNeeds: number;
  /**
   *
   * @type {string}
   * @memberof GetRecipeNutritionWidgetByID200ResponseGoodInner
   */
  name: string;
}
/**
 *
 * @export
 * @interface GetRecipePriceBreakdownByID200Response
 */
export interface GetRecipePriceBreakdownByID200Response {
  /**
   *
   * @type {Set<GetRecipePriceBreakdownByID200ResponseIngredientsInner>}
   * @memberof GetRecipePriceBreakdownByID200Response
   */
  ingredients: Set<GetRecipePriceBreakdownByID200ResponseIngredientsInner>;
  /**
   *
   * @type {number}
   * @memberof GetRecipePriceBreakdownByID200Response
   */
  totalCost: number;
  /**
   *
   * @type {number}
   * @memberof GetRecipePriceBreakdownByID200Response
   */
  totalCostPerServing: number;
}
/**
 *
 * @export
 * @interface GetRecipePriceBreakdownByID200ResponseIngredientsInner
 */
export interface GetRecipePriceBreakdownByID200ResponseIngredientsInner {
  /**
   *
   * @type {GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount}
   * @memberof GetRecipePriceBreakdownByID200ResponseIngredientsInner
   */
  amount?: GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount;
  /**
   *
   * @type {string}
   * @memberof GetRecipePriceBreakdownByID200ResponseIngredientsInner
   */
  image: string;
  /**
   *
   * @type {string}
   * @memberof GetRecipePriceBreakdownByID200ResponseIngredientsInner
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof GetRecipePriceBreakdownByID200ResponseIngredientsInner
   */
  price: number;
}
/**
 *
 * @export
 * @interface GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount
 */
export interface GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount {
  /**
   *
   * @type {GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric}
   * @memberof GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount
   */
  metric: GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric;
  /**
   *
   * @type {GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric}
   * @memberof GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount
   */
  us: GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric;
}
/**
 *
 * @export
 * @interface GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric
 */
export interface GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric {
  /**
   *
   * @type {string}
   * @memberof GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric
   */
  unit: string;
  /**
   *
   * @type {number}
   * @memberof GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric
   */
  value: number;
}
/**
 *
 * @export
 * @interface GetRecipeTasteByID200Response
 */
export interface GetRecipeTasteByID200Response {
  /**
   *
   * @type {number}
   * @memberof GetRecipeTasteByID200Response
   */
  sweetness: number;
  /**
   *
   * @type {number}
   * @memberof GetRecipeTasteByID200Response
   */
  saltiness: number;
  /**
   *
   * @type {number}
   * @memberof GetRecipeTasteByID200Response
   */
  sourness: number;
  /**
   *
   * @type {number}
   * @memberof GetRecipeTasteByID200Response
   */
  bitterness: number;
  /**
   *
   * @type {number}
   * @memberof GetRecipeTasteByID200Response
   */
  savoriness: number;
  /**
   *
   * @type {number}
   * @memberof GetRecipeTasteByID200Response
   */
  fattiness: number;
  /**
   *
   * @type {number}
   * @memberof GetRecipeTasteByID200Response
   */
  spiciness: number;
}
/**
 *
 * @export
 * @interface GetShoppingList200Response
 */
export interface GetShoppingList200Response {
  /**
   *
   * @type {Set<GetShoppingList200ResponseAislesInner>}
   * @memberof GetShoppingList200Response
   */
  aisles: Set<GetShoppingList200ResponseAislesInner>;
  /**
   *
   * @type {number}
   * @memberof GetShoppingList200Response
   */
  cost: number;
  /**
   *
   * @type {number}
   * @memberof GetShoppingList200Response
   */
  startDate: number;
  /**
   *
   * @type {number}
   * @memberof GetShoppingList200Response
   */
  endDate: number;
}
/**
 *
 * @export
 * @interface GetShoppingList200ResponseAislesInner
 */
export interface GetShoppingList200ResponseAislesInner {
  /**
   *
   * @type {string}
   * @memberof GetShoppingList200ResponseAislesInner
   */
  aisle: string;
  /**
   *
   * @type {Set<GetShoppingList200ResponseAislesInnerItemsInner>}
   * @memberof GetShoppingList200ResponseAislesInner
   */
  items?: Set<GetShoppingList200ResponseAislesInnerItemsInner>;
}
/**
 *
 * @export
 * @interface GetShoppingList200ResponseAislesInnerItemsInner
 */
export interface GetShoppingList200ResponseAislesInnerItemsInner {
  /**
   *
   * @type {number}
   * @memberof GetShoppingList200ResponseAislesInnerItemsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof GetShoppingList200ResponseAislesInnerItemsInner
   */
  name: string;
  /**
   *
   * @type {GetShoppingList200ResponseAislesInnerItemsInnerMeasures}
   * @memberof GetShoppingList200ResponseAislesInnerItemsInner
   */
  measures?: GetShoppingList200ResponseAislesInnerItemsInnerMeasures;
  /**
   *
   * @type {boolean}
   * @memberof GetShoppingList200ResponseAislesInnerItemsInner
   */
  pantryItem: boolean;
  /**
   *
   * @type {string}
   * @memberof GetShoppingList200ResponseAislesInnerItemsInner
   */
  aisle: string;
  /**
   *
   * @type {number}
   * @memberof GetShoppingList200ResponseAislesInnerItemsInner
   */
  cost: number;
  /**
   *
   * @type {number}
   * @memberof GetShoppingList200ResponseAislesInnerItemsInner
   */
  ingredientId: number;
}
/**
 *
 * @export
 * @interface GetShoppingList200ResponseAislesInnerItemsInnerMeasures
 */
export interface GetShoppingList200ResponseAislesInnerItemsInnerMeasures {
  /**
   *
   * @type {ParseIngredients200ResponseInnerNutritionWeightPerServing}
   * @memberof GetShoppingList200ResponseAislesInnerItemsInnerMeasures
   */
  original: ParseIngredients200ResponseInnerNutritionWeightPerServing;
  /**
   *
   * @type {ParseIngredients200ResponseInnerNutritionWeightPerServing}
   * @memberof GetShoppingList200ResponseAislesInnerItemsInnerMeasures
   */
  metric: ParseIngredients200ResponseInnerNutritionWeightPerServing;
  /**
   *
   * @type {ParseIngredients200ResponseInnerNutritionWeightPerServing}
   * @memberof GetShoppingList200ResponseAislesInnerItemsInnerMeasures
   */
  us: ParseIngredients200ResponseInnerNutritionWeightPerServing;
}
/**
 *
 * @export
 * @interface GetSimilarRecipes200ResponseInner
 */
export interface GetSimilarRecipes200ResponseInner {
  /**
   *
   * @type {number}
   * @memberof GetSimilarRecipes200ResponseInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof GetSimilarRecipes200ResponseInner
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof GetSimilarRecipes200ResponseInner
   */
  imageType: string;
  /**
   *
   * @type {number}
   * @memberof GetSimilarRecipes200ResponseInner
   */
  readyInMinutes: number;
  /**
   *
   * @type {number}
   * @memberof GetSimilarRecipes200ResponseInner
   */
  servings: number;
  /**
   *
   * @type {string}
   * @memberof GetSimilarRecipes200ResponseInner
   */
  sourceUrl: string;
}
/**
 *
 * @export
 * @interface GetWineDescription200Response
 */
export interface GetWineDescription200Response {
  /**
   *
   * @type {string}
   * @memberof GetWineDescription200Response
   */
  wineDescription: string;
}
/**
 *
 * @export
 * @interface GetWinePairing200Response
 */
export interface GetWinePairing200Response {
  /**
   *
   * @type {Array<string>}
   * @memberof GetWinePairing200Response
   */
  pairedWines: Array<string>;
  /**
   *
   * @type {string}
   * @memberof GetWinePairing200Response
   */
  pairingText: string;
  /**
   *
   * @type {Set<GetWinePairing200ResponseProductMatchesInner>}
   * @memberof GetWinePairing200Response
   */
  productMatches: Set<GetWinePairing200ResponseProductMatchesInner>;
}
/**
 *
 * @export
 * @interface GetWinePairing200ResponseProductMatchesInner
 */
export interface GetWinePairing200ResponseProductMatchesInner {
  /**
   *
   * @type {number}
   * @memberof GetWinePairing200ResponseProductMatchesInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof GetWinePairing200ResponseProductMatchesInner
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof GetWinePairing200ResponseProductMatchesInner
   */
  averageRating: number;
  /**
   *
   * @type {any}
   * @memberof GetWinePairing200ResponseProductMatchesInner
   */
  description?: any;
  /**
   *
   * @type {string}
   * @memberof GetWinePairing200ResponseProductMatchesInner
   */
  imageUrl: string;
  /**
   *
   * @type {string}
   * @memberof GetWinePairing200ResponseProductMatchesInner
   */
  link: string;
  /**
   *
   * @type {string}
   * @memberof GetWinePairing200ResponseProductMatchesInner
   */
  price: string;
  /**
   *
   * @type {number}
   * @memberof GetWinePairing200ResponseProductMatchesInner
   */
  ratingCount: number;
  /**
   *
   * @type {number}
   * @memberof GetWinePairing200ResponseProductMatchesInner
   */
  score: number;
}
/**
 *
 * @export
 * @interface GetWineRecommendation200Response
 */
export interface GetWineRecommendation200Response {
  /**
   *
   * @type {Set<GetWineRecommendation200ResponseRecommendedWinesInner>}
   * @memberof GetWineRecommendation200Response
   */
  recommendedWines: Set<GetWineRecommendation200ResponseRecommendedWinesInner>;
  /**
   *
   * @type {number}
   * @memberof GetWineRecommendation200Response
   */
  totalFound: number;
}
/**
 *
 * @export
 * @interface GetWineRecommendation200ResponseRecommendedWinesInner
 */
export interface GetWineRecommendation200ResponseRecommendedWinesInner {
  /**
   *
   * @type {number}
   * @memberof GetWineRecommendation200ResponseRecommendedWinesInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof GetWineRecommendation200ResponseRecommendedWinesInner
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof GetWineRecommendation200ResponseRecommendedWinesInner
   */
  averageRating: number;
  /**
   *
   * @type {string}
   * @memberof GetWineRecommendation200ResponseRecommendedWinesInner
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof GetWineRecommendation200ResponseRecommendedWinesInner
   */
  imageUrl: string;
  /**
   *
   * @type {string}
   * @memberof GetWineRecommendation200ResponseRecommendedWinesInner
   */
  link: string;
  /**
   *
   * @type {string}
   * @memberof GetWineRecommendation200ResponseRecommendedWinesInner
   */
  price: string;
  /**
   *
   * @type {number}
   * @memberof GetWineRecommendation200ResponseRecommendedWinesInner
   */
  ratingCount: number;
  /**
   *
   * @type {number}
   * @memberof GetWineRecommendation200ResponseRecommendedWinesInner
   */
  score: number;
}
/**
 *
 * @export
 * @interface GuessNutritionByDishName200Response
 */
export interface GuessNutritionByDishName200Response {
  /**
   *
   * @type {GuessNutritionByDishName200ResponseCalories}
   * @memberof GuessNutritionByDishName200Response
   */
  calories: GuessNutritionByDishName200ResponseCalories;
  /**
   *
   * @type {GuessNutritionByDishName200ResponseCalories}
   * @memberof GuessNutritionByDishName200Response
   */
  carbs: GuessNutritionByDishName200ResponseCalories;
  /**
   *
   * @type {GuessNutritionByDishName200ResponseCalories}
   * @memberof GuessNutritionByDishName200Response
   */
  fat: GuessNutritionByDishName200ResponseCalories;
  /**
   *
   * @type {GuessNutritionByDishName200ResponseCalories}
   * @memberof GuessNutritionByDishName200Response
   */
  protein: GuessNutritionByDishName200ResponseCalories;
  /**
   *
   * @type {number}
   * @memberof GuessNutritionByDishName200Response
   */
  recipesUsed: number;
}
/**
 *
 * @export
 * @interface GuessNutritionByDishName200ResponseCalories
 */
export interface GuessNutritionByDishName200ResponseCalories {
  /**
   *
   * @type {GuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent}
   * @memberof GuessNutritionByDishName200ResponseCalories
   */
  confidenceRange95Percent: GuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent;
  /**
   *
   * @type {number}
   * @memberof GuessNutritionByDishName200ResponseCalories
   */
  standardDeviation: number;
  /**
   *
   * @type {string}
   * @memberof GuessNutritionByDishName200ResponseCalories
   */
  unit: string;
  /**
   *
   * @type {number}
   * @memberof GuessNutritionByDishName200ResponseCalories
   */
  value: number;
}
/**
 *
 * @export
 * @interface GuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent
 */
export interface GuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent {
  /**
   *
   * @type {number}
   * @memberof GuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent
   */
  max: number;
  /**
   *
   * @type {number}
   * @memberof GuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent
   */
  min: number;
}
/**
 *
 * @export
 * @interface ImageAnalysisByURL200Response
 */
export interface ImageAnalysisByURL200Response {
  /**
   *
   * @type {ImageAnalysisByURL200ResponseNutrition}
   * @memberof ImageAnalysisByURL200Response
   */
  nutrition: ImageAnalysisByURL200ResponseNutrition;
  /**
   *
   * @type {ImageAnalysisByURL200ResponseCategory}
   * @memberof ImageAnalysisByURL200Response
   */
  category: ImageAnalysisByURL200ResponseCategory;
  /**
   *
   * @type {Set<ImageAnalysisByURL200ResponseRecipesInner>}
   * @memberof ImageAnalysisByURL200Response
   */
  recipes: Set<ImageAnalysisByURL200ResponseRecipesInner>;
}
/**
 *
 * @export
 * @interface ImageAnalysisByURL200ResponseCategory
 */
export interface ImageAnalysisByURL200ResponseCategory {
  /**
   *
   * @type {string}
   * @memberof ImageAnalysisByURL200ResponseCategory
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof ImageAnalysisByURL200ResponseCategory
   */
  probability: number;
}
/**
 *
 * @export
 * @interface ImageAnalysisByURL200ResponseNutrition
 */
export interface ImageAnalysisByURL200ResponseNutrition {
  /**
   *
   * @type {number}
   * @memberof ImageAnalysisByURL200ResponseNutrition
   */
  recipesUsed: number;
  /**
   *
   * @type {ImageAnalysisByURL200ResponseNutritionCalories}
   * @memberof ImageAnalysisByURL200ResponseNutrition
   */
  calories: ImageAnalysisByURL200ResponseNutritionCalories;
  /**
   *
   * @type {ImageAnalysisByURL200ResponseNutritionCalories}
   * @memberof ImageAnalysisByURL200ResponseNutrition
   */
  fat: ImageAnalysisByURL200ResponseNutritionCalories;
  /**
   *
   * @type {ImageAnalysisByURL200ResponseNutritionCalories}
   * @memberof ImageAnalysisByURL200ResponseNutrition
   */
  protein: ImageAnalysisByURL200ResponseNutritionCalories;
  /**
   *
   * @type {ImageAnalysisByURL200ResponseNutritionCalories}
   * @memberof ImageAnalysisByURL200ResponseNutrition
   */
  carbs: ImageAnalysisByURL200ResponseNutritionCalories;
}
/**
 *
 * @export
 * @interface ImageAnalysisByURL200ResponseNutritionCalories
 */
export interface ImageAnalysisByURL200ResponseNutritionCalories {
  /**
   *
   * @type {number}
   * @memberof ImageAnalysisByURL200ResponseNutritionCalories
   */
  value: number;
  /**
   *
   * @type {string}
   * @memberof ImageAnalysisByURL200ResponseNutritionCalories
   */
  unit: string;
  /**
   *
   * @type {ImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent}
   * @memberof ImageAnalysisByURL200ResponseNutritionCalories
   */
  confidenceRange95Percent: ImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent;
  /**
   *
   * @type {number}
   * @memberof ImageAnalysisByURL200ResponseNutritionCalories
   */
  standardDeviation: number;
}
/**
 *
 * @export
 * @interface ImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent
 */
export interface ImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent {
  /**
   *
   * @type {number}
   * @memberof ImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent
   */
  min: number;
  /**
   *
   * @type {number}
   * @memberof ImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent
   */
  max: number;
}
/**
 *
 * @export
 * @interface ImageAnalysisByURL200ResponseRecipesInner
 */
export interface ImageAnalysisByURL200ResponseRecipesInner {
  /**
   *
   * @type {number}
   * @memberof ImageAnalysisByURL200ResponseRecipesInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof ImageAnalysisByURL200ResponseRecipesInner
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof ImageAnalysisByURL200ResponseRecipesInner
   */
  imageType: string;
  /**
   *
   * @type {string}
   * @memberof ImageAnalysisByURL200ResponseRecipesInner
   */
  url: string;
}
/**
 *
 * @export
 * @interface ImageClassificationByURL200Response
 */
export interface ImageClassificationByURL200Response {
  /**
   *
   * @type {string}
   * @memberof ImageClassificationByURL200Response
   */
  category: string;
  /**
   *
   * @type {number}
   * @memberof ImageClassificationByURL200Response
   */
  probability: number;
}
/**
 *
 * @export
 * @interface IngredientSearch200Response
 */
export interface IngredientSearch200Response {
  /**
   *
   * @type {Set<IngredientSearch200ResponseResultsInner>}
   * @memberof IngredientSearch200Response
   */
  results: Set<IngredientSearch200ResponseResultsInner>;
  /**
   *
   * @type {number}
   * @memberof IngredientSearch200Response
   */
  offset: number;
  /**
   *
   * @type {number}
   * @memberof IngredientSearch200Response
   */
  number: number;
  /**
   *
   * @type {number}
   * @memberof IngredientSearch200Response
   */
  totalResults: number;
}
/**
 *
 * @export
 * @interface IngredientSearch200ResponseResultsInner
 */
export interface IngredientSearch200ResponseResultsInner {
  /**
   *
   * @type {number}
   * @memberof IngredientSearch200ResponseResultsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof IngredientSearch200ResponseResultsInner
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof IngredientSearch200ResponseResultsInner
   */
  image: string;
}
/**
 *
 * @export
 * @interface MapIngredientsToGroceryProducts200ResponseInner
 */
export interface MapIngredientsToGroceryProducts200ResponseInner {
  /**
   *
   * @type {string}
   * @memberof MapIngredientsToGroceryProducts200ResponseInner
   */
  original: string;
  /**
   *
   * @type {string}
   * @memberof MapIngredientsToGroceryProducts200ResponseInner
   */
  originalName: string;
  /**
   *
   * @type {string}
   * @memberof MapIngredientsToGroceryProducts200ResponseInner
   */
  ingredientImage: string;
  /**
   *
   * @type {Array<string>}
   * @memberof MapIngredientsToGroceryProducts200ResponseInner
   */
  meta: Array<string>;
  /**
   *
   * @type {Set<MapIngredientsToGroceryProducts200ResponseInnerProductsInner>}
   * @memberof MapIngredientsToGroceryProducts200ResponseInner
   */
  products: Set<MapIngredientsToGroceryProducts200ResponseInnerProductsInner>;
}
/**
 *
 * @export
 * @interface MapIngredientsToGroceryProducts200ResponseInnerProductsInner
 */
export interface MapIngredientsToGroceryProducts200ResponseInnerProductsInner {
  /**
   *
   * @type {number}
   * @memberof MapIngredientsToGroceryProducts200ResponseInnerProductsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof MapIngredientsToGroceryProducts200ResponseInnerProductsInner
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof MapIngredientsToGroceryProducts200ResponseInnerProductsInner
   */
  upc: string;
}
/**
 *
 * @export
 * @interface MapIngredientsToGroceryProductsRequest
 */
export interface MapIngredientsToGroceryProductsRequest {
  /**
   *
   * @type {Array<string>}
   * @memberof MapIngredientsToGroceryProductsRequest
   */
  ingredients: Array<string>;
  /**
   *
   * @type {number}
   * @memberof MapIngredientsToGroceryProductsRequest
   */
  servings: number;
}
/**
 *
 * @export
 * @interface ParseIngredients200ResponseInner
 */
export interface ParseIngredients200ResponseInner {
  /**
   *
   * @type {number}
   * @memberof ParseIngredients200ResponseInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof ParseIngredients200ResponseInner
   */
  original: string;
  /**
   *
   * @type {string}
   * @memberof ParseIngredients200ResponseInner
   */
  originalName: string;
  /**
   *
   * @type {string}
   * @memberof ParseIngredients200ResponseInner
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ParseIngredients200ResponseInner
   */
  nameClean: string;
  /**
   *
   * @type {number}
   * @memberof ParseIngredients200ResponseInner
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof ParseIngredients200ResponseInner
   */
  unit: string;
  /**
   *
   * @type {string}
   * @memberof ParseIngredients200ResponseInner
   */
  unitShort: string;
  /**
   *
   * @type {string}
   * @memberof ParseIngredients200ResponseInner
   */
  unitLong: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ParseIngredients200ResponseInner
   */
  possibleUnits: Array<string>;
  /**
   *
   * @type {ParseIngredients200ResponseInnerEstimatedCost}
   * @memberof ParseIngredients200ResponseInner
   */
  estimatedCost: ParseIngredients200ResponseInnerEstimatedCost;
  /**
   *
   * @type {string}
   * @memberof ParseIngredients200ResponseInner
   */
  consistency: string;
  /**
   *
   * @type {string}
   * @memberof ParseIngredients200ResponseInner
   */
  aisle: string;
  /**
   *
   * @type {string}
   * @memberof ParseIngredients200ResponseInner
   */
  image: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ParseIngredients200ResponseInner
   */
  meta: Array<string>;
  /**
   *
   * @type {ParseIngredients200ResponseInnerNutrition}
   * @memberof ParseIngredients200ResponseInner
   */
  nutrition: ParseIngredients200ResponseInnerNutrition;
}
/**
 *
 * @export
 * @interface ParseIngredients200ResponseInnerEstimatedCost
 */
export interface ParseIngredients200ResponseInnerEstimatedCost {
  /**
   *
   * @type {number}
   * @memberof ParseIngredients200ResponseInnerEstimatedCost
   */
  value: number;
  /**
   *
   * @type {string}
   * @memberof ParseIngredients200ResponseInnerEstimatedCost
   */
  unit: string;
}
/**
 *
 * @export
 * @interface ParseIngredients200ResponseInnerNutrition
 */
export interface ParseIngredients200ResponseInnerNutrition {
  /**
   *
   * @type {Set<ParseIngredients200ResponseInnerNutritionNutrientsInner>}
   * @memberof ParseIngredients200ResponseInnerNutrition
   */
  nutrients: Set<ParseIngredients200ResponseInnerNutritionNutrientsInner>;
  /**
   *
   * @type {Set<ParseIngredients200ResponseInnerNutritionPropertiesInner>}
   * @memberof ParseIngredients200ResponseInnerNutrition
   */
  properties: Set<ParseIngredients200ResponseInnerNutritionPropertiesInner>;
  /**
   *
   * @type {Set<ParseIngredients200ResponseInnerNutritionPropertiesInner>}
   * @memberof ParseIngredients200ResponseInnerNutrition
   */
  flavonoids: Set<ParseIngredients200ResponseInnerNutritionPropertiesInner>;
  /**
   *
   * @type {ParseIngredients200ResponseInnerNutritionCaloricBreakdown}
   * @memberof ParseIngredients200ResponseInnerNutrition
   */
  caloricBreakdown: ParseIngredients200ResponseInnerNutritionCaloricBreakdown;
  /**
   *
   * @type {ParseIngredients200ResponseInnerNutritionWeightPerServing}
   * @memberof ParseIngredients200ResponseInnerNutrition
   */
  weightPerServing: ParseIngredients200ResponseInnerNutritionWeightPerServing;
}
/**
 *
 * @export
 * @interface ParseIngredients200ResponseInnerNutritionCaloricBreakdown
 */
export interface ParseIngredients200ResponseInnerNutritionCaloricBreakdown {
  /**
   *
   * @type {number}
   * @memberof ParseIngredients200ResponseInnerNutritionCaloricBreakdown
   */
  percentProtein: number;
  /**
   *
   * @type {number}
   * @memberof ParseIngredients200ResponseInnerNutritionCaloricBreakdown
   */
  percentFat: number;
  /**
   *
   * @type {number}
   * @memberof ParseIngredients200ResponseInnerNutritionCaloricBreakdown
   */
  percentCarbs: number;
}
/**
 *
 * @export
 * @interface ParseIngredients200ResponseInnerNutritionNutrientsInner
 */
export interface ParseIngredients200ResponseInnerNutritionNutrientsInner {
  /**
   *
   * @type {string}
   * @memberof ParseIngredients200ResponseInnerNutritionNutrientsInner
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof ParseIngredients200ResponseInnerNutritionNutrientsInner
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof ParseIngredients200ResponseInnerNutritionNutrientsInner
   */
  unit: string;
  /**
   *
   * @type {number}
   * @memberof ParseIngredients200ResponseInnerNutritionNutrientsInner
   */
  percentOfDailyNeeds: number;
}
/**
 *
 * @export
 * @interface ParseIngredients200ResponseInnerNutritionPropertiesInner
 */
export interface ParseIngredients200ResponseInnerNutritionPropertiesInner {
  /**
   *
   * @type {string}
   * @memberof ParseIngredients200ResponseInnerNutritionPropertiesInner
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof ParseIngredients200ResponseInnerNutritionPropertiesInner
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof ParseIngredients200ResponseInnerNutritionPropertiesInner
   */
  unit: string;
}
/**
 *
 * @export
 * @interface ParseIngredients200ResponseInnerNutritionWeightPerServing
 */
export interface ParseIngredients200ResponseInnerNutritionWeightPerServing {
  /**
   *
   * @type {number}
   * @memberof ParseIngredients200ResponseInnerNutritionWeightPerServing
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof ParseIngredients200ResponseInnerNutritionWeightPerServing
   */
  unit: string;
}
/**
 *
 * @export
 * @interface QuickAnswer200Response
 */
export interface QuickAnswer200Response {
  /**
   *
   * @type {string}
   * @memberof QuickAnswer200Response
   */
  answer: string;
  /**
   *
   * @type {string}
   * @memberof QuickAnswer200Response
   */
  image: string;
}
/**
 *
 * @export
 * @interface SearchAllFood200Response
 */
export interface SearchAllFood200Response {
  /**
   *
   * @type {string}
   * @memberof SearchAllFood200Response
   */
  query: string;
  /**
   *
   * @type {number}
   * @memberof SearchAllFood200Response
   */
  totalResults: number;
  /**
   *
   * @type {number}
   * @memberof SearchAllFood200Response
   */
  limit: number;
  /**
   *
   * @type {number}
   * @memberof SearchAllFood200Response
   */
  offset: number;
  /**
   *
   * @type {Set<SearchAllFood200ResponseSearchResultsInner>}
   * @memberof SearchAllFood200Response
   */
  searchResults: Set<SearchAllFood200ResponseSearchResultsInner>;
}
/**
 *
 * @export
 * @interface SearchAllFood200ResponseSearchResultsInner
 */
export interface SearchAllFood200ResponseSearchResultsInner {
  /**
   *
   * @type {string}
   * @memberof SearchAllFood200ResponseSearchResultsInner
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof SearchAllFood200ResponseSearchResultsInner
   */
  totalResults: number;
  /**
   *
   * @type {Set<SearchAllFood200ResponseSearchResultsInnerResultsInner>}
   * @memberof SearchAllFood200ResponseSearchResultsInner
   */
  results?: Set<SearchAllFood200ResponseSearchResultsInnerResultsInner>;
}
/**
 *
 * @export
 * @interface SearchAllFood200ResponseSearchResultsInnerResultsInner
 */
export interface SearchAllFood200ResponseSearchResultsInnerResultsInner {
  /**
   *
   * @type {string}
   * @memberof SearchAllFood200ResponseSearchResultsInnerResultsInner
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof SearchAllFood200ResponseSearchResultsInnerResultsInner
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof SearchAllFood200ResponseSearchResultsInnerResultsInner
   */
  image: string | null;
  /**
   *
   * @type {string}
   * @memberof SearchAllFood200ResponseSearchResultsInnerResultsInner
   */
  link: string | null;
  /**
   *
   * @type {string}
   * @memberof SearchAllFood200ResponseSearchResultsInnerResultsInner
   */
  type: string;
  /**
   *
   * @type {number}
   * @memberof SearchAllFood200ResponseSearchResultsInnerResultsInner
   */
  relevance: number;
  /**
   *
   * @type {string}
   * @memberof SearchAllFood200ResponseSearchResultsInnerResultsInner
   */
  content: string | null;
}
/**
 *
 * @export
 * @interface SearchCustomFoods200Response
 */
export interface SearchCustomFoods200Response {
  /**
   *
   * @type {Set<SearchCustomFoods200ResponseCustomFoodsInner>}
   * @memberof SearchCustomFoods200Response
   */
  customFoods: Set<SearchCustomFoods200ResponseCustomFoodsInner>;
  /**
   *
   * @type {string}
   * @memberof SearchCustomFoods200Response
   */
  type: string;
  /**
   *
   * @type {number}
   * @memberof SearchCustomFoods200Response
   */
  offset: number;
  /**
   *
   * @type {number}
   * @memberof SearchCustomFoods200Response
   */
  number: number;
}
/**
 *
 * @export
 * @interface SearchCustomFoods200ResponseCustomFoodsInner
 */
export interface SearchCustomFoods200ResponseCustomFoodsInner {
  /**
   *
   * @type {number}
   * @memberof SearchCustomFoods200ResponseCustomFoodsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof SearchCustomFoods200ResponseCustomFoodsInner
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof SearchCustomFoods200ResponseCustomFoodsInner
   */
  servings: number;
  /**
   *
   * @type {string}
   * @memberof SearchCustomFoods200ResponseCustomFoodsInner
   */
  imageUrl: string;
  /**
   *
   * @type {number}
   * @memberof SearchCustomFoods200ResponseCustomFoodsInner
   */
  price: number;
}
/**
 *
 * @export
 * @interface SearchFoodVideos200Response
 */
export interface SearchFoodVideos200Response {
  /**
   *
   * @type {Set<SearchFoodVideos200ResponseVideosInner>}
   * @memberof SearchFoodVideos200Response
   */
  videos: Set<SearchFoodVideos200ResponseVideosInner>;
  /**
   *
   * @type {number}
   * @memberof SearchFoodVideos200Response
   */
  totalResults: number;
}
/**
 *
 * @export
 * @interface SearchFoodVideos200ResponseVideosInner
 */
export interface SearchFoodVideos200ResponseVideosInner {
  /**
   *
   * @type {string}
   * @memberof SearchFoodVideos200ResponseVideosInner
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof SearchFoodVideos200ResponseVideosInner
   */
  length: number;
  /**
   *
   * @type {number}
   * @memberof SearchFoodVideos200ResponseVideosInner
   */
  rating: number;
  /**
   *
   * @type {string}
   * @memberof SearchFoodVideos200ResponseVideosInner
   */
  shortTitle: string;
  /**
   *
   * @type {string}
   * @memberof SearchFoodVideos200ResponseVideosInner
   */
  thumbnail: string;
  /**
   *
   * @type {number}
   * @memberof SearchFoodVideos200ResponseVideosInner
   */
  views: number;
  /**
   *
   * @type {string}
   * @memberof SearchFoodVideos200ResponseVideosInner
   */
  youTubeId: string;
}
/**
 *
 * @export
 * @interface SearchGroceryProducts200Response
 */
export interface SearchGroceryProducts200Response {
  /**
   *
   * @type {Set<AutocompleteRecipeSearch200ResponseInner>}
   * @memberof SearchGroceryProducts200Response
   */
  products: Set<AutocompleteRecipeSearch200ResponseInner>;
  /**
   *
   * @type {number}
   * @memberof SearchGroceryProducts200Response
   */
  totalProducts: number;
  /**
   *
   * @type {string}
   * @memberof SearchGroceryProducts200Response
   */
  type: string;
  /**
   *
   * @type {number}
   * @memberof SearchGroceryProducts200Response
   */
  offset: number;
  /**
   *
   * @type {number}
   * @memberof SearchGroceryProducts200Response
   */
  number: number;
}
/**
 *
 * @export
 * @interface SearchGroceryProductsByUPC200Response
 */
export interface SearchGroceryProductsByUPC200Response {
  /**
   *
   * @type {number}
   * @memberof SearchGroceryProductsByUPC200Response
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof SearchGroceryProductsByUPC200Response
   */
  title: string;
  /**
   *
   * @type {Array<string>}
   * @memberof SearchGroceryProductsByUPC200Response
   */
  badges: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof SearchGroceryProductsByUPC200Response
   */
  importantBadges: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof SearchGroceryProductsByUPC200Response
   */
  breadcrumbs: Array<string>;
  /**
   *
   * @type {string}
   * @memberof SearchGroceryProductsByUPC200Response
   */
  generatedText: string;
  /**
   *
   * @type {string}
   * @memberof SearchGroceryProductsByUPC200Response
   */
  imageType: string;
  /**
   *
   * @type {number}
   * @memberof SearchGroceryProductsByUPC200Response
   */
  ingredientCount?: number;
  /**
   *
   * @type {string}
   * @memberof SearchGroceryProductsByUPC200Response
   */
  ingredientList: string;
  /**
   *
   * @type {Set<SearchGroceryProductsByUPC200ResponseIngredientsInner>}
   * @memberof SearchGroceryProductsByUPC200Response
   */
  ingredients: Set<SearchGroceryProductsByUPC200ResponseIngredientsInner>;
  /**
   *
   * @type {number}
   * @memberof SearchGroceryProductsByUPC200Response
   */
  likes: number;
  /**
   *
   * @type {SearchGroceryProductsByUPC200ResponseNutrition}
   * @memberof SearchGroceryProductsByUPC200Response
   */
  nutrition: SearchGroceryProductsByUPC200ResponseNutrition;
  /**
   *
   * @type {number}
   * @memberof SearchGroceryProductsByUPC200Response
   */
  price: number;
  /**
   *
   * @type {SearchGroceryProductsByUPC200ResponseServings}
   * @memberof SearchGroceryProductsByUPC200Response
   */
  servings: SearchGroceryProductsByUPC200ResponseServings;
  /**
   *
   * @type {number}
   * @memberof SearchGroceryProductsByUPC200Response
   */
  spoonacularScore: number;
}
/**
 *
 * @export
 * @interface SearchGroceryProductsByUPC200ResponseIngredientsInner
 */
export interface SearchGroceryProductsByUPC200ResponseIngredientsInner {
  /**
   *
   * @type {any}
   * @memberof SearchGroceryProductsByUPC200ResponseIngredientsInner
   */
  description?: any;
  /**
   *
   * @type {string}
   * @memberof SearchGroceryProductsByUPC200ResponseIngredientsInner
   */
  name: string;
  /**
   *
   * @type {any}
   * @memberof SearchGroceryProductsByUPC200ResponseIngredientsInner
   */
  safety_level?: any;
}
/**
 *
 * @export
 * @interface SearchGroceryProductsByUPC200ResponseNutrition
 */
export interface SearchGroceryProductsByUPC200ResponseNutrition {
  /**
   *
   * @type {Set<ParseIngredients200ResponseInnerNutritionNutrientsInner>}
   * @memberof SearchGroceryProductsByUPC200ResponseNutrition
   */
  nutrients: Set<ParseIngredients200ResponseInnerNutritionNutrientsInner>;
  /**
   *
   * @type {ParseIngredients200ResponseInnerNutritionCaloricBreakdown}
   * @memberof SearchGroceryProductsByUPC200ResponseNutrition
   */
  caloricBreakdown: ParseIngredients200ResponseInnerNutritionCaloricBreakdown;
}
/**
 *
 * @export
 * @interface SearchGroceryProductsByUPC200ResponseServings
 */
export interface SearchGroceryProductsByUPC200ResponseServings {
  /**
   *
   * @type {number}
   * @memberof SearchGroceryProductsByUPC200ResponseServings
   */
  number: number;
  /**
   *
   * @type {number}
   * @memberof SearchGroceryProductsByUPC200ResponseServings
   */
  size: number;
  /**
   *
   * @type {string}
   * @memberof SearchGroceryProductsByUPC200ResponseServings
   */
  unit: string;
}
/**
 *
 * @export
 * @interface SearchMenuItems200Response
 */
export interface SearchMenuItems200Response {
  /**
   *
   * @type {Set<SearchMenuItems200ResponseMenuItemsInner>}
   * @memberof SearchMenuItems200Response
   */
  menuItems: Set<SearchMenuItems200ResponseMenuItemsInner>;
  /**
   *
   * @type {number}
   * @memberof SearchMenuItems200Response
   */
  totalMenuItems: number;
  /**
   *
   * @type {string}
   * @memberof SearchMenuItems200Response
   */
  type: string;
  /**
   *
   * @type {number}
   * @memberof SearchMenuItems200Response
   */
  offset: number;
  /**
   *
   * @type {number}
   * @memberof SearchMenuItems200Response
   */
  number: number;
}
/**
 *
 * @export
 * @interface SearchMenuItems200ResponseMenuItemsInner
 */
export interface SearchMenuItems200ResponseMenuItemsInner {
  /**
   *
   * @type {number}
   * @memberof SearchMenuItems200ResponseMenuItemsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof SearchMenuItems200ResponseMenuItemsInner
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof SearchMenuItems200ResponseMenuItemsInner
   */
  restaurantChain: string;
  /**
   *
   * @type {string}
   * @memberof SearchMenuItems200ResponseMenuItemsInner
   */
  image: string;
  /**
   *
   * @type {string}
   * @memberof SearchMenuItems200ResponseMenuItemsInner
   */
  imageType: string;
  /**
   *
   * @type {SearchGroceryProductsByUPC200ResponseServings}
   * @memberof SearchMenuItems200ResponseMenuItemsInner
   */
  servings?: SearchGroceryProductsByUPC200ResponseServings;
}
/**
 *
 * @export
 * @interface SearchRecipes200Response
 */
export interface SearchRecipes200Response {
  /**
   *
   * @type {number}
   * @memberof SearchRecipes200Response
   */
  offset: number;
  /**
   *
   * @type {number}
   * @memberof SearchRecipes200Response
   */
  number: number;
  /**
   *
   * @type {Set<SearchRecipes200ResponseResultsInner>}
   * @memberof SearchRecipes200Response
   */
  results: Set<SearchRecipes200ResponseResultsInner>;
  /**
   *
   * @type {number}
   * @memberof SearchRecipes200Response
   */
  totalResults: number;
}
/**
 *
 * @export
 * @interface SearchRecipes200ResponseResultsInner
 */
export interface SearchRecipes200ResponseResultsInner {
  /**
   *
   * @type {number}
   * @memberof SearchRecipes200ResponseResultsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof SearchRecipes200ResponseResultsInner
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof SearchRecipes200ResponseResultsInner
   */
  calories: number;
  /**
   *
   * @type {string}
   * @memberof SearchRecipes200ResponseResultsInner
   */
  carbs: string;
  /**
   *
   * @type {string}
   * @memberof SearchRecipes200ResponseResultsInner
   */
  fat: string;
  /**
   *
   * @type {string}
   * @memberof SearchRecipes200ResponseResultsInner
   */
  image: string;
  /**
   *
   * @type {string}
   * @memberof SearchRecipes200ResponseResultsInner
   */
  imageType: string;
  /**
   *
   * @type {string}
   * @memberof SearchRecipes200ResponseResultsInner
   */
  protein: string;
}
/**
 *
 * @export
 * @interface SearchRecipesByIngredients200ResponseInner
 */
export interface SearchRecipesByIngredients200ResponseInner {
  /**
   *
   * @type {number}
   * @memberof SearchRecipesByIngredients200ResponseInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof SearchRecipesByIngredients200ResponseInner
   */
  image: string;
  /**
   *
   * @type {string}
   * @memberof SearchRecipesByIngredients200ResponseInner
   */
  imageType: string;
  /**
   *
   * @type {number}
   * @memberof SearchRecipesByIngredients200ResponseInner
   */
  likes: number;
  /**
   *
   * @type {number}
   * @memberof SearchRecipesByIngredients200ResponseInner
   */
  missedIngredientCount: number;
  /**
   *
   * @type {Set<SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner>}
   * @memberof SearchRecipesByIngredients200ResponseInner
   */
  missedIngredients: Set<SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner>;
  /**
   *
   * @type {string}
   * @memberof SearchRecipesByIngredients200ResponseInner
   */
  title: string;
  /**
   *
   * @type {Array<object>}
   * @memberof SearchRecipesByIngredients200ResponseInner
   */
  unusedIngredients: Array<object>;
  /**
   *
   * @type {number}
   * @memberof SearchRecipesByIngredients200ResponseInner
   */
  usedIngredientCount: number;
  /**
   *
   * @type {Set<SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner>}
   * @memberof SearchRecipesByIngredients200ResponseInner
   */
  usedIngredients: Set<SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner>;
}
/**
 *
 * @export
 * @interface SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner
 */
export interface SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner {
  /**
   *
   * @type {string}
   * @memberof SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner
   */
  aisle: string;
  /**
   *
   * @type {number}
   * @memberof SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner
   */
  amount: number;
  /**
   *
   * @type {number}
   * @memberof SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner
   */
  image: string;
  /**
   *
   * @type {Array<string>}
   * @memberof SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner
   */
  meta?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner
   */
  original: string;
  /**
   *
   * @type {string}
   * @memberof SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner
   */
  originalName: string;
  /**
   *
   * @type {string}
   * @memberof SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner
   */
  unit: string;
  /**
   *
   * @type {string}
   * @memberof SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner
   */
  unitLong: string;
  /**
   *
   * @type {string}
   * @memberof SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner
   */
  unitShort: string;
}
/**
 *
 * @export
 * @interface SearchRecipesByNutrients200ResponseInner
 */
export interface SearchRecipesByNutrients200ResponseInner {
  /**
   *
   * @type {number}
   * @memberof SearchRecipesByNutrients200ResponseInner
   */
  calories: number;
  /**
   *
   * @type {string}
   * @memberof SearchRecipesByNutrients200ResponseInner
   */
  carbs: string;
  /**
   *
   * @type {string}
   * @memberof SearchRecipesByNutrients200ResponseInner
   */
  fat: string;
  /**
   *
   * @type {number}
   * @memberof SearchRecipesByNutrients200ResponseInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof SearchRecipesByNutrients200ResponseInner
   */
  image: string;
  /**
   *
   * @type {string}
   * @memberof SearchRecipesByNutrients200ResponseInner
   */
  imageType: string;
  /**
   *
   * @type {string}
   * @memberof SearchRecipesByNutrients200ResponseInner
   */
  protein: string;
  /**
   *
   * @type {string}
   * @memberof SearchRecipesByNutrients200ResponseInner
   */
  title: string;
}
/**
 *
 * @export
 * @interface SearchRestaurants200Response
 */
export interface SearchRestaurants200Response {
  /**
   *
   * @type {Array<SearchRestaurants200ResponseRestaurantsInner>}
   * @memberof SearchRestaurants200Response
   */
  restaurants?: Array<SearchRestaurants200ResponseRestaurantsInner>;
}
/**
 *
 * @export
 * @interface SearchRestaurants200ResponseRestaurantsInner
 */
export interface SearchRestaurants200ResponseRestaurantsInner {
  /**
   *
   * @type {string}
   * @memberof SearchRestaurants200ResponseRestaurantsInner
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof SearchRestaurants200ResponseRestaurantsInner
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof SearchRestaurants200ResponseRestaurantsInner
   */
  phone_number?: number;
  /**
   *
   * @type {SearchRestaurants200ResponseRestaurantsInnerAddress}
   * @memberof SearchRestaurants200ResponseRestaurantsInner
   */
  address?: SearchRestaurants200ResponseRestaurantsInnerAddress;
  /**
   *
   * @type {string}
   * @memberof SearchRestaurants200ResponseRestaurantsInner
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof SearchRestaurants200ResponseRestaurantsInner
   */
  description?: string;
  /**
   *
   * @type {SearchRestaurants200ResponseRestaurantsInnerLocalHours}
   * @memberof SearchRestaurants200ResponseRestaurantsInner
   */
  local_hours?: SearchRestaurants200ResponseRestaurantsInnerLocalHours;
  /**
   *
   * @type {Array<string>}
   * @memberof SearchRestaurants200ResponseRestaurantsInner
   */
  cuisines?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof SearchRestaurants200ResponseRestaurantsInner
   */
  food_photos?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof SearchRestaurants200ResponseRestaurantsInner
   */
  logo_photos?: Array<string>;
  /**
   *
   * @type {Array<object>}
   * @memberof SearchRestaurants200ResponseRestaurantsInner
   */
  store_photos?: Array<object>;
  /**
   *
   * @type {number}
   * @memberof SearchRestaurants200ResponseRestaurantsInner
   */
  dollar_signs?: number;
  /**
   *
   * @type {boolean}
   * @memberof SearchRestaurants200ResponseRestaurantsInner
   */
  pickup_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof SearchRestaurants200ResponseRestaurantsInner
   */
  delivery_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof SearchRestaurants200ResponseRestaurantsInner
   */
  is_open?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof SearchRestaurants200ResponseRestaurantsInner
   */
  offers_first_party_delivery?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof SearchRestaurants200ResponseRestaurantsInner
   */
  offers_third_party_delivery?: boolean;
  /**
   *
   * @type {number}
   * @memberof SearchRestaurants200ResponseRestaurantsInner
   */
  miles?: number;
  /**
   *
   * @type {number}
   * @memberof SearchRestaurants200ResponseRestaurantsInner
   */
  weighted_rating_value?: number;
  /**
   *
   * @type {number}
   * @memberof SearchRestaurants200ResponseRestaurantsInner
   */
  aggregated_rating_count?: number;
}
/**
 *
 * @export
 * @interface SearchRestaurants200ResponseRestaurantsInnerAddress
 */
export interface SearchRestaurants200ResponseRestaurantsInnerAddress {
  /**
   *
   * @type {string}
   * @memberof SearchRestaurants200ResponseRestaurantsInnerAddress
   */
  street_addr?: string;
  /**
   *
   * @type {string}
   * @memberof SearchRestaurants200ResponseRestaurantsInnerAddress
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof SearchRestaurants200ResponseRestaurantsInnerAddress
   */
  state?: string;
  /**
   *
   * @type {string}
   * @memberof SearchRestaurants200ResponseRestaurantsInnerAddress
   */
  zipcode?: string;
  /**
   *
   * @type {string}
   * @memberof SearchRestaurants200ResponseRestaurantsInnerAddress
   */
  country?: string;
  /**
   *
   * @type {number}
   * @memberof SearchRestaurants200ResponseRestaurantsInnerAddress
   */
  lat?: number;
  /**
   *
   * @type {number}
   * @memberof SearchRestaurants200ResponseRestaurantsInnerAddress
   */
  lon?: number;
  /**
   *
   * @type {string}
   * @memberof SearchRestaurants200ResponseRestaurantsInnerAddress
   */
  street_addr_2?: string;
  /**
   *
   * @type {number}
   * @memberof SearchRestaurants200ResponseRestaurantsInnerAddress
   */
  latitude?: number;
  /**
   *
   * @type {number}
   * @memberof SearchRestaurants200ResponseRestaurantsInnerAddress
   */
  longitude?: number;
}
/**
 *
 * @export
 * @interface SearchRestaurants200ResponseRestaurantsInnerLocalHours
 */
export interface SearchRestaurants200ResponseRestaurantsInnerLocalHours {
  /**
   *
   * @type {SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational}
   * @memberof SearchRestaurants200ResponseRestaurantsInnerLocalHours
   */
  operational?: SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational;
  /**
   *
   * @type {SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational}
   * @memberof SearchRestaurants200ResponseRestaurantsInnerLocalHours
   */
  delivery?: SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational;
  /**
   *
   * @type {SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational}
   * @memberof SearchRestaurants200ResponseRestaurantsInnerLocalHours
   */
  pickup?: SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational;
  /**
   *
   * @type {SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational}
   * @memberof SearchRestaurants200ResponseRestaurantsInnerLocalHours
   */
  dine_in?: SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational;
}
/**
 *
 * @export
 * @interface SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational
 */
export interface SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational {
  /**
   *
   * @type {string}
   * @memberof SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational
   */
  Monday?: string;
  /**
   *
   * @type {string}
   * @memberof SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational
   */
  Tuesday?: string;
  /**
   *
   * @type {string}
   * @memberof SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational
   */
  Wednesday?: string;
  /**
   *
   * @type {string}
   * @memberof SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational
   */
  Thursday?: string;
  /**
   *
   * @type {string}
   * @memberof SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational
   */
  Friday?: string;
  /**
   *
   * @type {string}
   * @memberof SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational
   */
  Saturday?: string;
  /**
   *
   * @type {string}
   * @memberof SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational
   */
  Sunday?: string;
}
/**
 *
 * @export
 * @interface SearchSiteContent200Response
 */
export interface SearchSiteContent200Response {
  /**
   *
   * @type {Set<SearchSiteContent200ResponseArticlesInner>}
   * @memberof SearchSiteContent200Response
   */
  Articles: Set<SearchSiteContent200ResponseArticlesInner>;
  /**
   *
   * @type {Set<SearchSiteContent200ResponseGroceryProductsInner>}
   * @memberof SearchSiteContent200Response
   */
  "Grocery Products": Set<SearchSiteContent200ResponseGroceryProductsInner>;
  /**
   *
   * @type {Set<SearchSiteContent200ResponseGroceryProductsInner>}
   * @memberof SearchSiteContent200Response
   */
  "Menu Items": Set<SearchSiteContent200ResponseGroceryProductsInner>;
  /**
   *
   * @type {Set<SearchSiteContent200ResponseGroceryProductsInner>}
   * @memberof SearchSiteContent200Response
   */
  Recipes: Set<SearchSiteContent200ResponseGroceryProductsInner>;
}
/**
 *
 * @export
 * @interface SearchSiteContent200ResponseArticlesInner
 */
export interface SearchSiteContent200ResponseArticlesInner {
  /**
   *
   * @type {Array<any>}
   * @memberof SearchSiteContent200ResponseArticlesInner
   */
  dataPoints?: Array<any>;
  /**
   *
   * @type {string}
   * @memberof SearchSiteContent200ResponseArticlesInner
   */
  image: string;
  /**
   *
   * @type {string}
   * @memberof SearchSiteContent200ResponseArticlesInner
   */
  link: string;
  /**
   *
   * @type {string}
   * @memberof SearchSiteContent200ResponseArticlesInner
   */
  name: string;
}
/**
 *
 * @export
 * @interface SearchSiteContent200ResponseGroceryProductsInner
 */
export interface SearchSiteContent200ResponseGroceryProductsInner {
  /**
   *
   * @type {Set<SearchSiteContent200ResponseGroceryProductsInnerDataPointsInner>}
   * @memberof SearchSiteContent200ResponseGroceryProductsInner
   */
  dataPoints?: Set<SearchSiteContent200ResponseGroceryProductsInnerDataPointsInner>;
  /**
   *
   * @type {string}
   * @memberof SearchSiteContent200ResponseGroceryProductsInner
   */
  image: string;
  /**
   *
   * @type {string}
   * @memberof SearchSiteContent200ResponseGroceryProductsInner
   */
  link: string;
  /**
   *
   * @type {string}
   * @memberof SearchSiteContent200ResponseGroceryProductsInner
   */
  name: string;
}
/**
 *
 * @export
 * @interface SearchSiteContent200ResponseGroceryProductsInnerDataPointsInner
 */
export interface SearchSiteContent200ResponseGroceryProductsInnerDataPointsInner {
  /**
   *
   * @type {string}
   * @memberof SearchSiteContent200ResponseGroceryProductsInnerDataPointsInner
   */
  key: string;
  /**
   *
   * @type {string}
   * @memberof SearchSiteContent200ResponseGroceryProductsInnerDataPointsInner
   */
  value: string;
}
/**
 *
 * @export
 * @interface SummarizeRecipe200Response
 */
export interface SummarizeRecipe200Response {
  /**
   *
   * @type {number}
   * @memberof SummarizeRecipe200Response
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof SummarizeRecipe200Response
   */
  summary: string;
  /**
   *
   * @type {string}
   * @memberof SummarizeRecipe200Response
   */
  title: string;
}
/**
 *
 * @export
 * @interface TalkToChatbot200Response
 */
export interface TalkToChatbot200Response {
  /**
   *
   * @type {string}
   * @memberof TalkToChatbot200Response
   */
  answerText: string;
  /**
   *
   * @type {Array<any>}
   * @memberof TalkToChatbot200Response
   */
  media: Array<any>;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * This endpoint allows you to send raw recipe information, such as title, servings, and ingredients, to then see what we compute (badges, diets, nutrition, and more). This is useful if you have your own recipe data and want to enrich it with our semantic analysis.
     * @summary Analyze Recipe
     * @param {AnalyzeRecipeRequest} analyzeRecipeRequest Example request body.
     * @param {string} [language] The input language, either \&quot;en\&quot; or \&quot;de\&quot;.
     * @param {boolean} [includeNutrition] Whether nutrition data should be added to correctly parsed ingredients.
     * @param {boolean} [includeTaste] Whether taste data should be added to correctly parsed ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    analyzeRecipe: async (
      analyzeRecipeRequest: AnalyzeRecipeRequest,
      language?: string,
      includeNutrition?: boolean,
      includeTaste?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'analyzeRecipeRequest' is not null or undefined
      assertParamExists(
        "analyzeRecipe",
        "analyzeRecipeRequest",
        analyzeRecipeRequest
      );
      const localVarPath = `/recipes/analyze`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (includeNutrition !== undefined) {
        localVarQueryParameter["includeNutrition"] = includeNutrition;
      }

      if (includeTaste !== undefined) {
        localVarQueryParameter["includeTaste"] = includeTaste;
      }

      localVarHeaderParameter["Content-Type"] = "";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        analyzeRecipeRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Generate a recipe card for a recipe.
     * @summary Create Recipe Card
     * @param {number} id The recipe id.
     * @param {string} [mask] The mask to put over the recipe image (\&quot;ellipseMask\&quot;, \&quot;diamondMask\&quot;, \&quot;starMask\&quot;, \&quot;heartMask\&quot;, \&quot;potMask\&quot;, \&quot;fishMask\&quot;).
     * @param {string} [backgroundImage] The background image (\&quot;none\&quot;,\&quot;background1\&quot;, or \&quot;background2\&quot;).
     * @param {string} [backgroundColor] The background color for the recipe card as a hex-string.
     * @param {string} [fontColor] The font color for the recipe card as a hex-string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRecipeCardGet: async (
      id: number,
      mask?: string,
      backgroundImage?: string,
      backgroundColor?: string,
      fontColor?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("createRecipeCardGet", "id", id);
      const localVarPath = `/recipes/{id}/card`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (mask !== undefined) {
        localVarQueryParameter["mask"] = mask;
      }

      if (backgroundImage !== undefined) {
        localVarQueryParameter["backgroundImage"] = backgroundImage;
      }

      if (backgroundColor !== undefined) {
        localVarQueryParameter["backgroundColor"] = backgroundColor;
      }

      if (fontColor !== undefined) {
        localVarQueryParameter["fontColor"] = fontColor;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Search through thousands of restaurants (in North America) by location, cuisine, budget, and more.
     * @summary Search Restaurants
     * @param {string} [query] The search query.
     * @param {number} [lat] The latitude of the user\&#39;s location.
     * @param {number} [lng] The longitude of the user\&#39;s location.\&quot;.
     * @param {number} [distance] The distance around the location in miles.
     * @param {number} [budget] The user\&#39;s budget for a meal in USD.
     * @param {string} [cuisine] The cuisine of the restaurant.
     * @param {number} [minRating] The minimum rating of the restaurant between 0 and 5.
     * @param {boolean} [isOpen] Whether the restaurant must be open at the time of search.
     * @param {string} [sort] How to sort the results, one of the following \&#39;cheapest\&#39;, \&#39;fastest\&#39;, \&#39;rating\&#39;, \&#39;distance\&#39; or the default \&#39;relevance\&#39;.
     * @param {number} [page] The page number of results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchRestaurants: async (
      query?: string,
      lat?: number,
      lng?: number,
      distance?: number,
      budget?: number,
      cuisine?: string,
      minRating?: number,
      isOpen?: boolean,
      sort?: string,
      page?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/food/restaurants/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (query !== undefined) {
        localVarQueryParameter["query"] = query;
      }

      if (lat !== undefined) {
        localVarQueryParameter["lat"] = lat;
      }

      if (lng !== undefined) {
        localVarQueryParameter["lng"] = lng;
      }

      if (distance !== undefined) {
        localVarQueryParameter["distance"] = distance;
      }

      if (budget !== undefined) {
        localVarQueryParameter["budget"] = budget;
      }

      if (cuisine !== undefined) {
        localVarQueryParameter["cuisine"] = cuisine;
      }

      if (minRating !== undefined) {
        localVarQueryParameter["min-rating"] = minRating;
      }

      if (isOpen !== undefined) {
        localVarQueryParameter["is-open"] = isOpen;
      }

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     * This endpoint allows you to send raw recipe information, such as title, servings, and ingredients, to then see what we compute (badges, diets, nutrition, and more). This is useful if you have your own recipe data and want to enrich it with our semantic analysis.
     * @summary Analyze Recipe
     * @param {AnalyzeRecipeRequest} analyzeRecipeRequest Example request body.
     * @param {string} [language] The input language, either \&quot;en\&quot; or \&quot;de\&quot;.
     * @param {boolean} [includeNutrition] Whether nutrition data should be added to correctly parsed ingredients.
     * @param {boolean} [includeTaste] Whether taste data should be added to correctly parsed ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async analyzeRecipe(
      analyzeRecipeRequest: AnalyzeRecipeRequest,
      language?: string,
      includeNutrition?: boolean,
      includeTaste?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.analyzeRecipe(
        analyzeRecipeRequest,
        language,
        includeNutrition,
        includeTaste,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DefaultApi.analyzeRecipe"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Generate a recipe card for a recipe.
     * @summary Create Recipe Card
     * @param {number} id The recipe id.
     * @param {string} [mask] The mask to put over the recipe image (\&quot;ellipseMask\&quot;, \&quot;diamondMask\&quot;, \&quot;starMask\&quot;, \&quot;heartMask\&quot;, \&quot;potMask\&quot;, \&quot;fishMask\&quot;).
     * @param {string} [backgroundImage] The background image (\&quot;none\&quot;,\&quot;background1\&quot;, or \&quot;background2\&quot;).
     * @param {string} [backgroundColor] The background color for the recipe card as a hex-string.
     * @param {string} [fontColor] The font color for the recipe card as a hex-string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRecipeCardGet(
      id: number,
      mask?: string,
      backgroundImage?: string,
      backgroundColor?: string,
      fontColor?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createRecipeCardGet(
          id,
          mask,
          backgroundImage,
          backgroundColor,
          fontColor,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DefaultApi.createRecipeCardGet"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Search through thousands of restaurants (in North America) by location, cuisine, budget, and more.
     * @summary Search Restaurants
     * @param {string} [query] The search query.
     * @param {number} [lat] The latitude of the user\&#39;s location.
     * @param {number} [lng] The longitude of the user\&#39;s location.\&quot;.
     * @param {number} [distance] The distance around the location in miles.
     * @param {number} [budget] The user\&#39;s budget for a meal in USD.
     * @param {string} [cuisine] The cuisine of the restaurant.
     * @param {number} [minRating] The minimum rating of the restaurant between 0 and 5.
     * @param {boolean} [isOpen] Whether the restaurant must be open at the time of search.
     * @param {string} [sort] How to sort the results, one of the following \&#39;cheapest\&#39;, \&#39;fastest\&#39;, \&#39;rating\&#39;, \&#39;distance\&#39; or the default \&#39;relevance\&#39;.
     * @param {number} [page] The page number of results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchRestaurants(
      query?: string,
      lat?: number,
      lng?: number,
      distance?: number,
      budget?: number,
      cuisine?: string,
      minRating?: number,
      isOpen?: boolean,
      sort?: string,
      page?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SearchRestaurants200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.searchRestaurants(
          query,
          lat,
          lng,
          distance,
          budget,
          cuisine,
          minRating,
          isOpen,
          sort,
          page,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DefaultApi.searchRestaurants"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     * This endpoint allows you to send raw recipe information, such as title, servings, and ingredients, to then see what we compute (badges, diets, nutrition, and more). This is useful if you have your own recipe data and want to enrich it with our semantic analysis.
     * @summary Analyze Recipe
     * @param {AnalyzeRecipeRequest} analyzeRecipeRequest Example request body.
     * @param {string} [language] The input language, either \&quot;en\&quot; or \&quot;de\&quot;.
     * @param {boolean} [includeNutrition] Whether nutrition data should be added to correctly parsed ingredients.
     * @param {boolean} [includeTaste] Whether taste data should be added to correctly parsed ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    analyzeRecipe(
      analyzeRecipeRequest: AnalyzeRecipeRequest,
      language?: string,
      includeNutrition?: boolean,
      includeTaste?: boolean,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .analyzeRecipe(
          analyzeRecipeRequest,
          language,
          includeNutrition,
          includeTaste,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Generate a recipe card for a recipe.
     * @summary Create Recipe Card
     * @param {number} id The recipe id.
     * @param {string} [mask] The mask to put over the recipe image (\&quot;ellipseMask\&quot;, \&quot;diamondMask\&quot;, \&quot;starMask\&quot;, \&quot;heartMask\&quot;, \&quot;potMask\&quot;, \&quot;fishMask\&quot;).
     * @param {string} [backgroundImage] The background image (\&quot;none\&quot;,\&quot;background1\&quot;, or \&quot;background2\&quot;).
     * @param {string} [backgroundColor] The background color for the recipe card as a hex-string.
     * @param {string} [fontColor] The font color for the recipe card as a hex-string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRecipeCardGet(
      id: number,
      mask?: string,
      backgroundImage?: string,
      backgroundColor?: string,
      fontColor?: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .createRecipeCardGet(
          id,
          mask,
          backgroundImage,
          backgroundColor,
          fontColor,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Search through thousands of restaurants (in North America) by location, cuisine, budget, and more.
     * @summary Search Restaurants
     * @param {string} [query] The search query.
     * @param {number} [lat] The latitude of the user\&#39;s location.
     * @param {number} [lng] The longitude of the user\&#39;s location.\&quot;.
     * @param {number} [distance] The distance around the location in miles.
     * @param {number} [budget] The user\&#39;s budget for a meal in USD.
     * @param {string} [cuisine] The cuisine of the restaurant.
     * @param {number} [minRating] The minimum rating of the restaurant between 0 and 5.
     * @param {boolean} [isOpen] Whether the restaurant must be open at the time of search.
     * @param {string} [sort] How to sort the results, one of the following \&#39;cheapest\&#39;, \&#39;fastest\&#39;, \&#39;rating\&#39;, \&#39;distance\&#39; or the default \&#39;relevance\&#39;.
     * @param {number} [page] The page number of results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchRestaurants(
      query?: string,
      lat?: number,
      lng?: number,
      distance?: number,
      budget?: number,
      cuisine?: string,
      minRating?: number,
      isOpen?: boolean,
      sort?: string,
      page?: number,
      options?: any
    ): AxiosPromise<SearchRestaurants200Response> {
      return localVarFp
        .searchRestaurants(
          query,
          lat,
          lng,
          distance,
          budget,
          cuisine,
          minRating,
          isOpen,
          sort,
          page,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * This endpoint allows you to send raw recipe information, such as title, servings, and ingredients, to then see what we compute (badges, diets, nutrition, and more). This is useful if you have your own recipe data and want to enrich it with our semantic analysis.
   * @summary Analyze Recipe
   * @param {AnalyzeRecipeRequest} analyzeRecipeRequest Example request body.
   * @param {string} [language] The input language, either \&quot;en\&quot; or \&quot;de\&quot;.
   * @param {boolean} [includeNutrition] Whether nutrition data should be added to correctly parsed ingredients.
   * @param {boolean} [includeTaste] Whether taste data should be added to correctly parsed ingredients.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public analyzeRecipe(
    analyzeRecipeRequest: AnalyzeRecipeRequest,
    language?: string,
    includeNutrition?: boolean,
    includeTaste?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .analyzeRecipe(
        analyzeRecipeRequest,
        language,
        includeNutrition,
        includeTaste,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Generate a recipe card for a recipe.
   * @summary Create Recipe Card
   * @param {number} id The recipe id.
   * @param {string} [mask] The mask to put over the recipe image (\&quot;ellipseMask\&quot;, \&quot;diamondMask\&quot;, \&quot;starMask\&quot;, \&quot;heartMask\&quot;, \&quot;potMask\&quot;, \&quot;fishMask\&quot;).
   * @param {string} [backgroundImage] The background image (\&quot;none\&quot;,\&quot;background1\&quot;, or \&quot;background2\&quot;).
   * @param {string} [backgroundColor] The background color for the recipe card as a hex-string.
   * @param {string} [fontColor] The font color for the recipe card as a hex-string.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createRecipeCardGet(
    id: number,
    mask?: string,
    backgroundImage?: string,
    backgroundColor?: string,
    fontColor?: string,
    options?: RawAxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .createRecipeCardGet(
        id,
        mask,
        backgroundImage,
        backgroundColor,
        fontColor,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Search through thousands of restaurants (in North America) by location, cuisine, budget, and more.
   * @summary Search Restaurants
   * @param {string} [query] The search query.
   * @param {number} [lat] The latitude of the user\&#39;s location.
   * @param {number} [lng] The longitude of the user\&#39;s location.\&quot;.
   * @param {number} [distance] The distance around the location in miles.
   * @param {number} [budget] The user\&#39;s budget for a meal in USD.
   * @param {string} [cuisine] The cuisine of the restaurant.
   * @param {number} [minRating] The minimum rating of the restaurant between 0 and 5.
   * @param {boolean} [isOpen] Whether the restaurant must be open at the time of search.
   * @param {string} [sort] How to sort the results, one of the following \&#39;cheapest\&#39;, \&#39;fastest\&#39;, \&#39;rating\&#39;, \&#39;distance\&#39; or the default \&#39;relevance\&#39;.
   * @param {number} [page] The page number of results.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public searchRestaurants(
    query?: string,
    lat?: number,
    lng?: number,
    distance?: number,
    budget?: number,
    cuisine?: string,
    minRating?: number,
    isOpen?: boolean,
    sort?: string,
    page?: number,
    options?: RawAxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .searchRestaurants(
        query,
        lat,
        lng,
        distance,
        budget,
        cuisine,
        minRating,
        isOpen,
        sort,
        page,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * IngredientsApi - axios parameter creator
 * @export
 */
export const IngredientsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Autocomplete the entry of an ingredient.
     * @summary Autocomplete Ingredient Search
     * @param {string} [query] The (natural language) search query.
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {boolean} [metaInformation] Whether to return more meta information about the ingredients.
     * @param {string} [intolerances] A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.
     * @param {AutocompleteIngredientSearchLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autocompleteIngredientSearch: async (
      query?: string,
      number?: number,
      metaInformation?: boolean,
      intolerances?: string,
      language?: AutocompleteIngredientSearchLanguageEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/food/ingredients/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (query !== undefined) {
        localVarQueryParameter["query"] = query;
      }

      if (number !== undefined) {
        localVarQueryParameter["number"] = number;
      }

      if (metaInformation !== undefined) {
        localVarQueryParameter["metaInformation"] = metaInformation;
      }

      if (intolerances !== undefined) {
        localVarQueryParameter["intolerances"] = intolerances;
      }

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Compute the amount you need of a certain ingredient for a certain nutritional goal. For example, how much pineapple do you have to eat to get 10 grams of protein?
     * @summary Compute Ingredient Amount
     * @param {number} id The id of the ingredient you want the amount for.
     * @param {string} nutrient The target nutrient. See a list of supported nutrients.
     * @param {number} target The target number of the given nutrient.
     * @param {string} [unit] The target unit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    computeIngredientAmount: async (
      id: number,
      nutrient: string,
      target: number,
      unit?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("computeIngredientAmount", "id", id);
      // verify required parameter 'nutrient' is not null or undefined
      assertParamExists("computeIngredientAmount", "nutrient", nutrient);
      // verify required parameter 'target' is not null or undefined
      assertParamExists("computeIngredientAmount", "target", target);
      const localVarPath = `/food/ingredients/{id}/amount`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (nutrient !== undefined) {
        localVarQueryParameter["nutrient"] = nutrient;
      }

      if (target !== undefined) {
        localVarQueryParameter["target"] = target;
      }

      if (unit !== undefined) {
        localVarQueryParameter["unit"] = unit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Use an ingredient id to get all available information about an ingredient, such as its image and supermarket aisle.
     * @summary Get Ingredient Information
     * @param {number} id The item\&#39;s id.
     * @param {number} [amount] The amount of this ingredient.
     * @param {string} [unit] The unit for the given amount.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngredientInformation: async (
      id: number,
      amount?: number,
      unit?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getIngredientInformation", "id", id);
      const localVarPath = `/food/ingredients/{id}/information`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (amount !== undefined) {
        localVarQueryParameter["amount"] = amount;
      }

      if (unit !== undefined) {
        localVarQueryParameter["unit"] = unit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Search for substitutes for a given ingredient.
     * @summary Get Ingredient Substitutes
     * @param {string} ingredientName The name of the ingredient you want to replace.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngredientSubstitutes: async (
      ingredientName: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'ingredientName' is not null or undefined
      assertParamExists(
        "getIngredientSubstitutes",
        "ingredientName",
        ingredientName
      );
      const localVarPath = `/food/ingredients/substitutes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (ingredientName !== undefined) {
        localVarQueryParameter["ingredientName"] = ingredientName;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Search for substitutes for a given ingredient.
     * @summary Get Ingredient Substitutes by ID
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngredientSubstitutesByID: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getIngredientSubstitutesByID", "id", id);
      const localVarPath = `/food/ingredients/{id}/substitutes`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Search for simple whole foods (e.g. fruits, vegetables, nuts, grains, meat, fish, dairy etc.).
     * @summary Ingredient Search
     * @param {string} [query] The (natural language) search query.
     * @param {boolean} [addChildren] Whether to add children of found foods.
     * @param {number} [minProteinPercent] The minimum percentage of protein the food must have (between 0 and 100).
     * @param {number} [maxProteinPercent] The maximum percentage of protein the food can have (between 0 and 100).
     * @param {number} [minFatPercent] The minimum percentage of fat the food must have (between 0 and 100).
     * @param {number} [maxFatPercent] The maximum percentage of fat the food can have (between 0 and 100).
     * @param {number} [minCarbsPercent] The minimum percentage of carbs the food must have (between 0 and 100).
     * @param {number} [maxCarbsPercent] The maximum percentage of carbs the food can have (between 0 and 100).
     * @param {boolean} [metaInformation] Whether to return more meta information about the ingredients.
     * @param {string} [intolerances] A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.
     * @param {string} [sort] The strategy to sort recipes by. See a full list of supported sorting options.
     * @param {string} [sortDirection] The direction in which to sort. Must be either \&#39;asc\&#39; (ascending) or \&#39;desc\&#39; (descending).
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {IngredientSearchLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ingredientSearch: async (
      query?: string,
      addChildren?: boolean,
      minProteinPercent?: number,
      maxProteinPercent?: number,
      minFatPercent?: number,
      maxFatPercent?: number,
      minCarbsPercent?: number,
      maxCarbsPercent?: number,
      metaInformation?: boolean,
      intolerances?: string,
      sort?: string,
      sortDirection?: string,
      offset?: number,
      number?: number,
      language?: IngredientSearchLanguageEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/food/ingredients/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (query !== undefined) {
        localVarQueryParameter["query"] = query;
      }

      if (addChildren !== undefined) {
        localVarQueryParameter["addChildren"] = addChildren;
      }

      if (minProteinPercent !== undefined) {
        localVarQueryParameter["minProteinPercent"] = minProteinPercent;
      }

      if (maxProteinPercent !== undefined) {
        localVarQueryParameter["maxProteinPercent"] = maxProteinPercent;
      }

      if (minFatPercent !== undefined) {
        localVarQueryParameter["minFatPercent"] = minFatPercent;
      }

      if (maxFatPercent !== undefined) {
        localVarQueryParameter["maxFatPercent"] = maxFatPercent;
      }

      if (minCarbsPercent !== undefined) {
        localVarQueryParameter["minCarbsPercent"] = minCarbsPercent;
      }

      if (maxCarbsPercent !== undefined) {
        localVarQueryParameter["maxCarbsPercent"] = maxCarbsPercent;
      }

      if (metaInformation !== undefined) {
        localVarQueryParameter["metaInformation"] = metaInformation;
      }

      if (intolerances !== undefined) {
        localVarQueryParameter["intolerances"] = intolerances;
      }

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort;
      }

      if (sortDirection !== undefined) {
        localVarQueryParameter["sortDirection"] = sortDirection;
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
      }

      if (number !== undefined) {
        localVarQueryParameter["number"] = number;
      }

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Visualize a recipe\'s ingredient list.
     * @summary Ingredients by ID Image
     * @param {number} id The recipe id.
     * @param {IngredientsByIDImageMeasureEnum} [measure] Whether the the measures should be \&#39;us\&#39; or \&#39;metric\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ingredientsByIDImage: async (
      id: number,
      measure?: IngredientsByIDImageMeasureEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("ingredientsByIDImage", "id", id);
      const localVarPath = `/recipes/{id}/ingredientWidget.png`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (measure !== undefined) {
        localVarQueryParameter["measure"] = measure;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Map a set of ingredients to products you can buy in the grocery store.
     * @summary Map Ingredients to Grocery Products
     * @param {MapIngredientsToGroceryProductsRequest} mapIngredientsToGroceryProductsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mapIngredientsToGroceryProducts: async (
      mapIngredientsToGroceryProductsRequest: MapIngredientsToGroceryProductsRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'mapIngredientsToGroceryProductsRequest' is not null or undefined
      assertParamExists(
        "mapIngredientsToGroceryProducts",
        "mapIngredientsToGroceryProductsRequest",
        mapIngredientsToGroceryProductsRequest
      );
      const localVarPath = `/food/ingredients/map`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mapIngredientsToGroceryProductsRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Visualize ingredients of a recipe. You can play around with that endpoint!
     * @summary Ingredients Widget
     * @param {VisualizeIngredientsContentTypeEnum} [contentType] The content type.
     * @param {VisualizeIngredientsLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {VisualizeIngredientsAcceptEnum} [accept] Accept header.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizeIngredients: async (
      contentType?: VisualizeIngredientsContentTypeEnum,
      language?: VisualizeIngredientsLanguageEnum,
      accept?: VisualizeIngredientsAcceptEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/recipes/visualizeIngredients`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (contentType != null) {
        localVarHeaderParameter["Content-Type"] = String(contentType);
      }

      if (accept != null) {
        localVarHeaderParameter["Accept"] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * IngredientsApi - functional programming interface
 * @export
 */
export const IngredientsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    IngredientsApiAxiosParamCreator(configuration);
  return {
    /**
     * Autocomplete the entry of an ingredient.
     * @summary Autocomplete Ingredient Search
     * @param {string} [query] The (natural language) search query.
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {boolean} [metaInformation] Whether to return more meta information about the ingredients.
     * @param {string} [intolerances] A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.
     * @param {AutocompleteIngredientSearchLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autocompleteIngredientSearch(
      query?: string,
      number?: number,
      metaInformation?: boolean,
      intolerances?: string,
      language?: AutocompleteIngredientSearchLanguageEnum,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Set<AutocompleteIngredientSearch200ResponseInner>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.autocompleteIngredientSearch(
          query,
          number,
          metaInformation,
          intolerances,
          language,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["IngredientsApi.autocompleteIngredientSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Compute the amount you need of a certain ingredient for a certain nutritional goal. For example, how much pineapple do you have to eat to get 10 grams of protein?
     * @summary Compute Ingredient Amount
     * @param {number} id The id of the ingredient you want the amount for.
     * @param {string} nutrient The target nutrient. See a list of supported nutrients.
     * @param {number} target The target number of the given nutrient.
     * @param {string} [unit] The target unit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async computeIngredientAmount(
      id: number,
      nutrient: string,
      target: number,
      unit?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ComputeIngredientAmount200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.computeIngredientAmount(
          id,
          nutrient,
          target,
          unit,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["IngredientsApi.computeIngredientAmount"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Use an ingredient id to get all available information about an ingredient, such as its image and supermarket aisle.
     * @summary Get Ingredient Information
     * @param {number} id The item\&#39;s id.
     * @param {number} [amount] The amount of this ingredient.
     * @param {string} [unit] The unit for the given amount.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIngredientInformation(
      id: number,
      amount?: number,
      unit?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetIngredientInformation200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getIngredientInformation(
          id,
          amount,
          unit,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["IngredientsApi.getIngredientInformation"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Search for substitutes for a given ingredient.
     * @summary Get Ingredient Substitutes
     * @param {string} ingredientName The name of the ingredient you want to replace.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIngredientSubstitutes(
      ingredientName: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetIngredientSubstitutes200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getIngredientSubstitutes(
          ingredientName,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["IngredientsApi.getIngredientSubstitutes"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Search for substitutes for a given ingredient.
     * @summary Get Ingredient Substitutes by ID
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIngredientSubstitutesByID(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetIngredientSubstitutes200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getIngredientSubstitutesByID(
          id,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["IngredientsApi.getIngredientSubstitutesByID"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Search for simple whole foods (e.g. fruits, vegetables, nuts, grains, meat, fish, dairy etc.).
     * @summary Ingredient Search
     * @param {string} [query] The (natural language) search query.
     * @param {boolean} [addChildren] Whether to add children of found foods.
     * @param {number} [minProteinPercent] The minimum percentage of protein the food must have (between 0 and 100).
     * @param {number} [maxProteinPercent] The maximum percentage of protein the food can have (between 0 and 100).
     * @param {number} [minFatPercent] The minimum percentage of fat the food must have (between 0 and 100).
     * @param {number} [maxFatPercent] The maximum percentage of fat the food can have (between 0 and 100).
     * @param {number} [minCarbsPercent] The minimum percentage of carbs the food must have (between 0 and 100).
     * @param {number} [maxCarbsPercent] The maximum percentage of carbs the food can have (between 0 and 100).
     * @param {boolean} [metaInformation] Whether to return more meta information about the ingredients.
     * @param {string} [intolerances] A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.
     * @param {string} [sort] The strategy to sort recipes by. See a full list of supported sorting options.
     * @param {string} [sortDirection] The direction in which to sort. Must be either \&#39;asc\&#39; (ascending) or \&#39;desc\&#39; (descending).
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {IngredientSearchLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ingredientSearch(
      query?: string,
      addChildren?: boolean,
      minProteinPercent?: number,
      maxProteinPercent?: number,
      minFatPercent?: number,
      maxFatPercent?: number,
      minCarbsPercent?: number,
      maxCarbsPercent?: number,
      metaInformation?: boolean,
      intolerances?: string,
      sort?: string,
      sortDirection?: string,
      offset?: number,
      number?: number,
      language?: IngredientSearchLanguageEnum,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<IngredientSearch200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ingredientSearch(
          query,
          addChildren,
          minProteinPercent,
          maxProteinPercent,
          minFatPercent,
          maxFatPercent,
          minCarbsPercent,
          maxCarbsPercent,
          metaInformation,
          intolerances,
          sort,
          sortDirection,
          offset,
          number,
          language,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["IngredientsApi.ingredientSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Visualize a recipe\'s ingredient list.
     * @summary Ingredients by ID Image
     * @param {number} id The recipe id.
     * @param {IngredientsByIDImageMeasureEnum} [measure] Whether the the measures should be \&#39;us\&#39; or \&#39;metric\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ingredientsByIDImage(
      id: number,
      measure?: IngredientsByIDImageMeasureEnum,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ingredientsByIDImage(
          id,
          measure,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["IngredientsApi.ingredientsByIDImage"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Map a set of ingredients to products you can buy in the grocery store.
     * @summary Map Ingredients to Grocery Products
     * @param {MapIngredientsToGroceryProductsRequest} mapIngredientsToGroceryProductsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mapIngredientsToGroceryProducts(
      mapIngredientsToGroceryProductsRequest: MapIngredientsToGroceryProductsRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Set<MapIngredientsToGroceryProducts200ResponseInner>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mapIngredientsToGroceryProducts(
          mapIngredientsToGroceryProductsRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["IngredientsApi.mapIngredientsToGroceryProducts"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Visualize ingredients of a recipe. You can play around with that endpoint!
     * @summary Ingredients Widget
     * @param {VisualizeIngredientsContentTypeEnum} [contentType] The content type.
     * @param {VisualizeIngredientsLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {VisualizeIngredientsAcceptEnum} [accept] Accept header.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async visualizeIngredients(
      contentType?: VisualizeIngredientsContentTypeEnum,
      language?: VisualizeIngredientsLanguageEnum,
      accept?: VisualizeIngredientsAcceptEnum,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.visualizeIngredients(
          contentType,
          language,
          accept,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["IngredientsApi.visualizeIngredients"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * IngredientsApi - factory interface
 * @export
 */
export const IngredientsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = IngredientsApiFp(configuration);
  return {
    /**
     * Autocomplete the entry of an ingredient.
     * @summary Autocomplete Ingredient Search
     * @param {string} [query] The (natural language) search query.
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {boolean} [metaInformation] Whether to return more meta information about the ingredients.
     * @param {string} [intolerances] A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.
     * @param {AutocompleteIngredientSearchLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autocompleteIngredientSearch(
      query?: string,
      number?: number,
      metaInformation?: boolean,
      intolerances?: string,
      language?: AutocompleteIngredientSearchLanguageEnum,
      options?: any
    ): AxiosPromise<Set<AutocompleteIngredientSearch200ResponseInner>> {
      return localVarFp
        .autocompleteIngredientSearch(
          query,
          number,
          metaInformation,
          intolerances,
          language,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Compute the amount you need of a certain ingredient for a certain nutritional goal. For example, how much pineapple do you have to eat to get 10 grams of protein?
     * @summary Compute Ingredient Amount
     * @param {number} id The id of the ingredient you want the amount for.
     * @param {string} nutrient The target nutrient. See a list of supported nutrients.
     * @param {number} target The target number of the given nutrient.
     * @param {string} [unit] The target unit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    computeIngredientAmount(
      id: number,
      nutrient: string,
      target: number,
      unit?: string,
      options?: any
    ): AxiosPromise<ComputeIngredientAmount200Response> {
      return localVarFp
        .computeIngredientAmount(id, nutrient, target, unit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Use an ingredient id to get all available information about an ingredient, such as its image and supermarket aisle.
     * @summary Get Ingredient Information
     * @param {number} id The item\&#39;s id.
     * @param {number} [amount] The amount of this ingredient.
     * @param {string} [unit] The unit for the given amount.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngredientInformation(
      id: number,
      amount?: number,
      unit?: string,
      options?: any
    ): AxiosPromise<GetIngredientInformation200Response> {
      return localVarFp
        .getIngredientInformation(id, amount, unit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Search for substitutes for a given ingredient.
     * @summary Get Ingredient Substitutes
     * @param {string} ingredientName The name of the ingredient you want to replace.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngredientSubstitutes(
      ingredientName: string,
      options?: any
    ): AxiosPromise<GetIngredientSubstitutes200Response> {
      return localVarFp
        .getIngredientSubstitutes(ingredientName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Search for substitutes for a given ingredient.
     * @summary Get Ingredient Substitutes by ID
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngredientSubstitutesByID(
      id: number,
      options?: any
    ): AxiosPromise<GetIngredientSubstitutes200Response> {
      return localVarFp
        .getIngredientSubstitutesByID(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Search for simple whole foods (e.g. fruits, vegetables, nuts, grains, meat, fish, dairy etc.).
     * @summary Ingredient Search
     * @param {string} [query] The (natural language) search query.
     * @param {boolean} [addChildren] Whether to add children of found foods.
     * @param {number} [minProteinPercent] The minimum percentage of protein the food must have (between 0 and 100).
     * @param {number} [maxProteinPercent] The maximum percentage of protein the food can have (between 0 and 100).
     * @param {number} [minFatPercent] The minimum percentage of fat the food must have (between 0 and 100).
     * @param {number} [maxFatPercent] The maximum percentage of fat the food can have (between 0 and 100).
     * @param {number} [minCarbsPercent] The minimum percentage of carbs the food must have (between 0 and 100).
     * @param {number} [maxCarbsPercent] The maximum percentage of carbs the food can have (between 0 and 100).
     * @param {boolean} [metaInformation] Whether to return more meta information about the ingredients.
     * @param {string} [intolerances] A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.
     * @param {string} [sort] The strategy to sort recipes by. See a full list of supported sorting options.
     * @param {string} [sortDirection] The direction in which to sort. Must be either \&#39;asc\&#39; (ascending) or \&#39;desc\&#39; (descending).
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {IngredientSearchLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ingredientSearch(
      query?: string,
      addChildren?: boolean,
      minProteinPercent?: number,
      maxProteinPercent?: number,
      minFatPercent?: number,
      maxFatPercent?: number,
      minCarbsPercent?: number,
      maxCarbsPercent?: number,
      metaInformation?: boolean,
      intolerances?: string,
      sort?: string,
      sortDirection?: string,
      offset?: number,
      number?: number,
      language?: IngredientSearchLanguageEnum,
      options?: any
    ): AxiosPromise<IngredientSearch200Response> {
      return localVarFp
        .ingredientSearch(
          query,
          addChildren,
          minProteinPercent,
          maxProteinPercent,
          minFatPercent,
          maxFatPercent,
          minCarbsPercent,
          maxCarbsPercent,
          metaInformation,
          intolerances,
          sort,
          sortDirection,
          offset,
          number,
          language,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Visualize a recipe\'s ingredient list.
     * @summary Ingredients by ID Image
     * @param {number} id The recipe id.
     * @param {IngredientsByIDImageMeasureEnum} [measure] Whether the the measures should be \&#39;us\&#39; or \&#39;metric\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ingredientsByIDImage(
      id: number,
      measure?: IngredientsByIDImageMeasureEnum,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .ingredientsByIDImage(id, measure, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Map a set of ingredients to products you can buy in the grocery store.
     * @summary Map Ingredients to Grocery Products
     * @param {MapIngredientsToGroceryProductsRequest} mapIngredientsToGroceryProductsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mapIngredientsToGroceryProducts(
      mapIngredientsToGroceryProductsRequest: MapIngredientsToGroceryProductsRequest,
      options?: any
    ): AxiosPromise<Set<MapIngredientsToGroceryProducts200ResponseInner>> {
      return localVarFp
        .mapIngredientsToGroceryProducts(
          mapIngredientsToGroceryProductsRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Visualize ingredients of a recipe. You can play around with that endpoint!
     * @summary Ingredients Widget
     * @param {VisualizeIngredientsContentTypeEnum} [contentType] The content type.
     * @param {VisualizeIngredientsLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {VisualizeIngredientsAcceptEnum} [accept] Accept header.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizeIngredients(
      contentType?: VisualizeIngredientsContentTypeEnum,
      language?: VisualizeIngredientsLanguageEnum,
      accept?: VisualizeIngredientsAcceptEnum,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .visualizeIngredients(contentType, language, accept, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * IngredientsApi - object-oriented interface
 * @export
 * @class IngredientsApi
 * @extends {BaseAPI}
 */
export class IngredientsApi extends BaseAPI {
  /**
   * Autocomplete the entry of an ingredient.
   * @summary Autocomplete Ingredient Search
   * @param {string} [query] The (natural language) search query.
   * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
   * @param {boolean} [metaInformation] Whether to return more meta information about the ingredients.
   * @param {string} [intolerances] A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.
   * @param {AutocompleteIngredientSearchLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IngredientsApi
   */
  public autocompleteIngredientSearch(
    query?: string,
    number?: number,
    metaInformation?: boolean,
    intolerances?: string,
    language?: AutocompleteIngredientSearchLanguageEnum,
    options?: RawAxiosRequestConfig
  ) {
    return IngredientsApiFp(this.configuration)
      .autocompleteIngredientSearch(
        query,
        number,
        metaInformation,
        intolerances,
        language,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Compute the amount you need of a certain ingredient for a certain nutritional goal. For example, how much pineapple do you have to eat to get 10 grams of protein?
   * @summary Compute Ingredient Amount
   * @param {number} id The id of the ingredient you want the amount for.
   * @param {string} nutrient The target nutrient. See a list of supported nutrients.
   * @param {number} target The target number of the given nutrient.
   * @param {string} [unit] The target unit.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IngredientsApi
   */
  public computeIngredientAmount(
    id: number,
    nutrient: string,
    target: number,
    unit?: string,
    options?: RawAxiosRequestConfig
  ) {
    return IngredientsApiFp(this.configuration)
      .computeIngredientAmount(id, nutrient, target, unit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Use an ingredient id to get all available information about an ingredient, such as its image and supermarket aisle.
   * @summary Get Ingredient Information
   * @param {number} id The item\&#39;s id.
   * @param {number} [amount] The amount of this ingredient.
   * @param {string} [unit] The unit for the given amount.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IngredientsApi
   */
  public getIngredientInformation(
    id: number,
    amount?: number,
    unit?: string,
    options?: RawAxiosRequestConfig
  ) {
    return IngredientsApiFp(this.configuration)
      .getIngredientInformation(id, amount, unit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Search for substitutes for a given ingredient.
   * @summary Get Ingredient Substitutes
   * @param {string} ingredientName The name of the ingredient you want to replace.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IngredientsApi
   */
  public getIngredientSubstitutes(
    ingredientName: string,
    options?: RawAxiosRequestConfig
  ) {
    return IngredientsApiFp(this.configuration)
      .getIngredientSubstitutes(ingredientName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Search for substitutes for a given ingredient.
   * @summary Get Ingredient Substitutes by ID
   * @param {number} id The item\&#39;s id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IngredientsApi
   */
  public getIngredientSubstitutesByID(
    id: number,
    options?: RawAxiosRequestConfig
  ) {
    return IngredientsApiFp(this.configuration)
      .getIngredientSubstitutesByID(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Search for simple whole foods (e.g. fruits, vegetables, nuts, grains, meat, fish, dairy etc.).
   * @summary Ingredient Search
   * @param {string} [query] The (natural language) search query.
   * @param {boolean} [addChildren] Whether to add children of found foods.
   * @param {number} [minProteinPercent] The minimum percentage of protein the food must have (between 0 and 100).
   * @param {number} [maxProteinPercent] The maximum percentage of protein the food can have (between 0 and 100).
   * @param {number} [minFatPercent] The minimum percentage of fat the food must have (between 0 and 100).
   * @param {number} [maxFatPercent] The maximum percentage of fat the food can have (between 0 and 100).
   * @param {number} [minCarbsPercent] The minimum percentage of carbs the food must have (between 0 and 100).
   * @param {number} [maxCarbsPercent] The maximum percentage of carbs the food can have (between 0 and 100).
   * @param {boolean} [metaInformation] Whether to return more meta information about the ingredients.
   * @param {string} [intolerances] A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.
   * @param {string} [sort] The strategy to sort recipes by. See a full list of supported sorting options.
   * @param {string} [sortDirection] The direction in which to sort. Must be either \&#39;asc\&#39; (ascending) or \&#39;desc\&#39; (descending).
   * @param {number} [offset] The number of results to skip (between 0 and 900).
   * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
   * @param {IngredientSearchLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IngredientsApi
   */
  public ingredientSearch(
    query?: string,
    addChildren?: boolean,
    minProteinPercent?: number,
    maxProteinPercent?: number,
    minFatPercent?: number,
    maxFatPercent?: number,
    minCarbsPercent?: number,
    maxCarbsPercent?: number,
    metaInformation?: boolean,
    intolerances?: string,
    sort?: string,
    sortDirection?: string,
    offset?: number,
    number?: number,
    language?: IngredientSearchLanguageEnum,
    options?: RawAxiosRequestConfig
  ) {
    return IngredientsApiFp(this.configuration)
      .ingredientSearch(
        query,
        addChildren,
        minProteinPercent,
        maxProteinPercent,
        minFatPercent,
        maxFatPercent,
        minCarbsPercent,
        maxCarbsPercent,
        metaInformation,
        intolerances,
        sort,
        sortDirection,
        offset,
        number,
        language,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Visualize a recipe\'s ingredient list.
   * @summary Ingredients by ID Image
   * @param {number} id The recipe id.
   * @param {IngredientsByIDImageMeasureEnum} [measure] Whether the the measures should be \&#39;us\&#39; or \&#39;metric\&#39;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IngredientsApi
   */
  public ingredientsByIDImage(
    id: number,
    measure?: IngredientsByIDImageMeasureEnum,
    options?: RawAxiosRequestConfig
  ) {
    return IngredientsApiFp(this.configuration)
      .ingredientsByIDImage(id, measure, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Map a set of ingredients to products you can buy in the grocery store.
   * @summary Map Ingredients to Grocery Products
   * @param {MapIngredientsToGroceryProductsRequest} mapIngredientsToGroceryProductsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IngredientsApi
   */
  public mapIngredientsToGroceryProducts(
    mapIngredientsToGroceryProductsRequest: MapIngredientsToGroceryProductsRequest,
    options?: RawAxiosRequestConfig
  ) {
    return IngredientsApiFp(this.configuration)
      .mapIngredientsToGroceryProducts(
        mapIngredientsToGroceryProductsRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Visualize ingredients of a recipe. You can play around with that endpoint!
   * @summary Ingredients Widget
   * @param {VisualizeIngredientsContentTypeEnum} [contentType] The content type.
   * @param {VisualizeIngredientsLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
   * @param {VisualizeIngredientsAcceptEnum} [accept] Accept header.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IngredientsApi
   */
  public visualizeIngredients(
    contentType?: VisualizeIngredientsContentTypeEnum,
    language?: VisualizeIngredientsLanguageEnum,
    accept?: VisualizeIngredientsAcceptEnum,
    options?: RawAxiosRequestConfig
  ) {
    return IngredientsApiFp(this.configuration)
      .visualizeIngredients(contentType, language, accept, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const AutocompleteIngredientSearchLanguageEnum = {
  En: "en",
  De: "de",
} as const;
export type AutocompleteIngredientSearchLanguageEnum =
  (typeof AutocompleteIngredientSearchLanguageEnum)[keyof typeof AutocompleteIngredientSearchLanguageEnum];
/**
 * @export
 */
export const IngredientSearchLanguageEnum = {
  En: "en",
  De: "de",
} as const;
export type IngredientSearchLanguageEnum =
  (typeof IngredientSearchLanguageEnum)[keyof typeof IngredientSearchLanguageEnum];
/**
 * @export
 */
export const IngredientsByIDImageMeasureEnum = {
  Us: "us",
  Metric: "metric",
} as const;
export type IngredientsByIDImageMeasureEnum =
  (typeof IngredientsByIDImageMeasureEnum)[keyof typeof IngredientsByIDImageMeasureEnum];
/**
 * @export
 */
export const VisualizeIngredientsContentTypeEnum = {
  ApplicationXWwwFormUrlencoded: "application/x-www-form-urlencoded",
  ApplicationJson: "application/json",
  MultipartFormData: "multipart/form-data",
} as const;
export type VisualizeIngredientsContentTypeEnum =
  (typeof VisualizeIngredientsContentTypeEnum)[keyof typeof VisualizeIngredientsContentTypeEnum];
/**
 * @export
 */
export const VisualizeIngredientsLanguageEnum = {
  En: "en",
  De: "de",
} as const;
export type VisualizeIngredientsLanguageEnum =
  (typeof VisualizeIngredientsLanguageEnum)[keyof typeof VisualizeIngredientsLanguageEnum];
/**
 * @export
 */
export const VisualizeIngredientsAcceptEnum = {
  ApplicationJson: "application/json",
  TextHtml: "text/html",
  Media: "media/_*",
} as const;
export type VisualizeIngredientsAcceptEnum =
  (typeof VisualizeIngredientsAcceptEnum)[keyof typeof VisualizeIngredientsAcceptEnum];

/**
 * MealPlanningApi - axios parameter creator
 * @export
 */
export const MealPlanningApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Add a meal plan template for a user.
     * @summary Add Meal Plan Template
     * @param {string} username The username.
     * @param {string} hash The private hash for the username.
     * @param {AddToMealPlanRequest} addToMealPlanRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addMealPlanTemplate: async (
      username: string,
      hash: string,
      addToMealPlanRequest: AddToMealPlanRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists("addMealPlanTemplate", "username", username);
      // verify required parameter 'hash' is not null or undefined
      assertParamExists("addMealPlanTemplate", "hash", hash);
      // verify required parameter 'addToMealPlanRequest' is not null or undefined
      assertParamExists(
        "addMealPlanTemplate",
        "addToMealPlanRequest",
        addToMealPlanRequest
      );
      const localVarPath = `/mealplanner/{username}/templates`.replace(
        `{${"username"}}`,
        encodeURIComponent(String(username))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (hash !== undefined) {
        localVarQueryParameter["hash"] = hash;
      }

      localVarHeaderParameter["Content-Type"] = "";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        addToMealPlanRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Add an item to the user\'s meal plan.
     * @summary Add to Meal Plan
     * @param {string} username The username.
     * @param {string} hash The private hash for the username.
     * @param {AddToMealPlanRequest} addToMealPlanRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addToMealPlan: async (
      username: string,
      hash: string,
      addToMealPlanRequest: AddToMealPlanRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists("addToMealPlan", "username", username);
      // verify required parameter 'hash' is not null or undefined
      assertParamExists("addToMealPlan", "hash", hash);
      // verify required parameter 'addToMealPlanRequest' is not null or undefined
      assertParamExists(
        "addToMealPlan",
        "addToMealPlanRequest",
        addToMealPlanRequest
      );
      const localVarPath = `/mealplanner/{username}/items`.replace(
        `{${"username"}}`,
        encodeURIComponent(String(username))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (hash !== undefined) {
        localVarQueryParameter["hash"] = hash;
      }

      localVarHeaderParameter["Content-Type"] = "";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        addToMealPlanRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Add an item to the current shopping list of a user.
     * @summary Add to Shopping List
     * @param {string} username The username.
     * @param {string} hash The private hash for the username.
     * @param {AddToMealPlanRequest} addToMealPlanRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addToShoppingList: async (
      username: string,
      hash: string,
      addToMealPlanRequest: AddToMealPlanRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists("addToShoppingList", "username", username);
      // verify required parameter 'hash' is not null or undefined
      assertParamExists("addToShoppingList", "hash", hash);
      // verify required parameter 'addToMealPlanRequest' is not null or undefined
      assertParamExists(
        "addToShoppingList",
        "addToMealPlanRequest",
        addToMealPlanRequest
      );
      const localVarPath =
        `/mealplanner/{username}/shopping-list/items`.replace(
          `{${"username"}}`,
          encodeURIComponent(String(username))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (hash !== undefined) {
        localVarQueryParameter["hash"] = hash;
      }

      localVarHeaderParameter["Content-Type"] = "";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        addToMealPlanRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete all planned items from the user\'s meal plan for a specific day.
     * @summary Clear Meal Plan Day
     * @param {string} username The username.
     * @param {string} date The date in the format yyyy-mm-dd.
     * @param {string} hash The private hash for the username.
     * @param {ClearMealPlanDayRequest} clearMealPlanDayRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clearMealPlanDay: async (
      username: string,
      date: string,
      hash: string,
      clearMealPlanDayRequest: ClearMealPlanDayRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists("clearMealPlanDay", "username", username);
      // verify required parameter 'date' is not null or undefined
      assertParamExists("clearMealPlanDay", "date", date);
      // verify required parameter 'hash' is not null or undefined
      assertParamExists("clearMealPlanDay", "hash", hash);
      // verify required parameter 'clearMealPlanDayRequest' is not null or undefined
      assertParamExists(
        "clearMealPlanDay",
        "clearMealPlanDayRequest",
        clearMealPlanDayRequest
      );
      const localVarPath = `/mealplanner/{username}/day/{date}`
        .replace(`{${"username"}}`, encodeURIComponent(String(username)))
        .replace(`{${"date"}}`, encodeURIComponent(String(date)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (hash !== undefined) {
        localVarQueryParameter["hash"] = hash;
      }

      localVarHeaderParameter["Content-Type"] = "";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        clearMealPlanDayRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * In order to call user-specific endpoints, you need to connect your app\'s users to spoonacular users.
     * @summary Connect User
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    connectUser: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("connectUser", "body", body);
      const localVarPath = `/users/connect`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete an item from the user\'s meal plan.
     * @summary Delete from Meal Plan
     * @param {string} username The username.
     * @param {number} id The shopping list item id.
     * @param {string} hash The private hash for the username.
     * @param {DeleteFromMealPlanRequest} deleteFromMealPlanRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFromMealPlan: async (
      username: string,
      id: number,
      hash: string,
      deleteFromMealPlanRequest: DeleteFromMealPlanRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists("deleteFromMealPlan", "username", username);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteFromMealPlan", "id", id);
      // verify required parameter 'hash' is not null or undefined
      assertParamExists("deleteFromMealPlan", "hash", hash);
      // verify required parameter 'deleteFromMealPlanRequest' is not null or undefined
      assertParamExists(
        "deleteFromMealPlan",
        "deleteFromMealPlanRequest",
        deleteFromMealPlanRequest
      );
      const localVarPath = `/mealplanner/{username}/items/{id}`
        .replace(`{${"username"}}`, encodeURIComponent(String(username)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (hash !== undefined) {
        localVarQueryParameter["hash"] = hash;
      }

      localVarHeaderParameter["Content-Type"] = "";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        deleteFromMealPlanRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete an item from the current shopping list of the user.
     * @summary Delete from Shopping List
     * @param {string} username The username.
     * @param {number} id The item\&#39;s id.
     * @param {string} hash The private hash for the username.
     * @param {DeleteFromMealPlanRequest} deleteFromMealPlanRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFromShoppingList: async (
      username: string,
      id: number,
      hash: string,
      deleteFromMealPlanRequest: DeleteFromMealPlanRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists("deleteFromShoppingList", "username", username);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteFromShoppingList", "id", id);
      // verify required parameter 'hash' is not null or undefined
      assertParamExists("deleteFromShoppingList", "hash", hash);
      // verify required parameter 'deleteFromMealPlanRequest' is not null or undefined
      assertParamExists(
        "deleteFromShoppingList",
        "deleteFromMealPlanRequest",
        deleteFromMealPlanRequest
      );
      const localVarPath = `/mealplanner/{username}/shopping-list/items/{id}`
        .replace(`{${"username"}}`, encodeURIComponent(String(username)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (hash !== undefined) {
        localVarQueryParameter["hash"] = hash;
      }

      localVarHeaderParameter["Content-Type"] = "";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        deleteFromMealPlanRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a meal plan template for a user.
     * @summary Delete Meal Plan Template
     * @param {string} username The username.
     * @param {number} id The item\&#39;s id.
     * @param {string} hash The private hash for the username.
     * @param {DeleteFromMealPlanRequest} deleteFromMealPlanRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMealPlanTemplate: async (
      username: string,
      id: number,
      hash: string,
      deleteFromMealPlanRequest: DeleteFromMealPlanRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists("deleteMealPlanTemplate", "username", username);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteMealPlanTemplate", "id", id);
      // verify required parameter 'hash' is not null or undefined
      assertParamExists("deleteMealPlanTemplate", "hash", hash);
      // verify required parameter 'deleteFromMealPlanRequest' is not null or undefined
      assertParamExists(
        "deleteMealPlanTemplate",
        "deleteFromMealPlanRequest",
        deleteFromMealPlanRequest
      );
      const localVarPath = `/mealplanner/{username}/templates/{id}`
        .replace(`{${"username"}}`, encodeURIComponent(String(username)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (hash !== undefined) {
        localVarQueryParameter["hash"] = hash;
      }

      localVarHeaderParameter["Content-Type"] = "";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        deleteFromMealPlanRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Generate a meal plan with three meals per day (breakfast, lunch, and dinner).
     * @summary Generate Meal Plan
     * @param {string} [timeFrame] Either for one \&quot;day\&quot; or an entire \&quot;week\&quot;.
     * @param {number} [targetCalories] What is the caloric target for one day? The meal plan generator will try to get as close as possible to that goal.
     * @param {string} [diet] Enter a diet that the meal plan has to adhere to. See a full list of supported diets.
     * @param {string} [exclude] A comma-separated list of allergens or ingredients that must be excluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateMealPlan: async (
      timeFrame?: string,
      targetCalories?: number,
      diet?: string,
      exclude?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/mealplanner/generate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (timeFrame !== undefined) {
        localVarQueryParameter["timeFrame"] = timeFrame;
      }

      if (targetCalories !== undefined) {
        localVarQueryParameter["targetCalories"] = targetCalories;
      }

      if (diet !== undefined) {
        localVarQueryParameter["diet"] = diet;
      }

      if (exclude !== undefined) {
        localVarQueryParameter["exclude"] = exclude;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Generate the shopping list for a user from the meal planner in a given time frame.
     * @summary Generate Shopping List
     * @param {string} username The username.
     * @param {string} startDate The start date in the format yyyy-mm-dd.
     * @param {string} endDate The end date in the format yyyy-mm-dd.
     * @param {string} hash The private hash for the username.
     * @param {GenerateShoppingListRequest} generateShoppingListRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateShoppingList: async (
      username: string,
      startDate: string,
      endDate: string,
      hash: string,
      generateShoppingListRequest: GenerateShoppingListRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists("generateShoppingList", "username", username);
      // verify required parameter 'startDate' is not null or undefined
      assertParamExists("generateShoppingList", "startDate", startDate);
      // verify required parameter 'endDate' is not null or undefined
      assertParamExists("generateShoppingList", "endDate", endDate);
      // verify required parameter 'hash' is not null or undefined
      assertParamExists("generateShoppingList", "hash", hash);
      // verify required parameter 'generateShoppingListRequest' is not null or undefined
      assertParamExists(
        "generateShoppingList",
        "generateShoppingListRequest",
        generateShoppingListRequest
      );
      const localVarPath =
        `/mealplanner/{username}/shopping-list/{start-date}/{end-date}`
          .replace(`{${"username"}}`, encodeURIComponent(String(username)))
          .replace(`{${"start-date"}}`, encodeURIComponent(String(startDate)))
          .replace(`{${"end-date"}}`, encodeURIComponent(String(endDate)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (hash !== undefined) {
        localVarQueryParameter["hash"] = hash;
      }

      localVarHeaderParameter["Content-Type"] = "";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        generateShoppingListRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information about a meal plan template.
     * @summary Get Meal Plan Template
     * @param {string} username The username.
     * @param {number} id The item\&#39;s id.
     * @param {string} hash The private hash for the username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMealPlanTemplate: async (
      username: string,
      id: number,
      hash: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists("getMealPlanTemplate", "username", username);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getMealPlanTemplate", "id", id);
      // verify required parameter 'hash' is not null or undefined
      assertParamExists("getMealPlanTemplate", "hash", hash);
      const localVarPath = `/mealplanner/{username}/templates/{id}`
        .replace(`{${"username"}}`, encodeURIComponent(String(username)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (hash !== undefined) {
        localVarQueryParameter["hash"] = hash;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get meal plan templates from user or public ones.
     * @summary Get Meal Plan Templates
     * @param {string} username The username.
     * @param {string} hash The private hash for the username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMealPlanTemplates: async (
      username: string,
      hash: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists("getMealPlanTemplates", "username", username);
      // verify required parameter 'hash' is not null or undefined
      assertParamExists("getMealPlanTemplates", "hash", hash);
      const localVarPath = `/mealplanner/{username}/templates`.replace(
        `{${"username"}}`,
        encodeURIComponent(String(username))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (hash !== undefined) {
        localVarQueryParameter["hash"] = hash;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve a meal planned week for the given user. The username must be a spoonacular user and the hash must the the user\'s hash that can be found in his/her account.
     * @summary Get Meal Plan Week
     * @param {string} username The username.
     * @param {string} startDate The start date of the meal planned week in the format yyyy-mm-dd.
     * @param {string} hash The private hash for the username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMealPlanWeek: async (
      username: string,
      startDate: string,
      hash: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists("getMealPlanWeek", "username", username);
      // verify required parameter 'startDate' is not null or undefined
      assertParamExists("getMealPlanWeek", "startDate", startDate);
      // verify required parameter 'hash' is not null or undefined
      assertParamExists("getMealPlanWeek", "hash", hash);
      const localVarPath = `/mealplanner/{username}/week/{start-date}`
        .replace(`{${"username"}}`, encodeURIComponent(String(username)))
        .replace(`{${"start-date"}}`, encodeURIComponent(String(startDate)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (hash !== undefined) {
        localVarQueryParameter["hash"] = hash;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the current shopping list for the given user.
     * @summary Get Shopping List
     * @param {string} username The username.
     * @param {string} hash The private hash for the username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShoppingList: async (
      username: string,
      hash: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists("getShoppingList", "username", username);
      // verify required parameter 'hash' is not null or undefined
      assertParamExists("getShoppingList", "hash", hash);
      const localVarPath = `/mealplanner/{username}/shopping-list`.replace(
        `{${"username"}}`,
        encodeURIComponent(String(username))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (hash !== undefined) {
        localVarQueryParameter["hash"] = hash;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MealPlanningApi - functional programming interface
 * @export
 */
export const MealPlanningApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    MealPlanningApiAxiosParamCreator(configuration);
  return {
    /**
     * Add a meal plan template for a user.
     * @summary Add Meal Plan Template
     * @param {string} username The username.
     * @param {string} hash The private hash for the username.
     * @param {AddToMealPlanRequest} addToMealPlanRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addMealPlanTemplate(
      username: string,
      hash: string,
      addToMealPlanRequest: AddToMealPlanRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AddMealPlanTemplate200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addMealPlanTemplate(
          username,
          hash,
          addToMealPlanRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MealPlanningApi.addMealPlanTemplate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Add an item to the user\'s meal plan.
     * @summary Add to Meal Plan
     * @param {string} username The username.
     * @param {string} hash The private hash for the username.
     * @param {AddToMealPlanRequest} addToMealPlanRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addToMealPlan(
      username: string,
      hash: string,
      addToMealPlanRequest: AddToMealPlanRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addToMealPlan(
        username,
        hash,
        addToMealPlanRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MealPlanningApi.addToMealPlan"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Add an item to the current shopping list of a user.
     * @summary Add to Shopping List
     * @param {string} username The username.
     * @param {string} hash The private hash for the username.
     * @param {AddToMealPlanRequest} addToMealPlanRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addToShoppingList(
      username: string,
      hash: string,
      addToMealPlanRequest: AddToMealPlanRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GenerateShoppingList200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addToShoppingList(
          username,
          hash,
          addToMealPlanRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MealPlanningApi.addToShoppingList"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Delete all planned items from the user\'s meal plan for a specific day.
     * @summary Clear Meal Plan Day
     * @param {string} username The username.
     * @param {string} date The date in the format yyyy-mm-dd.
     * @param {string} hash The private hash for the username.
     * @param {ClearMealPlanDayRequest} clearMealPlanDayRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async clearMealPlanDay(
      username: string,
      date: string,
      hash: string,
      clearMealPlanDayRequest: ClearMealPlanDayRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.clearMealPlanDay(
          username,
          date,
          hash,
          clearMealPlanDayRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MealPlanningApi.clearMealPlanDay"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * In order to call user-specific endpoints, you need to connect your app\'s users to spoonacular users.
     * @summary Connect User
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async connectUser(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ConnectUser200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.connectUser(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MealPlanningApi.connectUser"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Delete an item from the user\'s meal plan.
     * @summary Delete from Meal Plan
     * @param {string} username The username.
     * @param {number} id The shopping list item id.
     * @param {string} hash The private hash for the username.
     * @param {DeleteFromMealPlanRequest} deleteFromMealPlanRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFromMealPlan(
      username: string,
      id: number,
      hash: string,
      deleteFromMealPlanRequest: DeleteFromMealPlanRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteFromMealPlan(
          username,
          id,
          hash,
          deleteFromMealPlanRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MealPlanningApi.deleteFromMealPlan"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Delete an item from the current shopping list of the user.
     * @summary Delete from Shopping List
     * @param {string} username The username.
     * @param {number} id The item\&#39;s id.
     * @param {string} hash The private hash for the username.
     * @param {DeleteFromMealPlanRequest} deleteFromMealPlanRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFromShoppingList(
      username: string,
      id: number,
      hash: string,
      deleteFromMealPlanRequest: DeleteFromMealPlanRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteFromShoppingList(
          username,
          id,
          hash,
          deleteFromMealPlanRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MealPlanningApi.deleteFromShoppingList"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Delete a meal plan template for a user.
     * @summary Delete Meal Plan Template
     * @param {string} username The username.
     * @param {number} id The item\&#39;s id.
     * @param {string} hash The private hash for the username.
     * @param {DeleteFromMealPlanRequest} deleteFromMealPlanRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteMealPlanTemplate(
      username: string,
      id: number,
      hash: string,
      deleteFromMealPlanRequest: DeleteFromMealPlanRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteMealPlanTemplate(
          username,
          id,
          hash,
          deleteFromMealPlanRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MealPlanningApi.deleteMealPlanTemplate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Generate a meal plan with three meals per day (breakfast, lunch, and dinner).
     * @summary Generate Meal Plan
     * @param {string} [timeFrame] Either for one \&quot;day\&quot; or an entire \&quot;week\&quot;.
     * @param {number} [targetCalories] What is the caloric target for one day? The meal plan generator will try to get as close as possible to that goal.
     * @param {string} [diet] Enter a diet that the meal plan has to adhere to. See a full list of supported diets.
     * @param {string} [exclude] A comma-separated list of allergens or ingredients that must be excluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateMealPlan(
      timeFrame?: string,
      targetCalories?: number,
      diet?: string,
      exclude?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GenerateMealPlan200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.generateMealPlan(
          timeFrame,
          targetCalories,
          diet,
          exclude,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MealPlanningApi.generateMealPlan"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Generate the shopping list for a user from the meal planner in a given time frame.
     * @summary Generate Shopping List
     * @param {string} username The username.
     * @param {string} startDate The start date in the format yyyy-mm-dd.
     * @param {string} endDate The end date in the format yyyy-mm-dd.
     * @param {string} hash The private hash for the username.
     * @param {GenerateShoppingListRequest} generateShoppingListRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateShoppingList(
      username: string,
      startDate: string,
      endDate: string,
      hash: string,
      generateShoppingListRequest: GenerateShoppingListRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GenerateShoppingList200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.generateShoppingList(
          username,
          startDate,
          endDate,
          hash,
          generateShoppingListRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MealPlanningApi.generateShoppingList"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get information about a meal plan template.
     * @summary Get Meal Plan Template
     * @param {string} username The username.
     * @param {number} id The item\&#39;s id.
     * @param {string} hash The private hash for the username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMealPlanTemplate(
      username: string,
      id: number,
      hash: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetMealPlanTemplate200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMealPlanTemplate(
          username,
          id,
          hash,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MealPlanningApi.getMealPlanTemplate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get meal plan templates from user or public ones.
     * @summary Get Meal Plan Templates
     * @param {string} username The username.
     * @param {string} hash The private hash for the username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMealPlanTemplates(
      username: string,
      hash: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetMealPlanTemplates200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMealPlanTemplates(
          username,
          hash,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MealPlanningApi.getMealPlanTemplates"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve a meal planned week for the given user. The username must be a spoonacular user and the hash must the the user\'s hash that can be found in his/her account.
     * @summary Get Meal Plan Week
     * @param {string} username The username.
     * @param {string} startDate The start date of the meal planned week in the format yyyy-mm-dd.
     * @param {string} hash The private hash for the username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMealPlanWeek(
      username: string,
      startDate: string,
      hash: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetMealPlanWeek200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMealPlanWeek(
        username,
        startDate,
        hash,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MealPlanningApi.getMealPlanWeek"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get the current shopping list for the given user.
     * @summary Get Shopping List
     * @param {string} username The username.
     * @param {string} hash The private hash for the username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getShoppingList(
      username: string,
      hash: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetShoppingList200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getShoppingList(
        username,
        hash,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MealPlanningApi.getShoppingList"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * MealPlanningApi - factory interface
 * @export
 */
export const MealPlanningApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MealPlanningApiFp(configuration);
  return {
    /**
     * Add a meal plan template for a user.
     * @summary Add Meal Plan Template
     * @param {string} username The username.
     * @param {string} hash The private hash for the username.
     * @param {AddToMealPlanRequest} addToMealPlanRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addMealPlanTemplate(
      username: string,
      hash: string,
      addToMealPlanRequest: AddToMealPlanRequest,
      options?: any
    ): AxiosPromise<AddMealPlanTemplate200Response> {
      return localVarFp
        .addMealPlanTemplate(username, hash, addToMealPlanRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Add an item to the user\'s meal plan.
     * @summary Add to Meal Plan
     * @param {string} username The username.
     * @param {string} hash The private hash for the username.
     * @param {AddToMealPlanRequest} addToMealPlanRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addToMealPlan(
      username: string,
      hash: string,
      addToMealPlanRequest: AddToMealPlanRequest,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .addToMealPlan(username, hash, addToMealPlanRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Add an item to the current shopping list of a user.
     * @summary Add to Shopping List
     * @param {string} username The username.
     * @param {string} hash The private hash for the username.
     * @param {AddToMealPlanRequest} addToMealPlanRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addToShoppingList(
      username: string,
      hash: string,
      addToMealPlanRequest: AddToMealPlanRequest,
      options?: any
    ): AxiosPromise<GenerateShoppingList200Response> {
      return localVarFp
        .addToShoppingList(username, hash, addToMealPlanRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete all planned items from the user\'s meal plan for a specific day.
     * @summary Clear Meal Plan Day
     * @param {string} username The username.
     * @param {string} date The date in the format yyyy-mm-dd.
     * @param {string} hash The private hash for the username.
     * @param {ClearMealPlanDayRequest} clearMealPlanDayRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clearMealPlanDay(
      username: string,
      date: string,
      hash: string,
      clearMealPlanDayRequest: ClearMealPlanDayRequest,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .clearMealPlanDay(
          username,
          date,
          hash,
          clearMealPlanDayRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * In order to call user-specific endpoints, you need to connect your app\'s users to spoonacular users.
     * @summary Connect User
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    connectUser(
      body: object,
      options?: any
    ): AxiosPromise<ConnectUser200Response> {
      return localVarFp
        .connectUser(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete an item from the user\'s meal plan.
     * @summary Delete from Meal Plan
     * @param {string} username The username.
     * @param {number} id The shopping list item id.
     * @param {string} hash The private hash for the username.
     * @param {DeleteFromMealPlanRequest} deleteFromMealPlanRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFromMealPlan(
      username: string,
      id: number,
      hash: string,
      deleteFromMealPlanRequest: DeleteFromMealPlanRequest,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .deleteFromMealPlan(
          username,
          id,
          hash,
          deleteFromMealPlanRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete an item from the current shopping list of the user.
     * @summary Delete from Shopping List
     * @param {string} username The username.
     * @param {number} id The item\&#39;s id.
     * @param {string} hash The private hash for the username.
     * @param {DeleteFromMealPlanRequest} deleteFromMealPlanRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFromShoppingList(
      username: string,
      id: number,
      hash: string,
      deleteFromMealPlanRequest: DeleteFromMealPlanRequest,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .deleteFromShoppingList(
          username,
          id,
          hash,
          deleteFromMealPlanRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a meal plan template for a user.
     * @summary Delete Meal Plan Template
     * @param {string} username The username.
     * @param {number} id The item\&#39;s id.
     * @param {string} hash The private hash for the username.
     * @param {DeleteFromMealPlanRequest} deleteFromMealPlanRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMealPlanTemplate(
      username: string,
      id: number,
      hash: string,
      deleteFromMealPlanRequest: DeleteFromMealPlanRequest,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .deleteMealPlanTemplate(
          username,
          id,
          hash,
          deleteFromMealPlanRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Generate a meal plan with three meals per day (breakfast, lunch, and dinner).
     * @summary Generate Meal Plan
     * @param {string} [timeFrame] Either for one \&quot;day\&quot; or an entire \&quot;week\&quot;.
     * @param {number} [targetCalories] What is the caloric target for one day? The meal plan generator will try to get as close as possible to that goal.
     * @param {string} [diet] Enter a diet that the meal plan has to adhere to. See a full list of supported diets.
     * @param {string} [exclude] A comma-separated list of allergens or ingredients that must be excluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateMealPlan(
      timeFrame?: string,
      targetCalories?: number,
      diet?: string,
      exclude?: string,
      options?: any
    ): AxiosPromise<GenerateMealPlan200Response> {
      return localVarFp
        .generateMealPlan(timeFrame, targetCalories, diet, exclude, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Generate the shopping list for a user from the meal planner in a given time frame.
     * @summary Generate Shopping List
     * @param {string} username The username.
     * @param {string} startDate The start date in the format yyyy-mm-dd.
     * @param {string} endDate The end date in the format yyyy-mm-dd.
     * @param {string} hash The private hash for the username.
     * @param {GenerateShoppingListRequest} generateShoppingListRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateShoppingList(
      username: string,
      startDate: string,
      endDate: string,
      hash: string,
      generateShoppingListRequest: GenerateShoppingListRequest,
      options?: any
    ): AxiosPromise<GenerateShoppingList200Response> {
      return localVarFp
        .generateShoppingList(
          username,
          startDate,
          endDate,
          hash,
          generateShoppingListRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get information about a meal plan template.
     * @summary Get Meal Plan Template
     * @param {string} username The username.
     * @param {number} id The item\&#39;s id.
     * @param {string} hash The private hash for the username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMealPlanTemplate(
      username: string,
      id: number,
      hash: string,
      options?: any
    ): AxiosPromise<GetMealPlanTemplate200Response> {
      return localVarFp
        .getMealPlanTemplate(username, id, hash, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get meal plan templates from user or public ones.
     * @summary Get Meal Plan Templates
     * @param {string} username The username.
     * @param {string} hash The private hash for the username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMealPlanTemplates(
      username: string,
      hash: string,
      options?: any
    ): AxiosPromise<GetMealPlanTemplates200Response> {
      return localVarFp
        .getMealPlanTemplates(username, hash, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve a meal planned week for the given user. The username must be a spoonacular user and the hash must the the user\'s hash that can be found in his/her account.
     * @summary Get Meal Plan Week
     * @param {string} username The username.
     * @param {string} startDate The start date of the meal planned week in the format yyyy-mm-dd.
     * @param {string} hash The private hash for the username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMealPlanWeek(
      username: string,
      startDate: string,
      hash: string,
      options?: any
    ): AxiosPromise<GetMealPlanWeek200Response> {
      return localVarFp
        .getMealPlanWeek(username, startDate, hash, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the current shopping list for the given user.
     * @summary Get Shopping List
     * @param {string} username The username.
     * @param {string} hash The private hash for the username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShoppingList(
      username: string,
      hash: string,
      options?: any
    ): AxiosPromise<GetShoppingList200Response> {
      return localVarFp
        .getShoppingList(username, hash, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * MealPlanningApi - object-oriented interface
 * @export
 * @class MealPlanningApi
 * @extends {BaseAPI}
 */
export class MealPlanningApi extends BaseAPI {
  /**
   * Add a meal plan template for a user.
   * @summary Add Meal Plan Template
   * @param {string} username The username.
   * @param {string} hash The private hash for the username.
   * @param {AddToMealPlanRequest} addToMealPlanRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MealPlanningApi
   */
  public addMealPlanTemplate(
    username: string,
    hash: string,
    addToMealPlanRequest: AddToMealPlanRequest,
    options?: RawAxiosRequestConfig
  ) {
    return MealPlanningApiFp(this.configuration)
      .addMealPlanTemplate(username, hash, addToMealPlanRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Add an item to the user\'s meal plan.
   * @summary Add to Meal Plan
   * @param {string} username The username.
   * @param {string} hash The private hash for the username.
   * @param {AddToMealPlanRequest} addToMealPlanRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MealPlanningApi
   */
  public addToMealPlan(
    username: string,
    hash: string,
    addToMealPlanRequest: AddToMealPlanRequest,
    options?: RawAxiosRequestConfig
  ) {
    return MealPlanningApiFp(this.configuration)
      .addToMealPlan(username, hash, addToMealPlanRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Add an item to the current shopping list of a user.
   * @summary Add to Shopping List
   * @param {string} username The username.
   * @param {string} hash The private hash for the username.
   * @param {AddToMealPlanRequest} addToMealPlanRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MealPlanningApi
   */
  public addToShoppingList(
    username: string,
    hash: string,
    addToMealPlanRequest: AddToMealPlanRequest,
    options?: RawAxiosRequestConfig
  ) {
    return MealPlanningApiFp(this.configuration)
      .addToShoppingList(username, hash, addToMealPlanRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete all planned items from the user\'s meal plan for a specific day.
   * @summary Clear Meal Plan Day
   * @param {string} username The username.
   * @param {string} date The date in the format yyyy-mm-dd.
   * @param {string} hash The private hash for the username.
   * @param {ClearMealPlanDayRequest} clearMealPlanDayRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MealPlanningApi
   */
  public clearMealPlanDay(
    username: string,
    date: string,
    hash: string,
    clearMealPlanDayRequest: ClearMealPlanDayRequest,
    options?: RawAxiosRequestConfig
  ) {
    return MealPlanningApiFp(this.configuration)
      .clearMealPlanDay(username, date, hash, clearMealPlanDayRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * In order to call user-specific endpoints, you need to connect your app\'s users to spoonacular users.
   * @summary Connect User
   * @param {object} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MealPlanningApi
   */
  public connectUser(body: object, options?: RawAxiosRequestConfig) {
    return MealPlanningApiFp(this.configuration)
      .connectUser(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete an item from the user\'s meal plan.
   * @summary Delete from Meal Plan
   * @param {string} username The username.
   * @param {number} id The shopping list item id.
   * @param {string} hash The private hash for the username.
   * @param {DeleteFromMealPlanRequest} deleteFromMealPlanRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MealPlanningApi
   */
  public deleteFromMealPlan(
    username: string,
    id: number,
    hash: string,
    deleteFromMealPlanRequest: DeleteFromMealPlanRequest,
    options?: RawAxiosRequestConfig
  ) {
    return MealPlanningApiFp(this.configuration)
      .deleteFromMealPlan(
        username,
        id,
        hash,
        deleteFromMealPlanRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete an item from the current shopping list of the user.
   * @summary Delete from Shopping List
   * @param {string} username The username.
   * @param {number} id The item\&#39;s id.
   * @param {string} hash The private hash for the username.
   * @param {DeleteFromMealPlanRequest} deleteFromMealPlanRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MealPlanningApi
   */
  public deleteFromShoppingList(
    username: string,
    id: number,
    hash: string,
    deleteFromMealPlanRequest: DeleteFromMealPlanRequest,
    options?: RawAxiosRequestConfig
  ) {
    return MealPlanningApiFp(this.configuration)
      .deleteFromShoppingList(
        username,
        id,
        hash,
        deleteFromMealPlanRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a meal plan template for a user.
   * @summary Delete Meal Plan Template
   * @param {string} username The username.
   * @param {number} id The item\&#39;s id.
   * @param {string} hash The private hash for the username.
   * @param {DeleteFromMealPlanRequest} deleteFromMealPlanRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MealPlanningApi
   */
  public deleteMealPlanTemplate(
    username: string,
    id: number,
    hash: string,
    deleteFromMealPlanRequest: DeleteFromMealPlanRequest,
    options?: RawAxiosRequestConfig
  ) {
    return MealPlanningApiFp(this.configuration)
      .deleteMealPlanTemplate(
        username,
        id,
        hash,
        deleteFromMealPlanRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Generate a meal plan with three meals per day (breakfast, lunch, and dinner).
   * @summary Generate Meal Plan
   * @param {string} [timeFrame] Either for one \&quot;day\&quot; or an entire \&quot;week\&quot;.
   * @param {number} [targetCalories] What is the caloric target for one day? The meal plan generator will try to get as close as possible to that goal.
   * @param {string} [diet] Enter a diet that the meal plan has to adhere to. See a full list of supported diets.
   * @param {string} [exclude] A comma-separated list of allergens or ingredients that must be excluded.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MealPlanningApi
   */
  public generateMealPlan(
    timeFrame?: string,
    targetCalories?: number,
    diet?: string,
    exclude?: string,
    options?: RawAxiosRequestConfig
  ) {
    return MealPlanningApiFp(this.configuration)
      .generateMealPlan(timeFrame, targetCalories, diet, exclude, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Generate the shopping list for a user from the meal planner in a given time frame.
   * @summary Generate Shopping List
   * @param {string} username The username.
   * @param {string} startDate The start date in the format yyyy-mm-dd.
   * @param {string} endDate The end date in the format yyyy-mm-dd.
   * @param {string} hash The private hash for the username.
   * @param {GenerateShoppingListRequest} generateShoppingListRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MealPlanningApi
   */
  public generateShoppingList(
    username: string,
    startDate: string,
    endDate: string,
    hash: string,
    generateShoppingListRequest: GenerateShoppingListRequest,
    options?: RawAxiosRequestConfig
  ) {
    return MealPlanningApiFp(this.configuration)
      .generateShoppingList(
        username,
        startDate,
        endDate,
        hash,
        generateShoppingListRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get information about a meal plan template.
   * @summary Get Meal Plan Template
   * @param {string} username The username.
   * @param {number} id The item\&#39;s id.
   * @param {string} hash The private hash for the username.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MealPlanningApi
   */
  public getMealPlanTemplate(
    username: string,
    id: number,
    hash: string,
    options?: RawAxiosRequestConfig
  ) {
    return MealPlanningApiFp(this.configuration)
      .getMealPlanTemplate(username, id, hash, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get meal plan templates from user or public ones.
   * @summary Get Meal Plan Templates
   * @param {string} username The username.
   * @param {string} hash The private hash for the username.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MealPlanningApi
   */
  public getMealPlanTemplates(
    username: string,
    hash: string,
    options?: RawAxiosRequestConfig
  ) {
    return MealPlanningApiFp(this.configuration)
      .getMealPlanTemplates(username, hash, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve a meal planned week for the given user. The username must be a spoonacular user and the hash must the the user\'s hash that can be found in his/her account.
   * @summary Get Meal Plan Week
   * @param {string} username The username.
   * @param {string} startDate The start date of the meal planned week in the format yyyy-mm-dd.
   * @param {string} hash The private hash for the username.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MealPlanningApi
   */
  public getMealPlanWeek(
    username: string,
    startDate: string,
    hash: string,
    options?: RawAxiosRequestConfig
  ) {
    return MealPlanningApiFp(this.configuration)
      .getMealPlanWeek(username, startDate, hash, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the current shopping list for the given user.
   * @summary Get Shopping List
   * @param {string} username The username.
   * @param {string} hash The private hash for the username.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MealPlanningApi
   */
  public getShoppingList(
    username: string,
    hash: string,
    options?: RawAxiosRequestConfig
  ) {
    return MealPlanningApiFp(this.configuration)
      .getShoppingList(username, hash, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * MenuItemsApi - axios parameter creator
 * @export
 */
export const MenuItemsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Generate suggestions for menu items based on a (partial) query. The matches will be found by looking in the title only.
     * @summary Autocomplete Menu Item Search
     * @param {string} query The (partial) search query.
     * @param {number} [number] The number of results to return (between 1 and 25).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autocompleteMenuItemSearch: async (
      query: string,
      number?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists("autocompleteMenuItemSearch", "query", query);
      const localVarPath = `/food/menuItems/suggest`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (query !== undefined) {
        localVarQueryParameter["query"] = query;
      }

      if (number !== undefined) {
        localVarQueryParameter["number"] = number;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Use a menu item id to get all available information about a menu item, such as nutrition.
     * @summary Get Menu Item Information
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMenuItemInformation: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getMenuItemInformation", "id", id);
      const localVarPath = `/food/menuItems/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Visualize a menu item\'s nutritional information as HTML including CSS.
     * @summary Menu Item Nutrition by ID Image
     * @param {number} id The menu item id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    menuItemNutritionByIDImage: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("menuItemNutritionByIDImage", "id", id);
      const localVarPath = `/food/menuItems/{id}/nutritionWidget.png`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Visualize a menu item\'s nutritional label information as an image.
     * @summary Menu Item Nutrition Label Image
     * @param {number} id The menu item id.
     * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
     * @param {boolean} [showZeroValues] Whether to show zero values.
     * @param {boolean} [showIngredients] Whether to show a list of ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    menuItemNutritionLabelImage: async (
      id: number,
      showOptionalNutrients?: boolean,
      showZeroValues?: boolean,
      showIngredients?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("menuItemNutritionLabelImage", "id", id);
      const localVarPath = `/food/menuItems/{id}/nutritionLabel.png`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (showOptionalNutrients !== undefined) {
        localVarQueryParameter["showOptionalNutrients"] = showOptionalNutrients;
      }

      if (showZeroValues !== undefined) {
        localVarQueryParameter["showZeroValues"] = showZeroValues;
      }

      if (showIngredients !== undefined) {
        localVarQueryParameter["showIngredients"] = showIngredients;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Visualize a menu item\'s nutritional label information as HTML including CSS.
     * @summary Menu Item Nutrition Label Widget
     * @param {number} id The menu item id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
     * @param {boolean} [showZeroValues] Whether to show zero values.
     * @param {boolean} [showIngredients] Whether to show a list of ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    menuItemNutritionLabelWidget: async (
      id: number,
      defaultCss?: boolean,
      showOptionalNutrients?: boolean,
      showZeroValues?: boolean,
      showIngredients?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("menuItemNutritionLabelWidget", "id", id);
      const localVarPath = `/food/menuItems/{id}/nutritionLabel`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (defaultCss !== undefined) {
        localVarQueryParameter["defaultCss"] = defaultCss;
      }

      if (showOptionalNutrients !== undefined) {
        localVarQueryParameter["showOptionalNutrients"] = showOptionalNutrients;
      }

      if (showZeroValues !== undefined) {
        localVarQueryParameter["showZeroValues"] = showZeroValues;
      }

      if (showIngredients !== undefined) {
        localVarQueryParameter["showIngredients"] = showIngredients;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Search over 115,000 menu items from over 800 fast food and chain restaurants. For example, McDonald\'s Big Mac or Starbucks Mocha.
     * @summary Search Menu Items
     * @param {string} [query] The (natural language) search query.
     * @param {number} [minCalories] The minimum amount of calories the menu item must have.
     * @param {number} [maxCalories] The maximum amount of calories the menu item can have.
     * @param {number} [minCarbs] The minimum amount of carbohydrates in grams the menu item must have.
     * @param {number} [maxCarbs] The maximum amount of carbohydrates in grams the menu item can have.
     * @param {number} [minProtein] The minimum amount of protein in grams the menu item must have.
     * @param {number} [maxProtein] The maximum amount of protein in grams the menu item can have.
     * @param {number} [minFat] The minimum amount of fat in grams the menu item must have.
     * @param {number} [maxFat] The maximum amount of fat in grams the menu item can have.
     * @param {boolean} [addMenuItemInformation] If set to true, you get more information about the menu items returned.
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchMenuItems: async (
      query?: string,
      minCalories?: number,
      maxCalories?: number,
      minCarbs?: number,
      maxCarbs?: number,
      minProtein?: number,
      maxProtein?: number,
      minFat?: number,
      maxFat?: number,
      addMenuItemInformation?: boolean,
      offset?: number,
      number?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/food/menuItems/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (query !== undefined) {
        localVarQueryParameter["query"] = query;
      }

      if (minCalories !== undefined) {
        localVarQueryParameter["minCalories"] = minCalories;
      }

      if (maxCalories !== undefined) {
        localVarQueryParameter["maxCalories"] = maxCalories;
      }

      if (minCarbs !== undefined) {
        localVarQueryParameter["minCarbs"] = minCarbs;
      }

      if (maxCarbs !== undefined) {
        localVarQueryParameter["maxCarbs"] = maxCarbs;
      }

      if (minProtein !== undefined) {
        localVarQueryParameter["minProtein"] = minProtein;
      }

      if (maxProtein !== undefined) {
        localVarQueryParameter["maxProtein"] = maxProtein;
      }

      if (minFat !== undefined) {
        localVarQueryParameter["minFat"] = minFat;
      }

      if (maxFat !== undefined) {
        localVarQueryParameter["maxFat"] = maxFat;
      }

      if (addMenuItemInformation !== undefined) {
        localVarQueryParameter["addMenuItemInformation"] =
          addMenuItemInformation;
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
      }

      if (number !== undefined) {
        localVarQueryParameter["number"] = number;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Visualize a menu item\'s nutritional information as HTML including CSS.
     * @summary Menu Item Nutrition by ID Widget
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {VisualizeMenuItemNutritionByIDAcceptEnum} [accept] Accept header.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizeMenuItemNutritionByID: async (
      id: number,
      defaultCss?: boolean,
      accept?: VisualizeMenuItemNutritionByIDAcceptEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("visualizeMenuItemNutritionByID", "id", id);
      const localVarPath = `/food/menuItems/{id}/nutritionWidget`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (defaultCss !== undefined) {
        localVarQueryParameter["defaultCss"] = defaultCss;
      }

      if (accept != null) {
        localVarHeaderParameter["Accept"] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MenuItemsApi - functional programming interface
 * @export
 */
export const MenuItemsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    MenuItemsApiAxiosParamCreator(configuration);
  return {
    /**
     * Generate suggestions for menu items based on a (partial) query. The matches will be found by looking in the title only.
     * @summary Autocomplete Menu Item Search
     * @param {string} query The (partial) search query.
     * @param {number} [number] The number of results to return (between 1 and 25).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autocompleteMenuItemSearch(
      query: string,
      number?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AutocompleteMenuItemSearch200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.autocompleteMenuItemSearch(
          query,
          number,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MenuItemsApi.autocompleteMenuItemSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Use a menu item id to get all available information about a menu item, such as nutrition.
     * @summary Get Menu Item Information
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMenuItemInformation(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetMenuItemInformation200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMenuItemInformation(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MenuItemsApi.getMenuItemInformation"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Visualize a menu item\'s nutritional information as HTML including CSS.
     * @summary Menu Item Nutrition by ID Image
     * @param {number} id The menu item id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async menuItemNutritionByIDImage(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.menuItemNutritionByIDImage(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MenuItemsApi.menuItemNutritionByIDImage"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Visualize a menu item\'s nutritional label information as an image.
     * @summary Menu Item Nutrition Label Image
     * @param {number} id The menu item id.
     * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
     * @param {boolean} [showZeroValues] Whether to show zero values.
     * @param {boolean} [showIngredients] Whether to show a list of ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async menuItemNutritionLabelImage(
      id: number,
      showOptionalNutrients?: boolean,
      showZeroValues?: boolean,
      showIngredients?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.menuItemNutritionLabelImage(
          id,
          showOptionalNutrients,
          showZeroValues,
          showIngredients,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MenuItemsApi.menuItemNutritionLabelImage"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Visualize a menu item\'s nutritional label information as HTML including CSS.
     * @summary Menu Item Nutrition Label Widget
     * @param {number} id The menu item id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
     * @param {boolean} [showZeroValues] Whether to show zero values.
     * @param {boolean} [showIngredients] Whether to show a list of ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async menuItemNutritionLabelWidget(
      id: number,
      defaultCss?: boolean,
      showOptionalNutrients?: boolean,
      showZeroValues?: boolean,
      showIngredients?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.menuItemNutritionLabelWidget(
          id,
          defaultCss,
          showOptionalNutrients,
          showZeroValues,
          showIngredients,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MenuItemsApi.menuItemNutritionLabelWidget"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Search over 115,000 menu items from over 800 fast food and chain restaurants. For example, McDonald\'s Big Mac or Starbucks Mocha.
     * @summary Search Menu Items
     * @param {string} [query] The (natural language) search query.
     * @param {number} [minCalories] The minimum amount of calories the menu item must have.
     * @param {number} [maxCalories] The maximum amount of calories the menu item can have.
     * @param {number} [minCarbs] The minimum amount of carbohydrates in grams the menu item must have.
     * @param {number} [maxCarbs] The maximum amount of carbohydrates in grams the menu item can have.
     * @param {number} [minProtein] The minimum amount of protein in grams the menu item must have.
     * @param {number} [maxProtein] The maximum amount of protein in grams the menu item can have.
     * @param {number} [minFat] The minimum amount of fat in grams the menu item must have.
     * @param {number} [maxFat] The maximum amount of fat in grams the menu item can have.
     * @param {boolean} [addMenuItemInformation] If set to true, you get more information about the menu items returned.
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchMenuItems(
      query?: string,
      minCalories?: number,
      maxCalories?: number,
      minCarbs?: number,
      maxCarbs?: number,
      minProtein?: number,
      maxProtein?: number,
      minFat?: number,
      maxFat?: number,
      addMenuItemInformation?: boolean,
      offset?: number,
      number?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SearchMenuItems200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchMenuItems(
        query,
        minCalories,
        maxCalories,
        minCarbs,
        maxCarbs,
        minProtein,
        maxProtein,
        minFat,
        maxFat,
        addMenuItemInformation,
        offset,
        number,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MenuItemsApi.searchMenuItems"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Visualize a menu item\'s nutritional information as HTML including CSS.
     * @summary Menu Item Nutrition by ID Widget
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {VisualizeMenuItemNutritionByIDAcceptEnum} [accept] Accept header.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async visualizeMenuItemNutritionByID(
      id: number,
      defaultCss?: boolean,
      accept?: VisualizeMenuItemNutritionByIDAcceptEnum,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.visualizeMenuItemNutritionByID(
          id,
          defaultCss,
          accept,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MenuItemsApi.visualizeMenuItemNutritionByID"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * MenuItemsApi - factory interface
 * @export
 */
export const MenuItemsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MenuItemsApiFp(configuration);
  return {
    /**
     * Generate suggestions for menu items based on a (partial) query. The matches will be found by looking in the title only.
     * @summary Autocomplete Menu Item Search
     * @param {string} query The (partial) search query.
     * @param {number} [number] The number of results to return (between 1 and 25).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autocompleteMenuItemSearch(
      query: string,
      number?: number,
      options?: any
    ): AxiosPromise<AutocompleteMenuItemSearch200Response> {
      return localVarFp
        .autocompleteMenuItemSearch(query, number, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Use a menu item id to get all available information about a menu item, such as nutrition.
     * @summary Get Menu Item Information
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMenuItemInformation(
      id: number,
      options?: any
    ): AxiosPromise<GetMenuItemInformation200Response> {
      return localVarFp
        .getMenuItemInformation(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Visualize a menu item\'s nutritional information as HTML including CSS.
     * @summary Menu Item Nutrition by ID Image
     * @param {number} id The menu item id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    menuItemNutritionByIDImage(
      id: number,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .menuItemNutritionByIDImage(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Visualize a menu item\'s nutritional label information as an image.
     * @summary Menu Item Nutrition Label Image
     * @param {number} id The menu item id.
     * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
     * @param {boolean} [showZeroValues] Whether to show zero values.
     * @param {boolean} [showIngredients] Whether to show a list of ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    menuItemNutritionLabelImage(
      id: number,
      showOptionalNutrients?: boolean,
      showZeroValues?: boolean,
      showIngredients?: boolean,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .menuItemNutritionLabelImage(
          id,
          showOptionalNutrients,
          showZeroValues,
          showIngredients,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Visualize a menu item\'s nutritional label information as HTML including CSS.
     * @summary Menu Item Nutrition Label Widget
     * @param {number} id The menu item id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
     * @param {boolean} [showZeroValues] Whether to show zero values.
     * @param {boolean} [showIngredients] Whether to show a list of ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    menuItemNutritionLabelWidget(
      id: number,
      defaultCss?: boolean,
      showOptionalNutrients?: boolean,
      showZeroValues?: boolean,
      showIngredients?: boolean,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .menuItemNutritionLabelWidget(
          id,
          defaultCss,
          showOptionalNutrients,
          showZeroValues,
          showIngredients,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Search over 115,000 menu items from over 800 fast food and chain restaurants. For example, McDonald\'s Big Mac or Starbucks Mocha.
     * @summary Search Menu Items
     * @param {string} [query] The (natural language) search query.
     * @param {number} [minCalories] The minimum amount of calories the menu item must have.
     * @param {number} [maxCalories] The maximum amount of calories the menu item can have.
     * @param {number} [minCarbs] The minimum amount of carbohydrates in grams the menu item must have.
     * @param {number} [maxCarbs] The maximum amount of carbohydrates in grams the menu item can have.
     * @param {number} [minProtein] The minimum amount of protein in grams the menu item must have.
     * @param {number} [maxProtein] The maximum amount of protein in grams the menu item can have.
     * @param {number} [minFat] The minimum amount of fat in grams the menu item must have.
     * @param {number} [maxFat] The maximum amount of fat in grams the menu item can have.
     * @param {boolean} [addMenuItemInformation] If set to true, you get more information about the menu items returned.
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchMenuItems(
      query?: string,
      minCalories?: number,
      maxCalories?: number,
      minCarbs?: number,
      maxCarbs?: number,
      minProtein?: number,
      maxProtein?: number,
      minFat?: number,
      maxFat?: number,
      addMenuItemInformation?: boolean,
      offset?: number,
      number?: number,
      options?: any
    ): AxiosPromise<SearchMenuItems200Response> {
      return localVarFp
        .searchMenuItems(
          query,
          minCalories,
          maxCalories,
          minCarbs,
          maxCarbs,
          minProtein,
          maxProtein,
          minFat,
          maxFat,
          addMenuItemInformation,
          offset,
          number,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Visualize a menu item\'s nutritional information as HTML including CSS.
     * @summary Menu Item Nutrition by ID Widget
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {VisualizeMenuItemNutritionByIDAcceptEnum} [accept] Accept header.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizeMenuItemNutritionByID(
      id: number,
      defaultCss?: boolean,
      accept?: VisualizeMenuItemNutritionByIDAcceptEnum,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .visualizeMenuItemNutritionByID(id, defaultCss, accept, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * MenuItemsApi - object-oriented interface
 * @export
 * @class MenuItemsApi
 * @extends {BaseAPI}
 */
export class MenuItemsApi extends BaseAPI {
  /**
   * Generate suggestions for menu items based on a (partial) query. The matches will be found by looking in the title only.
   * @summary Autocomplete Menu Item Search
   * @param {string} query The (partial) search query.
   * @param {number} [number] The number of results to return (between 1 and 25).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MenuItemsApi
   */
  public autocompleteMenuItemSearch(
    query: string,
    number?: number,
    options?: RawAxiosRequestConfig
  ) {
    return MenuItemsApiFp(this.configuration)
      .autocompleteMenuItemSearch(query, number, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Use a menu item id to get all available information about a menu item, such as nutrition.
   * @summary Get Menu Item Information
   * @param {number} id The item\&#39;s id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MenuItemsApi
   */
  public getMenuItemInformation(id: number, options?: RawAxiosRequestConfig) {
    return MenuItemsApiFp(this.configuration)
      .getMenuItemInformation(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Visualize a menu item\'s nutritional information as HTML including CSS.
   * @summary Menu Item Nutrition by ID Image
   * @param {number} id The menu item id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MenuItemsApi
   */
  public menuItemNutritionByIDImage(
    id: number,
    options?: RawAxiosRequestConfig
  ) {
    return MenuItemsApiFp(this.configuration)
      .menuItemNutritionByIDImage(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Visualize a menu item\'s nutritional label information as an image.
   * @summary Menu Item Nutrition Label Image
   * @param {number} id The menu item id.
   * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
   * @param {boolean} [showZeroValues] Whether to show zero values.
   * @param {boolean} [showIngredients] Whether to show a list of ingredients.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MenuItemsApi
   */
  public menuItemNutritionLabelImage(
    id: number,
    showOptionalNutrients?: boolean,
    showZeroValues?: boolean,
    showIngredients?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return MenuItemsApiFp(this.configuration)
      .menuItemNutritionLabelImage(
        id,
        showOptionalNutrients,
        showZeroValues,
        showIngredients,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Visualize a menu item\'s nutritional label information as HTML including CSS.
   * @summary Menu Item Nutrition Label Widget
   * @param {number} id The menu item id.
   * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
   * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
   * @param {boolean} [showZeroValues] Whether to show zero values.
   * @param {boolean} [showIngredients] Whether to show a list of ingredients.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MenuItemsApi
   */
  public menuItemNutritionLabelWidget(
    id: number,
    defaultCss?: boolean,
    showOptionalNutrients?: boolean,
    showZeroValues?: boolean,
    showIngredients?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return MenuItemsApiFp(this.configuration)
      .menuItemNutritionLabelWidget(
        id,
        defaultCss,
        showOptionalNutrients,
        showZeroValues,
        showIngredients,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Search over 115,000 menu items from over 800 fast food and chain restaurants. For example, McDonald\'s Big Mac or Starbucks Mocha.
   * @summary Search Menu Items
   * @param {string} [query] The (natural language) search query.
   * @param {number} [minCalories] The minimum amount of calories the menu item must have.
   * @param {number} [maxCalories] The maximum amount of calories the menu item can have.
   * @param {number} [minCarbs] The minimum amount of carbohydrates in grams the menu item must have.
   * @param {number} [maxCarbs] The maximum amount of carbohydrates in grams the menu item can have.
   * @param {number} [minProtein] The minimum amount of protein in grams the menu item must have.
   * @param {number} [maxProtein] The maximum amount of protein in grams the menu item can have.
   * @param {number} [minFat] The minimum amount of fat in grams the menu item must have.
   * @param {number} [maxFat] The maximum amount of fat in grams the menu item can have.
   * @param {boolean} [addMenuItemInformation] If set to true, you get more information about the menu items returned.
   * @param {number} [offset] The number of results to skip (between 0 and 900).
   * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MenuItemsApi
   */
  public searchMenuItems(
    query?: string,
    minCalories?: number,
    maxCalories?: number,
    minCarbs?: number,
    maxCarbs?: number,
    minProtein?: number,
    maxProtein?: number,
    minFat?: number,
    maxFat?: number,
    addMenuItemInformation?: boolean,
    offset?: number,
    number?: number,
    options?: RawAxiosRequestConfig
  ) {
    return MenuItemsApiFp(this.configuration)
      .searchMenuItems(
        query,
        minCalories,
        maxCalories,
        minCarbs,
        maxCarbs,
        minProtein,
        maxProtein,
        minFat,
        maxFat,
        addMenuItemInformation,
        offset,
        number,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Visualize a menu item\'s nutritional information as HTML including CSS.
   * @summary Menu Item Nutrition by ID Widget
   * @param {number} id The item\&#39;s id.
   * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
   * @param {VisualizeMenuItemNutritionByIDAcceptEnum} [accept] Accept header.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MenuItemsApi
   */
  public visualizeMenuItemNutritionByID(
    id: number,
    defaultCss?: boolean,
    accept?: VisualizeMenuItemNutritionByIDAcceptEnum,
    options?: RawAxiosRequestConfig
  ) {
    return MenuItemsApiFp(this.configuration)
      .visualizeMenuItemNutritionByID(id, defaultCss, accept, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const VisualizeMenuItemNutritionByIDAcceptEnum = {
  ApplicationJson: "application/json",
  TextHtml: "text/html",
  Media: "media/_*",
} as const;
export type VisualizeMenuItemNutritionByIDAcceptEnum =
  (typeof VisualizeMenuItemNutritionByIDAcceptEnum)[keyof typeof VisualizeMenuItemNutritionByIDAcceptEnum];

/**
 * MiscApi - axios parameter creator
 * @export
 */
export const MiscApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Take any text and find all mentions of food contained within it. This task is also called Named Entity Recognition (NER). In this case, the entities are foods. Either dishes, such as pizza or cheeseburger, or ingredients, such as cucumber or almonds.
     * @summary Detect Food in Text
     * @param {DetectFoodInTextContentTypeEnum} [contentType] The content type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    detectFoodInText: async (
      contentType?: DetectFoodInTextContentTypeEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/food/detect`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (contentType != null) {
        localVarHeaderParameter["Content-Type"] = String(contentType);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a random joke that is related to food. Caution: this is an endpoint for adults!
     * @summary Random Food Joke
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getARandomFoodJoke: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/food/jokes/random`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint returns suggestions for things the user can say or ask the chatbot.
     * @summary Conversation Suggests
     * @param {string} query A (partial) query from the user. The endpoint will return if it matches topics it can talk about.
     * @param {number} [number] The number of suggestions to return (between 1 and 25).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConversationSuggests: async (
      query: string,
      number?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists("getConversationSuggests", "query", query);
      const localVarPath = `/food/converse/suggest`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (query !== undefined) {
        localVarQueryParameter["query"] = query;
      }

      if (number !== undefined) {
        localVarQueryParameter["number"] = number;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns random food trivia.
     * @summary Random Food Trivia
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRandomFoodTrivia: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/food/trivia/random`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Analyze a food image. The API tries to classify the image, guess the nutrition, and find a matching recipes.
     * @summary Image Analysis by URL
     * @param {string} imageUrl The URL of the image to be analyzed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imageAnalysisByURL: async (
      imageUrl: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'imageUrl' is not null or undefined
      assertParamExists("imageAnalysisByURL", "imageUrl", imageUrl);
      const localVarPath = `/food/images/analyze`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (imageUrl !== undefined) {
        localVarQueryParameter["imageUrl"] = imageUrl;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Classify a food image.
     * @summary Image Classification by URL
     * @param {string} imageUrl The URL of the image to be classified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imageClassificationByURL: async (
      imageUrl: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'imageUrl' is not null or undefined
      assertParamExists("imageClassificationByURL", "imageUrl", imageUrl);
      const localVarPath = `/food/images/classify`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (imageUrl !== undefined) {
        localVarQueryParameter["imageUrl"] = imageUrl;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Search all food content with one call. That includes recipes, grocery products, menu items, simple foods (ingredients), and food videos.
     * @summary Search All Food
     * @param {string} query The search query.
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAllFood: async (
      query: string,
      offset?: number,
      number?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists("searchAllFood", "query", query);
      const localVarPath = `/food/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (query !== undefined) {
        localVarQueryParameter["query"] = query;
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
      }

      if (number !== undefined) {
        localVarQueryParameter["number"] = number;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Search custom foods in a user\'s account.
     * @summary Search Custom Foods
     * @param {string} username The username.
     * @param {string} hash The private hash for the username.
     * @param {string} [query] The (natural language) search query.
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchCustomFoods: async (
      username: string,
      hash: string,
      query?: string,
      offset?: number,
      number?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists("searchCustomFoods", "username", username);
      // verify required parameter 'hash' is not null or undefined
      assertParamExists("searchCustomFoods", "hash", hash);
      const localVarPath = `/food/customFoods/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (query !== undefined) {
        localVarQueryParameter["query"] = query;
      }

      if (username !== undefined) {
        localVarQueryParameter["username"] = username;
      }

      if (hash !== undefined) {
        localVarQueryParameter["hash"] = hash;
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
      }

      if (number !== undefined) {
        localVarQueryParameter["number"] = number;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Find recipe and other food related videos.
     * @summary Search Food Videos
     * @param {string} [query] The (natural language) search query.
     * @param {string} [type] The type of the recipes. See a full list of supported meal types.
     * @param {string} [cuisine] The cuisine(s) of the recipes. One or more, comma separated. See a full list of supported cuisines.
     * @param {string} [diet] The diet for which the recipes must be suitable. See a full list of supported diets.
     * @param {string} [includeIngredients] A comma-separated list of ingredients that the recipes should contain.
     * @param {string} [excludeIngredients] A comma-separated list of ingredients or ingredient types that the recipes must not contain.
     * @param {number} [minLength] Minimum video length in seconds.
     * @param {number} [maxLength] Maximum video length in seconds.
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchFoodVideos: async (
      query?: string,
      type?: string,
      cuisine?: string,
      diet?: string,
      includeIngredients?: string,
      excludeIngredients?: string,
      minLength?: number,
      maxLength?: number,
      offset?: number,
      number?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/food/videos/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (query !== undefined) {
        localVarQueryParameter["query"] = query;
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type;
      }

      if (cuisine !== undefined) {
        localVarQueryParameter["cuisine"] = cuisine;
      }

      if (diet !== undefined) {
        localVarQueryParameter["diet"] = diet;
      }

      if (includeIngredients !== undefined) {
        localVarQueryParameter["includeIngredients"] = includeIngredients;
      }

      if (excludeIngredients !== undefined) {
        localVarQueryParameter["excludeIngredients"] = excludeIngredients;
      }

      if (minLength !== undefined) {
        localVarQueryParameter["minLength"] = minLength;
      }

      if (maxLength !== undefined) {
        localVarQueryParameter["maxLength"] = maxLength;
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
      }

      if (number !== undefined) {
        localVarQueryParameter["number"] = number;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Search spoonacular\'s site content. You\'ll be able to find everything that you could also find using the search suggestions on spoonacular.com. This is a suggest API so you can send partial strings as queries.
     * @summary Search Site Content
     * @param {string} query The query to search for. You can also use partial queries such as \&quot;spagh\&quot; to already find spaghetti recipes, articles, grocery products, and other content.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSiteContent: async (
      query: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists("searchSiteContent", "query", query);
      const localVarPath = `/food/site/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (query !== undefined) {
        localVarQueryParameter["query"] = query;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used to have a conversation about food with the spoonacular chatbot. Use the \"Get Conversation Suggests\" endpoint to show your user what he or she can say.
     * @summary Talk to Chatbot
     * @param {string} text The request / question / answer from the user to the chatbot.
     * @param {string} [contextId] An arbitrary globally unique id for your conversation. The conversation can contain states so you should pass your context id if you want the bot to be able to remember the conversation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    talkToChatbot: async (
      text: string,
      contextId?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'text' is not null or undefined
      assertParamExists("talkToChatbot", "text", text);
      const localVarPath = `/food/converse`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (text !== undefined) {
        localVarQueryParameter["text"] = text;
      }

      if (contextId !== undefined) {
        localVarQueryParameter["contextId"] = contextId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MiscApi - functional programming interface
 * @export
 */
export const MiscApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MiscApiAxiosParamCreator(configuration);
  return {
    /**
     * Take any text and find all mentions of food contained within it. This task is also called Named Entity Recognition (NER). In this case, the entities are foods. Either dishes, such as pizza or cheeseburger, or ingredients, such as cucumber or almonds.
     * @summary Detect Food in Text
     * @param {DetectFoodInTextContentTypeEnum} [contentType] The content type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async detectFoodInText(
      contentType?: DetectFoodInTextContentTypeEnum,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<DetectFoodInText200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.detectFoodInText(contentType, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MiscApi.detectFoodInText"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a random joke that is related to food. Caution: this is an endpoint for adults!
     * @summary Random Food Joke
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getARandomFoodJoke(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetARandomFoodJoke200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getARandomFoodJoke(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MiscApi.getARandomFoodJoke"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * This endpoint returns suggestions for things the user can say or ask the chatbot.
     * @summary Conversation Suggests
     * @param {string} query A (partial) query from the user. The endpoint will return if it matches topics it can talk about.
     * @param {number} [number] The number of suggestions to return (between 1 and 25).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConversationSuggests(
      query: string,
      number?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetConversationSuggests200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getConversationSuggests(
          query,
          number,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MiscApi.getConversationSuggests"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns random food trivia.
     * @summary Random Food Trivia
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRandomFoodTrivia(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetRandomFoodTrivia200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRandomFoodTrivia(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MiscApi.getRandomFoodTrivia"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Analyze a food image. The API tries to classify the image, guess the nutrition, and find a matching recipes.
     * @summary Image Analysis by URL
     * @param {string} imageUrl The URL of the image to be analyzed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imageAnalysisByURL(
      imageUrl: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ImageAnalysisByURL200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.imageAnalysisByURL(imageUrl, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MiscApi.imageAnalysisByURL"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Classify a food image.
     * @summary Image Classification by URL
     * @param {string} imageUrl The URL of the image to be classified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imageClassificationByURL(
      imageUrl: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ImageClassificationByURL200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.imageClassificationByURL(
          imageUrl,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MiscApi.imageClassificationByURL"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Search all food content with one call. That includes recipes, grocery products, menu items, simple foods (ingredients), and food videos.
     * @summary Search All Food
     * @param {string} query The search query.
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchAllFood(
      query: string,
      offset?: number,
      number?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SearchAllFood200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchAllFood(
        query,
        offset,
        number,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MiscApi.searchAllFood"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Search custom foods in a user\'s account.
     * @summary Search Custom Foods
     * @param {string} username The username.
     * @param {string} hash The private hash for the username.
     * @param {string} [query] The (natural language) search query.
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchCustomFoods(
      username: string,
      hash: string,
      query?: string,
      offset?: number,
      number?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SearchCustomFoods200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.searchCustomFoods(
          username,
          hash,
          query,
          offset,
          number,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MiscApi.searchCustomFoods"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Find recipe and other food related videos.
     * @summary Search Food Videos
     * @param {string} [query] The (natural language) search query.
     * @param {string} [type] The type of the recipes. See a full list of supported meal types.
     * @param {string} [cuisine] The cuisine(s) of the recipes. One or more, comma separated. See a full list of supported cuisines.
     * @param {string} [diet] The diet for which the recipes must be suitable. See a full list of supported diets.
     * @param {string} [includeIngredients] A comma-separated list of ingredients that the recipes should contain.
     * @param {string} [excludeIngredients] A comma-separated list of ingredients or ingredient types that the recipes must not contain.
     * @param {number} [minLength] Minimum video length in seconds.
     * @param {number} [maxLength] Maximum video length in seconds.
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchFoodVideos(
      query?: string,
      type?: string,
      cuisine?: string,
      diet?: string,
      includeIngredients?: string,
      excludeIngredients?: string,
      minLength?: number,
      maxLength?: number,
      offset?: number,
      number?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SearchFoodVideos200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.searchFoodVideos(
          query,
          type,
          cuisine,
          diet,
          includeIngredients,
          excludeIngredients,
          minLength,
          maxLength,
          offset,
          number,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MiscApi.searchFoodVideos"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Search spoonacular\'s site content. You\'ll be able to find everything that you could also find using the search suggestions on spoonacular.com. This is a suggest API so you can send partial strings as queries.
     * @summary Search Site Content
     * @param {string} query The query to search for. You can also use partial queries such as \&quot;spagh\&quot; to already find spaghetti recipes, articles, grocery products, and other content.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchSiteContent(
      query: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SearchSiteContent200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.searchSiteContent(query, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MiscApi.searchSiteContent"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * This endpoint can be used to have a conversation about food with the spoonacular chatbot. Use the \"Get Conversation Suggests\" endpoint to show your user what he or she can say.
     * @summary Talk to Chatbot
     * @param {string} text The request / question / answer from the user to the chatbot.
     * @param {string} [contextId] An arbitrary globally unique id for your conversation. The conversation can contain states so you should pass your context id if you want the bot to be able to remember the conversation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async talkToChatbot(
      text: string,
      contextId?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<TalkToChatbot200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.talkToChatbot(
        text,
        contextId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MiscApi.talkToChatbot"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * MiscApi - factory interface
 * @export
 */
export const MiscApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MiscApiFp(configuration);
  return {
    /**
     * Take any text and find all mentions of food contained within it. This task is also called Named Entity Recognition (NER). In this case, the entities are foods. Either dishes, such as pizza or cheeseburger, or ingredients, such as cucumber or almonds.
     * @summary Detect Food in Text
     * @param {DetectFoodInTextContentTypeEnum} [contentType] The content type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    detectFoodInText(
      contentType?: DetectFoodInTextContentTypeEnum,
      options?: any
    ): AxiosPromise<DetectFoodInText200Response> {
      return localVarFp
        .detectFoodInText(contentType, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a random joke that is related to food. Caution: this is an endpoint for adults!
     * @summary Random Food Joke
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getARandomFoodJoke(
      options?: any
    ): AxiosPromise<GetARandomFoodJoke200Response> {
      return localVarFp
        .getARandomFoodJoke(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint returns suggestions for things the user can say or ask the chatbot.
     * @summary Conversation Suggests
     * @param {string} query A (partial) query from the user. The endpoint will return if it matches topics it can talk about.
     * @param {number} [number] The number of suggestions to return (between 1 and 25).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConversationSuggests(
      query: string,
      number?: number,
      options?: any
    ): AxiosPromise<GetConversationSuggests200Response> {
      return localVarFp
        .getConversationSuggests(query, number, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns random food trivia.
     * @summary Random Food Trivia
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRandomFoodTrivia(
      options?: any
    ): AxiosPromise<GetRandomFoodTrivia200Response> {
      return localVarFp
        .getRandomFoodTrivia(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Analyze a food image. The API tries to classify the image, guess the nutrition, and find a matching recipes.
     * @summary Image Analysis by URL
     * @param {string} imageUrl The URL of the image to be analyzed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imageAnalysisByURL(
      imageUrl: string,
      options?: any
    ): AxiosPromise<ImageAnalysisByURL200Response> {
      return localVarFp
        .imageAnalysisByURL(imageUrl, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Classify a food image.
     * @summary Image Classification by URL
     * @param {string} imageUrl The URL of the image to be classified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imageClassificationByURL(
      imageUrl: string,
      options?: any
    ): AxiosPromise<ImageClassificationByURL200Response> {
      return localVarFp
        .imageClassificationByURL(imageUrl, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Search all food content with one call. That includes recipes, grocery products, menu items, simple foods (ingredients), and food videos.
     * @summary Search All Food
     * @param {string} query The search query.
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAllFood(
      query: string,
      offset?: number,
      number?: number,
      options?: any
    ): AxiosPromise<SearchAllFood200Response> {
      return localVarFp
        .searchAllFood(query, offset, number, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Search custom foods in a user\'s account.
     * @summary Search Custom Foods
     * @param {string} username The username.
     * @param {string} hash The private hash for the username.
     * @param {string} [query] The (natural language) search query.
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchCustomFoods(
      username: string,
      hash: string,
      query?: string,
      offset?: number,
      number?: number,
      options?: any
    ): AxiosPromise<SearchCustomFoods200Response> {
      return localVarFp
        .searchCustomFoods(username, hash, query, offset, number, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Find recipe and other food related videos.
     * @summary Search Food Videos
     * @param {string} [query] The (natural language) search query.
     * @param {string} [type] The type of the recipes. See a full list of supported meal types.
     * @param {string} [cuisine] The cuisine(s) of the recipes. One or more, comma separated. See a full list of supported cuisines.
     * @param {string} [diet] The diet for which the recipes must be suitable. See a full list of supported diets.
     * @param {string} [includeIngredients] A comma-separated list of ingredients that the recipes should contain.
     * @param {string} [excludeIngredients] A comma-separated list of ingredients or ingredient types that the recipes must not contain.
     * @param {number} [minLength] Minimum video length in seconds.
     * @param {number} [maxLength] Maximum video length in seconds.
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchFoodVideos(
      query?: string,
      type?: string,
      cuisine?: string,
      diet?: string,
      includeIngredients?: string,
      excludeIngredients?: string,
      minLength?: number,
      maxLength?: number,
      offset?: number,
      number?: number,
      options?: any
    ): AxiosPromise<SearchFoodVideos200Response> {
      return localVarFp
        .searchFoodVideos(
          query,
          type,
          cuisine,
          diet,
          includeIngredients,
          excludeIngredients,
          minLength,
          maxLength,
          offset,
          number,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Search spoonacular\'s site content. You\'ll be able to find everything that you could also find using the search suggestions on spoonacular.com. This is a suggest API so you can send partial strings as queries.
     * @summary Search Site Content
     * @param {string} query The query to search for. You can also use partial queries such as \&quot;spagh\&quot; to already find spaghetti recipes, articles, grocery products, and other content.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSiteContent(
      query: string,
      options?: any
    ): AxiosPromise<SearchSiteContent200Response> {
      return localVarFp
        .searchSiteContent(query, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint can be used to have a conversation about food with the spoonacular chatbot. Use the \"Get Conversation Suggests\" endpoint to show your user what he or she can say.
     * @summary Talk to Chatbot
     * @param {string} text The request / question / answer from the user to the chatbot.
     * @param {string} [contextId] An arbitrary globally unique id for your conversation. The conversation can contain states so you should pass your context id if you want the bot to be able to remember the conversation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    talkToChatbot(
      text: string,
      contextId?: string,
      options?: any
    ): AxiosPromise<TalkToChatbot200Response> {
      return localVarFp
        .talkToChatbot(text, contextId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * MiscApi - object-oriented interface
 * @export
 * @class MiscApi
 * @extends {BaseAPI}
 */
export class MiscApi extends BaseAPI {
  /**
   * Take any text and find all mentions of food contained within it. This task is also called Named Entity Recognition (NER). In this case, the entities are foods. Either dishes, such as pizza or cheeseburger, or ingredients, such as cucumber or almonds.
   * @summary Detect Food in Text
   * @param {DetectFoodInTextContentTypeEnum} [contentType] The content type.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MiscApi
   */
  public detectFoodInText(
    contentType?: DetectFoodInTextContentTypeEnum,
    options?: RawAxiosRequestConfig
  ) {
    return MiscApiFp(this.configuration)
      .detectFoodInText(contentType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a random joke that is related to food. Caution: this is an endpoint for adults!
   * @summary Random Food Joke
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MiscApi
   */
  public getARandomFoodJoke(options?: RawAxiosRequestConfig) {
    return MiscApiFp(this.configuration)
      .getARandomFoodJoke(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint returns suggestions for things the user can say or ask the chatbot.
   * @summary Conversation Suggests
   * @param {string} query A (partial) query from the user. The endpoint will return if it matches topics it can talk about.
   * @param {number} [number] The number of suggestions to return (between 1 and 25).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MiscApi
   */
  public getConversationSuggests(
    query: string,
    number?: number,
    options?: RawAxiosRequestConfig
  ) {
    return MiscApiFp(this.configuration)
      .getConversationSuggests(query, number, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns random food trivia.
   * @summary Random Food Trivia
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MiscApi
   */
  public getRandomFoodTrivia(options?: RawAxiosRequestConfig) {
    return MiscApiFp(this.configuration)
      .getRandomFoodTrivia(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Analyze a food image. The API tries to classify the image, guess the nutrition, and find a matching recipes.
   * @summary Image Analysis by URL
   * @param {string} imageUrl The URL of the image to be analyzed.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MiscApi
   */
  public imageAnalysisByURL(imageUrl: string, options?: RawAxiosRequestConfig) {
    return MiscApiFp(this.configuration)
      .imageAnalysisByURL(imageUrl, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Classify a food image.
   * @summary Image Classification by URL
   * @param {string} imageUrl The URL of the image to be classified.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MiscApi
   */
  public imageClassificationByURL(
    imageUrl: string,
    options?: RawAxiosRequestConfig
  ) {
    return MiscApiFp(this.configuration)
      .imageClassificationByURL(imageUrl, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Search all food content with one call. That includes recipes, grocery products, menu items, simple foods (ingredients), and food videos.
   * @summary Search All Food
   * @param {string} query The search query.
   * @param {number} [offset] The number of results to skip (between 0 and 900).
   * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MiscApi
   */
  public searchAllFood(
    query: string,
    offset?: number,
    number?: number,
    options?: RawAxiosRequestConfig
  ) {
    return MiscApiFp(this.configuration)
      .searchAllFood(query, offset, number, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Search custom foods in a user\'s account.
   * @summary Search Custom Foods
   * @param {string} username The username.
   * @param {string} hash The private hash for the username.
   * @param {string} [query] The (natural language) search query.
   * @param {number} [offset] The number of results to skip (between 0 and 900).
   * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MiscApi
   */
  public searchCustomFoods(
    username: string,
    hash: string,
    query?: string,
    offset?: number,
    number?: number,
    options?: RawAxiosRequestConfig
  ) {
    return MiscApiFp(this.configuration)
      .searchCustomFoods(username, hash, query, offset, number, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Find recipe and other food related videos.
   * @summary Search Food Videos
   * @param {string} [query] The (natural language) search query.
   * @param {string} [type] The type of the recipes. See a full list of supported meal types.
   * @param {string} [cuisine] The cuisine(s) of the recipes. One or more, comma separated. See a full list of supported cuisines.
   * @param {string} [diet] The diet for which the recipes must be suitable. See a full list of supported diets.
   * @param {string} [includeIngredients] A comma-separated list of ingredients that the recipes should contain.
   * @param {string} [excludeIngredients] A comma-separated list of ingredients or ingredient types that the recipes must not contain.
   * @param {number} [minLength] Minimum video length in seconds.
   * @param {number} [maxLength] Maximum video length in seconds.
   * @param {number} [offset] The number of results to skip (between 0 and 900).
   * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MiscApi
   */
  public searchFoodVideos(
    query?: string,
    type?: string,
    cuisine?: string,
    diet?: string,
    includeIngredients?: string,
    excludeIngredients?: string,
    minLength?: number,
    maxLength?: number,
    offset?: number,
    number?: number,
    options?: RawAxiosRequestConfig
  ) {
    return MiscApiFp(this.configuration)
      .searchFoodVideos(
        query,
        type,
        cuisine,
        diet,
        includeIngredients,
        excludeIngredients,
        minLength,
        maxLength,
        offset,
        number,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Search spoonacular\'s site content. You\'ll be able to find everything that you could also find using the search suggestions on spoonacular.com. This is a suggest API so you can send partial strings as queries.
   * @summary Search Site Content
   * @param {string} query The query to search for. You can also use partial queries such as \&quot;spagh\&quot; to already find spaghetti recipes, articles, grocery products, and other content.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MiscApi
   */
  public searchSiteContent(query: string, options?: RawAxiosRequestConfig) {
    return MiscApiFp(this.configuration)
      .searchSiteContent(query, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint can be used to have a conversation about food with the spoonacular chatbot. Use the \"Get Conversation Suggests\" endpoint to show your user what he or she can say.
   * @summary Talk to Chatbot
   * @param {string} text The request / question / answer from the user to the chatbot.
   * @param {string} [contextId] An arbitrary globally unique id for your conversation. The conversation can contain states so you should pass your context id if you want the bot to be able to remember the conversation.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MiscApi
   */
  public talkToChatbot(
    text: string,
    contextId?: string,
    options?: RawAxiosRequestConfig
  ) {
    return MiscApiFp(this.configuration)
      .talkToChatbot(text, contextId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const DetectFoodInTextContentTypeEnum = {
  ApplicationXWwwFormUrlencoded: "application/x-www-form-urlencoded",
  ApplicationJson: "application/json",
  MultipartFormData: "multipart/form-data",
} as const;
export type DetectFoodInTextContentTypeEnum =
  (typeof DetectFoodInTextContentTypeEnum)[keyof typeof DetectFoodInTextContentTypeEnum];

/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Generate suggestions for grocery products based on a (partial) query. The matches will be found by looking in the title only.
     * @summary Autocomplete Product Search
     * @param {string} query The (partial) search query.
     * @param {number} [number] The number of results to return (between 1 and 25).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autocompleteProductSearch: async (
      query: string,
      number?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists("autocompleteProductSearch", "query", query);
      const localVarPath = `/food/products/suggest`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (query !== undefined) {
        localVarQueryParameter["query"] = query;
      }

      if (number !== undefined) {
        localVarQueryParameter["number"] = number;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint allows you to match a packaged food to a basic category, e.g. a specific brand of milk to the category milk.
     * @summary Classify Grocery Product
     * @param {ClassifyGroceryProductRequest} classifyGroceryProductRequest
     * @param {ClassifyGroceryProductLocaleEnum} [locale] The display name of the returned category, supported is en_US (for American English) and en_GB (for British English).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    classifyGroceryProduct: async (
      classifyGroceryProductRequest: ClassifyGroceryProductRequest,
      locale?: ClassifyGroceryProductLocaleEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'classifyGroceryProductRequest' is not null or undefined
      assertParamExists(
        "classifyGroceryProduct",
        "classifyGroceryProductRequest",
        classifyGroceryProductRequest
      );
      const localVarPath = `/food/products/classify`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        classifyGroceryProductRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Provide a set of product jsons, get back classified products.
     * @summary Classify Grocery Product Bulk
     * @param {Set<ClassifyGroceryProductBulkRequestInner>} classifyGroceryProductBulkRequestInner
     * @param {string} [locale] The display name of the returned category, supported is en_US (for American English) and en_GB (for British English).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    classifyGroceryProductBulk: async (
      classifyGroceryProductBulkRequestInner: Set<ClassifyGroceryProductBulkRequestInner>,
      locale?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'classifyGroceryProductBulkRequestInner' is not null or undefined
      assertParamExists(
        "classifyGroceryProductBulk",
        "classifyGroceryProductBulkRequestInner",
        classifyGroceryProductBulkRequestInner
      );
      const localVarPath = `/food/products/classifyBatch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        classifyGroceryProductBulkRequestInner,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Find comparable products to the given one.
     * @summary Get Comparable Products
     * @param {number} upc The UPC of the product for which you want to find comparable products.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getComparableProducts: async (
      upc: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'upc' is not null or undefined
      assertParamExists("getComparableProducts", "upc", upc);
      const localVarPath = `/food/products/upc/{upc}/comparable`.replace(
        `{${"upc"}}`,
        encodeURIComponent(String(upc))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Use a product id to get full information about a product, such as ingredients, nutrition, etc. The nutritional information is per serving.
     * @summary Get Product Information
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProductInformation: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getProductInformation", "id", id);
      const localVarPath = `/food/products/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Visualize a product\'s nutritional information as an image.
     * @summary Product Nutrition by ID Image
     * @param {number} id The id of the product.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productNutritionByIDImage: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("productNutritionByIDImage", "id", id);
      const localVarPath = `/food/products/{id}/nutritionWidget.png`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a product\'s nutrition label as an image.
     * @summary Product Nutrition Label Image
     * @param {number} id The product id.
     * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
     * @param {boolean} [showZeroValues] Whether to show zero values.
     * @param {boolean} [showIngredients] Whether to show a list of ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productNutritionLabelImage: async (
      id: number,
      showOptionalNutrients?: boolean,
      showZeroValues?: boolean,
      showIngredients?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("productNutritionLabelImage", "id", id);
      const localVarPath = `/food/products/{id}/nutritionLabel.png`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (showOptionalNutrients !== undefined) {
        localVarQueryParameter["showOptionalNutrients"] = showOptionalNutrients;
      }

      if (showZeroValues !== undefined) {
        localVarQueryParameter["showZeroValues"] = showZeroValues;
      }

      if (showIngredients !== undefined) {
        localVarQueryParameter["showIngredients"] = showIngredients;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a product\'s nutrition label as an HTML widget.
     * @summary Product Nutrition Label Widget
     * @param {number} id The product id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
     * @param {boolean} [showZeroValues] Whether to show zero values.
     * @param {boolean} [showIngredients] Whether to show a list of ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productNutritionLabelWidget: async (
      id: number,
      defaultCss?: boolean,
      showOptionalNutrients?: boolean,
      showZeroValues?: boolean,
      showIngredients?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("productNutritionLabelWidget", "id", id);
      const localVarPath = `/food/products/{id}/nutritionLabel`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (defaultCss !== undefined) {
        localVarQueryParameter["defaultCss"] = defaultCss;
      }

      if (showOptionalNutrients !== undefined) {
        localVarQueryParameter["showOptionalNutrients"] = showOptionalNutrients;
      }

      if (showZeroValues !== undefined) {
        localVarQueryParameter["showZeroValues"] = showZeroValues;
      }

      if (showIngredients !== undefined) {
        localVarQueryParameter["showIngredients"] = showIngredients;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Search packaged food products, such as frozen pizza or Greek yogurt.
     * @summary Search Grocery Products
     * @param {string} [query] The (natural language) search query.
     * @param {number} [minCalories] The minimum amount of calories the product must have.
     * @param {number} [maxCalories] The maximum amount of calories the product can have.
     * @param {number} [minCarbs] The minimum amount of carbohydrates in grams the product must have.
     * @param {number} [maxCarbs] The maximum amount of carbohydrates in grams the product can have.
     * @param {number} [minProtein] The minimum amount of protein in grams the product must have.
     * @param {number} [maxProtein] The maximum amount of protein in grams the product can have.
     * @param {number} [minFat] The minimum amount of fat in grams the product must have.
     * @param {number} [maxFat] The maximum amount of fat in grams the product can have.
     * @param {boolean} [addProductInformation] If set to true, you get more information about the products returned.
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchGroceryProducts: async (
      query?: string,
      minCalories?: number,
      maxCalories?: number,
      minCarbs?: number,
      maxCarbs?: number,
      minProtein?: number,
      maxProtein?: number,
      minFat?: number,
      maxFat?: number,
      addProductInformation?: boolean,
      offset?: number,
      number?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/food/products/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (query !== undefined) {
        localVarQueryParameter["query"] = query;
      }

      if (minCalories !== undefined) {
        localVarQueryParameter["minCalories"] = minCalories;
      }

      if (maxCalories !== undefined) {
        localVarQueryParameter["maxCalories"] = maxCalories;
      }

      if (minCarbs !== undefined) {
        localVarQueryParameter["minCarbs"] = minCarbs;
      }

      if (maxCarbs !== undefined) {
        localVarQueryParameter["maxCarbs"] = maxCarbs;
      }

      if (minProtein !== undefined) {
        localVarQueryParameter["minProtein"] = minProtein;
      }

      if (maxProtein !== undefined) {
        localVarQueryParameter["maxProtein"] = maxProtein;
      }

      if (minFat !== undefined) {
        localVarQueryParameter["minFat"] = minFat;
      }

      if (maxFat !== undefined) {
        localVarQueryParameter["maxFat"] = maxFat;
      }

      if (addProductInformation !== undefined) {
        localVarQueryParameter["addProductInformation"] = addProductInformation;
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
      }

      if (number !== undefined) {
        localVarQueryParameter["number"] = number;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information about a packaged food using its UPC.
     * @summary Search Grocery Products by UPC
     * @param {number} upc The product\&#39;s UPC.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchGroceryProductsByUPC: async (
      upc: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'upc' is not null or undefined
      assertParamExists("searchGroceryProductsByUPC", "upc", upc);
      const localVarPath = `/food/products/upc/{upc}`.replace(
        `{${"upc"}}`,
        encodeURIComponent(String(upc))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Visualize a product\'s nutritional information as HTML including CSS.
     * @summary Product Nutrition by ID Widget
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {VisualizeProductNutritionByIDAcceptEnum} [accept] Accept header.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizeProductNutritionByID: async (
      id: number,
      defaultCss?: boolean,
      accept?: VisualizeProductNutritionByIDAcceptEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("visualizeProductNutritionByID", "id", id);
      const localVarPath = `/food/products/{id}/nutritionWidget`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (defaultCss !== undefined) {
        localVarQueryParameter["defaultCss"] = defaultCss;
      }

      if (accept != null) {
        localVarHeaderParameter["Accept"] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration);
  return {
    /**
     * Generate suggestions for grocery products based on a (partial) query. The matches will be found by looking in the title only.
     * @summary Autocomplete Product Search
     * @param {string} query The (partial) search query.
     * @param {number} [number] The number of results to return (between 1 and 25).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autocompleteProductSearch(
      query: string,
      number?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AutocompleteProductSearch200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.autocompleteProductSearch(
          query,
          number,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProductsApi.autocompleteProductSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * This endpoint allows you to match a packaged food to a basic category, e.g. a specific brand of milk to the category milk.
     * @summary Classify Grocery Product
     * @param {ClassifyGroceryProductRequest} classifyGroceryProductRequest
     * @param {ClassifyGroceryProductLocaleEnum} [locale] The display name of the returned category, supported is en_US (for American English) and en_GB (for British English).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async classifyGroceryProduct(
      classifyGroceryProductRequest: ClassifyGroceryProductRequest,
      locale?: ClassifyGroceryProductLocaleEnum,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ClassifyGroceryProduct200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.classifyGroceryProduct(
          classifyGroceryProductRequest,
          locale,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProductsApi.classifyGroceryProduct"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Provide a set of product jsons, get back classified products.
     * @summary Classify Grocery Product Bulk
     * @param {Set<ClassifyGroceryProductBulkRequestInner>} classifyGroceryProductBulkRequestInner
     * @param {string} [locale] The display name of the returned category, supported is en_US (for American English) and en_GB (for British English).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async classifyGroceryProductBulk(
      classifyGroceryProductBulkRequestInner: Set<ClassifyGroceryProductBulkRequestInner>,
      locale?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Set<ClassifyGroceryProductBulk200ResponseInner>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.classifyGroceryProductBulk(
          classifyGroceryProductBulkRequestInner,
          locale,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProductsApi.classifyGroceryProductBulk"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Find comparable products to the given one.
     * @summary Get Comparable Products
     * @param {number} upc The UPC of the product for which you want to find comparable products.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getComparableProducts(
      upc: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetComparableProducts200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getComparableProducts(upc, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProductsApi.getComparableProducts"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Use a product id to get full information about a product, such as ingredients, nutrition, etc. The nutritional information is per serving.
     * @summary Get Product Information
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProductInformation(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetProductInformation200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getProductInformation(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProductsApi.getProductInformation"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Visualize a product\'s nutritional information as an image.
     * @summary Product Nutrition by ID Image
     * @param {number} id The id of the product.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async productNutritionByIDImage(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.productNutritionByIDImage(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProductsApi.productNutritionByIDImage"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a product\'s nutrition label as an image.
     * @summary Product Nutrition Label Image
     * @param {number} id The product id.
     * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
     * @param {boolean} [showZeroValues] Whether to show zero values.
     * @param {boolean} [showIngredients] Whether to show a list of ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async productNutritionLabelImage(
      id: number,
      showOptionalNutrients?: boolean,
      showZeroValues?: boolean,
      showIngredients?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.productNutritionLabelImage(
          id,
          showOptionalNutrients,
          showZeroValues,
          showIngredients,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProductsApi.productNutritionLabelImage"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a product\'s nutrition label as an HTML widget.
     * @summary Product Nutrition Label Widget
     * @param {number} id The product id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
     * @param {boolean} [showZeroValues] Whether to show zero values.
     * @param {boolean} [showIngredients] Whether to show a list of ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async productNutritionLabelWidget(
      id: number,
      defaultCss?: boolean,
      showOptionalNutrients?: boolean,
      showZeroValues?: boolean,
      showIngredients?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.productNutritionLabelWidget(
          id,
          defaultCss,
          showOptionalNutrients,
          showZeroValues,
          showIngredients,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProductsApi.productNutritionLabelWidget"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Search packaged food products, such as frozen pizza or Greek yogurt.
     * @summary Search Grocery Products
     * @param {string} [query] The (natural language) search query.
     * @param {number} [minCalories] The minimum amount of calories the product must have.
     * @param {number} [maxCalories] The maximum amount of calories the product can have.
     * @param {number} [minCarbs] The minimum amount of carbohydrates in grams the product must have.
     * @param {number} [maxCarbs] The maximum amount of carbohydrates in grams the product can have.
     * @param {number} [minProtein] The minimum amount of protein in grams the product must have.
     * @param {number} [maxProtein] The maximum amount of protein in grams the product can have.
     * @param {number} [minFat] The minimum amount of fat in grams the product must have.
     * @param {number} [maxFat] The maximum amount of fat in grams the product can have.
     * @param {boolean} [addProductInformation] If set to true, you get more information about the products returned.
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchGroceryProducts(
      query?: string,
      minCalories?: number,
      maxCalories?: number,
      minCarbs?: number,
      maxCarbs?: number,
      minProtein?: number,
      maxProtein?: number,
      minFat?: number,
      maxFat?: number,
      addProductInformation?: boolean,
      offset?: number,
      number?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SearchGroceryProducts200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.searchGroceryProducts(
          query,
          minCalories,
          maxCalories,
          minCarbs,
          maxCarbs,
          minProtein,
          maxProtein,
          minFat,
          maxFat,
          addProductInformation,
          offset,
          number,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProductsApi.searchGroceryProducts"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get information about a packaged food using its UPC.
     * @summary Search Grocery Products by UPC
     * @param {number} upc The product\&#39;s UPC.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchGroceryProductsByUPC(
      upc: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SearchGroceryProductsByUPC200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.searchGroceryProductsByUPC(
          upc,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProductsApi.searchGroceryProductsByUPC"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Visualize a product\'s nutritional information as HTML including CSS.
     * @summary Product Nutrition by ID Widget
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {VisualizeProductNutritionByIDAcceptEnum} [accept] Accept header.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async visualizeProductNutritionByID(
      id: number,
      defaultCss?: boolean,
      accept?: VisualizeProductNutritionByIDAcceptEnum,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.visualizeProductNutritionByID(
          id,
          defaultCss,
          accept,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProductsApi.visualizeProductNutritionByID"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ProductsApiFp(configuration);
  return {
    /**
     * Generate suggestions for grocery products based on a (partial) query. The matches will be found by looking in the title only.
     * @summary Autocomplete Product Search
     * @param {string} query The (partial) search query.
     * @param {number} [number] The number of results to return (between 1 and 25).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autocompleteProductSearch(
      query: string,
      number?: number,
      options?: any
    ): AxiosPromise<AutocompleteProductSearch200Response> {
      return localVarFp
        .autocompleteProductSearch(query, number, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint allows you to match a packaged food to a basic category, e.g. a specific brand of milk to the category milk.
     * @summary Classify Grocery Product
     * @param {ClassifyGroceryProductRequest} classifyGroceryProductRequest
     * @param {ClassifyGroceryProductLocaleEnum} [locale] The display name of the returned category, supported is en_US (for American English) and en_GB (for British English).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    classifyGroceryProduct(
      classifyGroceryProductRequest: ClassifyGroceryProductRequest,
      locale?: ClassifyGroceryProductLocaleEnum,
      options?: any
    ): AxiosPromise<ClassifyGroceryProduct200Response> {
      return localVarFp
        .classifyGroceryProduct(classifyGroceryProductRequest, locale, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Provide a set of product jsons, get back classified products.
     * @summary Classify Grocery Product Bulk
     * @param {Set<ClassifyGroceryProductBulkRequestInner>} classifyGroceryProductBulkRequestInner
     * @param {string} [locale] The display name of the returned category, supported is en_US (for American English) and en_GB (for British English).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    classifyGroceryProductBulk(
      classifyGroceryProductBulkRequestInner: Set<ClassifyGroceryProductBulkRequestInner>,
      locale?: string,
      options?: any
    ): AxiosPromise<Set<ClassifyGroceryProductBulk200ResponseInner>> {
      return localVarFp
        .classifyGroceryProductBulk(
          classifyGroceryProductBulkRequestInner,
          locale,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Find comparable products to the given one.
     * @summary Get Comparable Products
     * @param {number} upc The UPC of the product for which you want to find comparable products.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getComparableProducts(
      upc: number,
      options?: any
    ): AxiosPromise<GetComparableProducts200Response> {
      return localVarFp
        .getComparableProducts(upc, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Use a product id to get full information about a product, such as ingredients, nutrition, etc. The nutritional information is per serving.
     * @summary Get Product Information
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProductInformation(
      id: number,
      options?: any
    ): AxiosPromise<GetProductInformation200Response> {
      return localVarFp
        .getProductInformation(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Visualize a product\'s nutritional information as an image.
     * @summary Product Nutrition by ID Image
     * @param {number} id The id of the product.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productNutritionByIDImage(id: number, options?: any): AxiosPromise<object> {
      return localVarFp
        .productNutritionByIDImage(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a product\'s nutrition label as an image.
     * @summary Product Nutrition Label Image
     * @param {number} id The product id.
     * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
     * @param {boolean} [showZeroValues] Whether to show zero values.
     * @param {boolean} [showIngredients] Whether to show a list of ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productNutritionLabelImage(
      id: number,
      showOptionalNutrients?: boolean,
      showZeroValues?: boolean,
      showIngredients?: boolean,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .productNutritionLabelImage(
          id,
          showOptionalNutrients,
          showZeroValues,
          showIngredients,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a product\'s nutrition label as an HTML widget.
     * @summary Product Nutrition Label Widget
     * @param {number} id The product id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
     * @param {boolean} [showZeroValues] Whether to show zero values.
     * @param {boolean} [showIngredients] Whether to show a list of ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productNutritionLabelWidget(
      id: number,
      defaultCss?: boolean,
      showOptionalNutrients?: boolean,
      showZeroValues?: boolean,
      showIngredients?: boolean,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .productNutritionLabelWidget(
          id,
          defaultCss,
          showOptionalNutrients,
          showZeroValues,
          showIngredients,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Search packaged food products, such as frozen pizza or Greek yogurt.
     * @summary Search Grocery Products
     * @param {string} [query] The (natural language) search query.
     * @param {number} [minCalories] The minimum amount of calories the product must have.
     * @param {number} [maxCalories] The maximum amount of calories the product can have.
     * @param {number} [minCarbs] The minimum amount of carbohydrates in grams the product must have.
     * @param {number} [maxCarbs] The maximum amount of carbohydrates in grams the product can have.
     * @param {number} [minProtein] The minimum amount of protein in grams the product must have.
     * @param {number} [maxProtein] The maximum amount of protein in grams the product can have.
     * @param {number} [minFat] The minimum amount of fat in grams the product must have.
     * @param {number} [maxFat] The maximum amount of fat in grams the product can have.
     * @param {boolean} [addProductInformation] If set to true, you get more information about the products returned.
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchGroceryProducts(
      query?: string,
      minCalories?: number,
      maxCalories?: number,
      minCarbs?: number,
      maxCarbs?: number,
      minProtein?: number,
      maxProtein?: number,
      minFat?: number,
      maxFat?: number,
      addProductInformation?: boolean,
      offset?: number,
      number?: number,
      options?: any
    ): AxiosPromise<SearchGroceryProducts200Response> {
      return localVarFp
        .searchGroceryProducts(
          query,
          minCalories,
          maxCalories,
          minCarbs,
          maxCarbs,
          minProtein,
          maxProtein,
          minFat,
          maxFat,
          addProductInformation,
          offset,
          number,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get information about a packaged food using its UPC.
     * @summary Search Grocery Products by UPC
     * @param {number} upc The product\&#39;s UPC.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchGroceryProductsByUPC(
      upc: number,
      options?: any
    ): AxiosPromise<SearchGroceryProductsByUPC200Response> {
      return localVarFp
        .searchGroceryProductsByUPC(upc, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Visualize a product\'s nutritional information as HTML including CSS.
     * @summary Product Nutrition by ID Widget
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {VisualizeProductNutritionByIDAcceptEnum} [accept] Accept header.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizeProductNutritionByID(
      id: number,
      defaultCss?: boolean,
      accept?: VisualizeProductNutritionByIDAcceptEnum,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .visualizeProductNutritionByID(id, defaultCss, accept, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
  /**
   * Generate suggestions for grocery products based on a (partial) query. The matches will be found by looking in the title only.
   * @summary Autocomplete Product Search
   * @param {string} query The (partial) search query.
   * @param {number} [number] The number of results to return (between 1 and 25).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public autocompleteProductSearch(
    query: string,
    number?: number,
    options?: RawAxiosRequestConfig
  ) {
    return ProductsApiFp(this.configuration)
      .autocompleteProductSearch(query, number, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint allows you to match a packaged food to a basic category, e.g. a specific brand of milk to the category milk.
   * @summary Classify Grocery Product
   * @param {ClassifyGroceryProductRequest} classifyGroceryProductRequest
   * @param {ClassifyGroceryProductLocaleEnum} [locale] The display name of the returned category, supported is en_US (for American English) and en_GB (for British English).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public classifyGroceryProduct(
    classifyGroceryProductRequest: ClassifyGroceryProductRequest,
    locale?: ClassifyGroceryProductLocaleEnum,
    options?: RawAxiosRequestConfig
  ) {
    return ProductsApiFp(this.configuration)
      .classifyGroceryProduct(classifyGroceryProductRequest, locale, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Provide a set of product jsons, get back classified products.
   * @summary Classify Grocery Product Bulk
   * @param {Set<ClassifyGroceryProductBulkRequestInner>} classifyGroceryProductBulkRequestInner
   * @param {string} [locale] The display name of the returned category, supported is en_US (for American English) and en_GB (for British English).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public classifyGroceryProductBulk(
    classifyGroceryProductBulkRequestInner: Set<ClassifyGroceryProductBulkRequestInner>,
    locale?: string,
    options?: RawAxiosRequestConfig
  ) {
    return ProductsApiFp(this.configuration)
      .classifyGroceryProductBulk(
        classifyGroceryProductBulkRequestInner,
        locale,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Find comparable products to the given one.
   * @summary Get Comparable Products
   * @param {number} upc The UPC of the product for which you want to find comparable products.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public getComparableProducts(upc: number, options?: RawAxiosRequestConfig) {
    return ProductsApiFp(this.configuration)
      .getComparableProducts(upc, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Use a product id to get full information about a product, such as ingredients, nutrition, etc. The nutritional information is per serving.
   * @summary Get Product Information
   * @param {number} id The item\&#39;s id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public getProductInformation(id: number, options?: RawAxiosRequestConfig) {
    return ProductsApiFp(this.configuration)
      .getProductInformation(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Visualize a product\'s nutritional information as an image.
   * @summary Product Nutrition by ID Image
   * @param {number} id The id of the product.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public productNutritionByIDImage(
    id: number,
    options?: RawAxiosRequestConfig
  ) {
    return ProductsApiFp(this.configuration)
      .productNutritionByIDImage(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a product\'s nutrition label as an image.
   * @summary Product Nutrition Label Image
   * @param {number} id The product id.
   * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
   * @param {boolean} [showZeroValues] Whether to show zero values.
   * @param {boolean} [showIngredients] Whether to show a list of ingredients.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public productNutritionLabelImage(
    id: number,
    showOptionalNutrients?: boolean,
    showZeroValues?: boolean,
    showIngredients?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return ProductsApiFp(this.configuration)
      .productNutritionLabelImage(
        id,
        showOptionalNutrients,
        showZeroValues,
        showIngredients,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a product\'s nutrition label as an HTML widget.
   * @summary Product Nutrition Label Widget
   * @param {number} id The product id.
   * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
   * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
   * @param {boolean} [showZeroValues] Whether to show zero values.
   * @param {boolean} [showIngredients] Whether to show a list of ingredients.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public productNutritionLabelWidget(
    id: number,
    defaultCss?: boolean,
    showOptionalNutrients?: boolean,
    showZeroValues?: boolean,
    showIngredients?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return ProductsApiFp(this.configuration)
      .productNutritionLabelWidget(
        id,
        defaultCss,
        showOptionalNutrients,
        showZeroValues,
        showIngredients,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Search packaged food products, such as frozen pizza or Greek yogurt.
   * @summary Search Grocery Products
   * @param {string} [query] The (natural language) search query.
   * @param {number} [minCalories] The minimum amount of calories the product must have.
   * @param {number} [maxCalories] The maximum amount of calories the product can have.
   * @param {number} [minCarbs] The minimum amount of carbohydrates in grams the product must have.
   * @param {number} [maxCarbs] The maximum amount of carbohydrates in grams the product can have.
   * @param {number} [minProtein] The minimum amount of protein in grams the product must have.
   * @param {number} [maxProtein] The maximum amount of protein in grams the product can have.
   * @param {number} [minFat] The minimum amount of fat in grams the product must have.
   * @param {number} [maxFat] The maximum amount of fat in grams the product can have.
   * @param {boolean} [addProductInformation] If set to true, you get more information about the products returned.
   * @param {number} [offset] The number of results to skip (between 0 and 900).
   * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public searchGroceryProducts(
    query?: string,
    minCalories?: number,
    maxCalories?: number,
    minCarbs?: number,
    maxCarbs?: number,
    minProtein?: number,
    maxProtein?: number,
    minFat?: number,
    maxFat?: number,
    addProductInformation?: boolean,
    offset?: number,
    number?: number,
    options?: RawAxiosRequestConfig
  ) {
    return ProductsApiFp(this.configuration)
      .searchGroceryProducts(
        query,
        minCalories,
        maxCalories,
        minCarbs,
        maxCarbs,
        minProtein,
        maxProtein,
        minFat,
        maxFat,
        addProductInformation,
        offset,
        number,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get information about a packaged food using its UPC.
   * @summary Search Grocery Products by UPC
   * @param {number} upc The product\&#39;s UPC.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public searchGroceryProductsByUPC(
    upc: number,
    options?: RawAxiosRequestConfig
  ) {
    return ProductsApiFp(this.configuration)
      .searchGroceryProductsByUPC(upc, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Visualize a product\'s nutritional information as HTML including CSS.
   * @summary Product Nutrition by ID Widget
   * @param {number} id The item\&#39;s id.
   * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
   * @param {VisualizeProductNutritionByIDAcceptEnum} [accept] Accept header.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public visualizeProductNutritionByID(
    id: number,
    defaultCss?: boolean,
    accept?: VisualizeProductNutritionByIDAcceptEnum,
    options?: RawAxiosRequestConfig
  ) {
    return ProductsApiFp(this.configuration)
      .visualizeProductNutritionByID(id, defaultCss, accept, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const ClassifyGroceryProductLocaleEnum = {
  Us: "en_US",
  Gb: "en_GB",
} as const;
export type ClassifyGroceryProductLocaleEnum =
  (typeof ClassifyGroceryProductLocaleEnum)[keyof typeof ClassifyGroceryProductLocaleEnum];
/**
 * @export
 */
export const VisualizeProductNutritionByIDAcceptEnum = {
  ApplicationJson: "application/json",
  TextHtml: "text/html",
  Media: "media/_*",
} as const;
export type VisualizeProductNutritionByIDAcceptEnum =
  (typeof VisualizeProductNutritionByIDAcceptEnum)[keyof typeof VisualizeProductNutritionByIDAcceptEnum];

/**
 * RecipesApi - axios parameter creator
 * @export
 */
export const RecipesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Parse a recipe search query to find out its intention.
     * @summary Analyze a Recipe Search Query
     * @param {string} q The recipe search query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    analyzeARecipeSearchQuery: async (
      q: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'q' is not null or undefined
      assertParamExists("analyzeARecipeSearchQuery", "q", q);
      const localVarPath = `/recipes/queries/analyze`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (q !== undefined) {
        localVarQueryParameter["q"] = q;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint allows you to break down instructions into atomic steps. Furthermore, each step will contain the ingredients and equipment required. Additionally, all ingredients and equipment from the recipe\'s instructions will be extracted independently of the step they\'re used in.
     * @summary Analyze Recipe Instructions
     * @param {AnalyzeRecipeInstructionsContentTypeEnum} [contentType] The content type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    analyzeRecipeInstructions: async (
      contentType?: AnalyzeRecipeInstructionsContentTypeEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/recipes/analyzeInstructions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (contentType != null) {
        localVarHeaderParameter["Content-Type"] = String(contentType);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Autocomplete a partial input to suggest possible recipe names.
     * @summary Autocomplete Recipe Search
     * @param {string} [query] The (natural language) search query.
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autocompleteRecipeSearch: async (
      query?: string,
      number?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/recipes/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (query !== undefined) {
        localVarQueryParameter["query"] = query;
      }

      if (number !== undefined) {
        localVarQueryParameter["number"] = number;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Classify the recipe\'s cuisine.
     * @summary Classify Cuisine
     * @param {ClassifyCuisineContentTypeEnum} [contentType] The content type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    classifyCuisine: async (
      contentType?: ClassifyCuisineContentTypeEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/recipes/cuisine`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (contentType != null) {
        localVarHeaderParameter["Content-Type"] = String(contentType);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve the glycemic index for a list of ingredients and compute the individual and total glycemic load.
     * @summary Compute Glycemic Load
     * @param {ComputeGlycemicLoadRequest} computeGlycemicLoadRequest
     * @param {ComputeGlycemicLoadLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    computeGlycemicLoad: async (
      computeGlycemicLoadRequest: ComputeGlycemicLoadRequest,
      language?: ComputeGlycemicLoadLanguageEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'computeGlycemicLoadRequest' is not null or undefined
      assertParamExists(
        "computeGlycemicLoad",
        "computeGlycemicLoadRequest",
        computeGlycemicLoadRequest
      );
      const localVarPath = `/food/ingredients/glycemicLoad`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        computeGlycemicLoadRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Convert amounts like \"2 cups of flour to grams\".
     * @summary Convert Amounts
     * @param {string} ingredientName The ingredient which you want to convert.
     * @param {number} sourceAmount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;.
     * @param {string} sourceUnit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot;
     * @param {string} targetUnit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    convertAmounts: async (
      ingredientName: string,
      sourceAmount: number,
      sourceUnit: string,
      targetUnit: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'ingredientName' is not null or undefined
      assertParamExists("convertAmounts", "ingredientName", ingredientName);
      // verify required parameter 'sourceAmount' is not null or undefined
      assertParamExists("convertAmounts", "sourceAmount", sourceAmount);
      // verify required parameter 'sourceUnit' is not null or undefined
      assertParamExists("convertAmounts", "sourceUnit", sourceUnit);
      // verify required parameter 'targetUnit' is not null or undefined
      assertParamExists("convertAmounts", "targetUnit", targetUnit);
      const localVarPath = `/recipes/convert`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (ingredientName !== undefined) {
        localVarQueryParameter["ingredientName"] = ingredientName;
      }

      if (sourceAmount !== undefined) {
        localVarQueryParameter["sourceAmount"] = sourceAmount;
      }

      if (sourceUnit !== undefined) {
        localVarQueryParameter["sourceUnit"] = sourceUnit;
      }

      if (targetUnit !== undefined) {
        localVarQueryParameter["targetUnit"] = targetUnit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Generate a recipe card for a recipe.
     * @summary Create Recipe Card
     * @param {CreateRecipeCardContentTypeEnum} [contentType] The content type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRecipeCard: async (
      contentType?: CreateRecipeCardContentTypeEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/recipes/visualizeRecipe`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (contentType != null) {
        localVarHeaderParameter["Content-Type"] = String(contentType);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Visualize a recipe\'s equipment list as an image.
     * @summary Equipment by ID Image
     * @param {number} id The recipe id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    equipmentByIDImage: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("equipmentByIDImage", "id", id);
      const localVarPath = `/recipes/{id}/equipmentWidget.png`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint lets you extract recipe data such as title, ingredients, and instructions from any properly formatted Website.
     * @summary Extract Recipe from Website
     * @param {string} url The URL of the recipe page.
     * @param {boolean} [forceExtraction] If true, the extraction will be triggered whether we already know the recipe or not. Use this only if information is missing as this operation is slower.
     * @param {boolean} [analyze] If true, the recipe will be analyzed and classified resolving in more data such as cuisines, dish types, and more.
     * @param {boolean} [includeNutrition] Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings.
     * @param {boolean} [includeTaste] Whether taste data should be added to correctly parsed ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    extractRecipeFromWebsite: async (
      url: string,
      forceExtraction?: boolean,
      analyze?: boolean,
      includeNutrition?: boolean,
      includeTaste?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'url' is not null or undefined
      assertParamExists("extractRecipeFromWebsite", "url", url);
      const localVarPath = `/recipes/extract`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (url !== undefined) {
        localVarQueryParameter["url"] = url;
      }

      if (forceExtraction !== undefined) {
        localVarQueryParameter["forceExtraction"] = forceExtraction;
      }

      if (analyze !== undefined) {
        localVarQueryParameter["analyze"] = analyze;
      }

      if (includeNutrition !== undefined) {
        localVarQueryParameter["includeNutrition"] = includeNutrition;
      }

      if (includeTaste !== undefined) {
        localVarQueryParameter["includeTaste"] = includeTaste;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get an analyzed breakdown of a recipe\'s instructions. Each step is enriched with the ingredients and equipment required.
     * @summary Get Analyzed Recipe Instructions
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [stepBreakdown] Whether to break down the recipe steps even more.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalyzedRecipeInstructions: async (
      id: number,
      stepBreakdown?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getAnalyzedRecipeInstructions", "id", id);
      const localVarPath = `/recipes/{id}/analyzedInstructions`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (stepBreakdown !== undefined) {
        localVarQueryParameter["stepBreakdown"] = stepBreakdown;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Find random (popular) recipes. If you need to filter recipes by diet, nutrition etc. you might want to consider using the complex recipe search endpoint and set the sort request parameter to random.
     * @summary Get Random Recipes
     * @param {boolean} [limitLicense] Whether the recipes should have an open license that allows display with proper attribution.
     * @param {string} [tags] The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have.
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRandomRecipes: async (
      limitLicense?: boolean,
      tags?: string,
      number?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/recipes/random`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (limitLicense !== undefined) {
        localVarQueryParameter["limitLicense"] = limitLicense;
      }

      if (tags !== undefined) {
        localVarQueryParameter["tags"] = tags;
      }

      if (number !== undefined) {
        localVarQueryParameter["number"] = number;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a recipe\'s equipment list.
     * @summary Equipment by ID
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecipeEquipmentByID: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getRecipeEquipmentByID", "id", id);
      const localVarPath = `/recipes/{id}/equipmentWidget.json`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Use a recipe id to get full information about a recipe, such as ingredients, nutrition, diet and allergen information, etc.
     * @summary Get Recipe Information
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [includeNutrition] Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecipeInformation: async (
      id: number,
      includeNutrition?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getRecipeInformation", "id", id);
      const localVarPath = `/recipes/{id}/information`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (includeNutrition !== undefined) {
        localVarQueryParameter["includeNutrition"] = includeNutrition;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information about multiple recipes at once. This is equivalent to calling the Get Recipe Information endpoint multiple times, but faster.
     * @summary Get Recipe Information Bulk
     * @param {string} ids A comma-separated list of recipe ids.
     * @param {boolean} [includeNutrition] Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecipeInformationBulk: async (
      ids: string,
      includeNutrition?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'ids' is not null or undefined
      assertParamExists("getRecipeInformationBulk", "ids", ids);
      const localVarPath = `/recipes/informationBulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (ids !== undefined) {
        localVarQueryParameter["ids"] = ids;
      }

      if (includeNutrition !== undefined) {
        localVarQueryParameter["includeNutrition"] = includeNutrition;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a recipe\'s ingredient list.
     * @summary Ingredients by ID
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecipeIngredientsByID: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getRecipeIngredientsByID", "id", id);
      const localVarPath = `/recipes/{id}/ingredientWidget.json`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a recipe\'s nutrition data.
     * @summary Nutrition by ID
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecipeNutritionWidgetByID: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getRecipeNutritionWidgetByID", "id", id);
      const localVarPath = `/recipes/{id}/nutritionWidget.json`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a recipe\'s price breakdown data.
     * @summary Price Breakdown by ID
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecipePriceBreakdownByID: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getRecipePriceBreakdownByID", "id", id);
      const localVarPath = `/recipes/{id}/priceBreakdownWidget.json`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a recipe\'s taste. The tastes supported are sweet, salty, sour, bitter, savory, and fatty.
     * @summary Taste by ID
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [normalize] Normalize to the strongest taste.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecipeTasteByID: async (
      id: number,
      normalize?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getRecipeTasteByID", "id", id);
      const localVarPath = `/recipes/{id}/tasteWidget.json`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (normalize !== undefined) {
        localVarQueryParameter["normalize"] = normalize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Find recipes which are similar to the given one.
     * @summary Get Similar Recipes
     * @param {number} id The item\&#39;s id.
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {boolean} [limitLicense] Whether the recipes should have an open license that allows display with proper attribution.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSimilarRecipes: async (
      id: number,
      number?: number,
      limitLicense?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getSimilarRecipes", "id", id);
      const localVarPath = `/recipes/{id}/similar`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (number !== undefined) {
        localVarQueryParameter["number"] = number;
      }

      if (limitLicense !== undefined) {
        localVarQueryParameter["limitLicense"] = limitLicense;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Estimate the macronutrients of a dish based on its title.
     * @summary Guess Nutrition by Dish Name
     * @param {string} title The title of the dish.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    guessNutritionByDishName: async (
      title: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'title' is not null or undefined
      assertParamExists("guessNutritionByDishName", "title", title);
      const localVarPath = `/recipes/guessNutrition`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (title !== undefined) {
        localVarQueryParameter["title"] = title;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Visualize a recipe\'s ingredient list.
     * @summary Ingredients by ID Image
     * @param {number} id The recipe id.
     * @param {IngredientsByIDImageMeasureEnum} [measure] Whether the the measures should be \&#39;us\&#39; or \&#39;metric\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ingredientsByIDImage: async (
      id: number,
      measure?: IngredientsByIDImageMeasureEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("ingredientsByIDImage", "id", id);
      const localVarPath = `/recipes/{id}/ingredientWidget.png`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (measure !== undefined) {
        localVarQueryParameter["measure"] = measure;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Extract an ingredient from plain text.
     * @summary Parse Ingredients
     * @param {ParseIngredientsContentTypeEnum} [contentType] The content type.
     * @param {ParseIngredientsLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    parseIngredients: async (
      contentType?: ParseIngredientsContentTypeEnum,
      language?: ParseIngredientsLanguageEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/recipes/parseIngredients`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (contentType != null) {
        localVarHeaderParameter["Content-Type"] = String(contentType);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Visualize a recipe\'s price breakdown.
     * @summary Price Breakdown by ID Image
     * @param {number} id The recipe id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    priceBreakdownByIDImage: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("priceBreakdownByIDImage", "id", id);
      const localVarPath = `/recipes/{id}/priceBreakdownWidget.png`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Answer a nutrition related natural language question.
     * @summary Quick Answer
     * @param {string} q The nutrition related question.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    quickAnswer: async (
      q: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'q' is not null or undefined
      assertParamExists("quickAnswer", "q", q);
      const localVarPath = `/recipes/quickAnswer`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (q !== undefined) {
        localVarQueryParameter["q"] = q;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Visualize a recipe\'s nutritional information as an image.
     * @summary Recipe Nutrition by ID Image
     * @param {number} id The recipe id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recipeNutritionByIDImage: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("recipeNutritionByIDImage", "id", id);
      const localVarPath = `/recipes/{id}/nutritionWidget.png`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a recipe\'s nutrition label as an image.
     * @summary Recipe Nutrition Label Image
     * @param {number} id The recipe id.
     * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
     * @param {boolean} [showZeroValues] Whether to show zero values.
     * @param {boolean} [showIngredients] Whether to show a list of ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recipeNutritionLabelImage: async (
      id: number,
      showOptionalNutrients?: boolean,
      showZeroValues?: boolean,
      showIngredients?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("recipeNutritionLabelImage", "id", id);
      const localVarPath = `/recipes/{id}/nutritionLabel.png`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (showOptionalNutrients !== undefined) {
        localVarQueryParameter["showOptionalNutrients"] = showOptionalNutrients;
      }

      if (showZeroValues !== undefined) {
        localVarQueryParameter["showZeroValues"] = showZeroValues;
      }

      if (showIngredients !== undefined) {
        localVarQueryParameter["showIngredients"] = showIngredients;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a recipe\'s nutrition label as an HTML widget.
     * @summary Recipe Nutrition Label Widget
     * @param {number} id The recipe id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
     * @param {boolean} [showZeroValues] Whether to show zero values.
     * @param {boolean} [showIngredients] Whether to show a list of ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recipeNutritionLabelWidget: async (
      id: number,
      defaultCss?: boolean,
      showOptionalNutrients?: boolean,
      showZeroValues?: boolean,
      showIngredients?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("recipeNutritionLabelWidget", "id", id);
      const localVarPath = `/recipes/{id}/nutritionLabel`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (defaultCss !== undefined) {
        localVarQueryParameter["defaultCss"] = defaultCss;
      }

      if (showOptionalNutrients !== undefined) {
        localVarQueryParameter["showOptionalNutrients"] = showOptionalNutrients;
      }

      if (showZeroValues !== undefined) {
        localVarQueryParameter["showZeroValues"] = showZeroValues;
      }

      if (showIngredients !== undefined) {
        localVarQueryParameter["showIngredients"] = showIngredients;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a recipe\'s taste as an image. The tastes supported are sweet, salty, sour, bitter, savory, and fatty.
     * @summary Recipe Taste by ID Image
     * @param {number} id The recipe id.
     * @param {boolean} [normalize] Normalize to the strongest taste.
     * @param {string} [rgb] Red, green, blue values for the chart color.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recipeTasteByIDImage: async (
      id: number,
      normalize?: boolean,
      rgb?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("recipeTasteByIDImage", "id", id);
      const localVarPath = `/recipes/{id}/tasteWidget.png`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (normalize !== undefined) {
        localVarQueryParameter["normalize"] = normalize;
      }

      if (rgb !== undefined) {
        localVarQueryParameter["rgb"] = rgb;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Search through hundreds of thousands of recipes using advanced filtering and ranking. NOTE: This method combines searching by query, by ingredients, and by nutrients into one endpoint.
     * @summary Search Recipes
     * @param {string} [query] The (natural language) search query.
     * @param {string} [cuisine] The cuisine(s) of the recipes. One or more, comma separated (will be interpreted as \&#39;OR\&#39;). See a full list of supported cuisines.
     * @param {string} [excludeCuisine] The cuisine(s) the recipes must not match. One or more, comma separated (will be interpreted as \&#39;AND\&#39;). See a full list of supported cuisines.
     * @param {string} [diet] The diet for which the recipes must be suitable. See a full list of supported diets.
     * @param {string} [intolerances] A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.
     * @param {string} [equipment] The equipment required. Multiple values will be interpreted as \&#39;or\&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;.
     * @param {string} [includeIngredients] A comma-separated list of ingredients that should/must be used in the recipes.
     * @param {string} [excludeIngredients] A comma-separated list of ingredients or ingredient types that the recipes must not contain.
     * @param {string} [type] The type of recipe. See a full list of supported meal types.
     * @param {boolean} [instructionsRequired] Whether the recipes must have instructions.
     * @param {boolean} [fillIngredients] Add information about the ingredients and whether they are used or missing in relation to the query.
     * @param {boolean} [addRecipeInformation] If set to true, you get more information about the recipes returned.
     * @param {boolean} [addRecipeNutrition] If set to true, you get nutritional information about each recipes returned.
     * @param {string} [author] The username of the recipe author.
     * @param {string} [tags] The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have.
     * @param {number} [recipeBoxId] The id of the recipe box to which the search should be limited to.
     * @param {string} [titleMatch] Enter text that must be found in the title of the recipes.
     * @param {number} [maxReadyTime] The maximum time in minutes it should take to prepare and cook the recipe.
     * @param {boolean} [ignorePantry] Whether to ignore typical pantry items, such as water, salt, flour, etc.
     * @param {string} [sort] The strategy to sort recipes by. See a full list of supported sorting options.
     * @param {string} [sortDirection] The direction in which to sort. Must be either \&#39;asc\&#39; (ascending) or \&#39;desc\&#39; (descending).
     * @param {number} [minCarbs] The minimum amount of carbohydrates in grams the recipe must have.
     * @param {number} [maxCarbs] The maximum amount of carbohydrates in grams the recipe can have.
     * @param {number} [minProtein] The minimum amount of protein in grams the recipe must have.
     * @param {number} [maxProtein] The maximum amount of protein in grams the recipe can have.
     * @param {number} [minCalories] The minimum amount of calories the recipe must have.
     * @param {number} [maxCalories] The maximum amount of calories the recipe can have.
     * @param {number} [minFat] The minimum amount of fat in grams the recipe must have.
     * @param {number} [maxFat] The maximum amount of fat in grams the recipe can have.
     * @param {number} [minAlcohol] The minimum amount of alcohol in grams the recipe must have.
     * @param {number} [maxAlcohol] The maximum amount of alcohol in grams the recipe can have.
     * @param {number} [minCaffeine] The minimum amount of caffeine in milligrams the recipe must have.
     * @param {number} [maxCaffeine] The maximum amount of caffeine in milligrams the recipe can have.
     * @param {number} [minCopper] The minimum amount of copper in milligrams the recipe must have.
     * @param {number} [maxCopper] The maximum amount of copper in milligrams the recipe can have.
     * @param {number} [minCalcium] The minimum amount of calcium in milligrams the recipe must have.
     * @param {number} [maxCalcium] The maximum amount of calcium in milligrams the recipe can have.
     * @param {number} [minCholine] The minimum amount of choline in milligrams the recipe must have.
     * @param {number} [maxCholine] The maximum amount of choline in milligrams the recipe can have.
     * @param {number} [minCholesterol] The minimum amount of cholesterol in milligrams the recipe must have.
     * @param {number} [maxCholesterol] The maximum amount of cholesterol in milligrams the recipe can have.
     * @param {number} [minFluoride] The minimum amount of fluoride in milligrams the recipe must have.
     * @param {number} [maxFluoride] The maximum amount of fluoride in milligrams the recipe can have.
     * @param {number} [minSaturatedFat] The minimum amount of saturated fat in grams the recipe must have.
     * @param {number} [maxSaturatedFat] The maximum amount of saturated fat in grams the recipe can have.
     * @param {number} [minVitaminA] The minimum amount of Vitamin A in IU the recipe must have.
     * @param {number} [maxVitaminA] The maximum amount of Vitamin A in IU the recipe can have.
     * @param {number} [minVitaminC] The minimum amount of Vitamin C milligrams the recipe must have.
     * @param {number} [maxVitaminC] The maximum amount of Vitamin C in milligrams the recipe can have.
     * @param {number} [minVitaminD] The minimum amount of Vitamin D in micrograms the recipe must have.
     * @param {number} [maxVitaminD] The maximum amount of Vitamin D in micrograms the recipe can have.
     * @param {number} [minVitaminE] The minimum amount of Vitamin E in milligrams the recipe must have.
     * @param {number} [maxVitaminE] The maximum amount of Vitamin E in milligrams the recipe can have.
     * @param {number} [minVitaminK] The minimum amount of Vitamin K in micrograms the recipe must have.
     * @param {number} [maxVitaminK] The maximum amount of Vitamin K in micrograms the recipe can have.
     * @param {number} [minVitaminB1] The minimum amount of Vitamin B1 in milligrams the recipe must have.
     * @param {number} [maxVitaminB1] The maximum amount of Vitamin B1 in milligrams the recipe can have.
     * @param {number} [minVitaminB2] The minimum amount of Vitamin B2 in milligrams the recipe must have.
     * @param {number} [maxVitaminB2] The maximum amount of Vitamin B2 in milligrams the recipe can have.
     * @param {number} [minVitaminB5] The minimum amount of Vitamin B5 in milligrams the recipe must have.
     * @param {number} [maxVitaminB5] The maximum amount of Vitamin B5 in milligrams the recipe can have.
     * @param {number} [minVitaminB3] The minimum amount of Vitamin B3 in milligrams the recipe must have.
     * @param {number} [maxVitaminB3] The maximum amount of Vitamin B3 in milligrams the recipe can have.
     * @param {number} [minVitaminB6] The minimum amount of Vitamin B6 in milligrams the recipe must have.
     * @param {number} [maxVitaminB6] The maximum amount of Vitamin B6 in milligrams the recipe can have.
     * @param {number} [minVitaminB12] The minimum amount of Vitamin B12 in micrograms the recipe must have.
     * @param {number} [maxVitaminB12] The maximum amount of Vitamin B12 in micrograms the recipe can have.
     * @param {number} [minFiber] The minimum amount of fiber in grams the recipe must have.
     * @param {number} [maxFiber] The maximum amount of fiber in grams the recipe can have.
     * @param {number} [minFolate] The minimum amount of folate in micrograms the recipe must have.
     * @param {number} [maxFolate] The maximum amount of folate in micrograms the recipe can have.
     * @param {number} [minFolicAcid] The minimum amount of folic acid in micrograms the recipe must have.
     * @param {number} [maxFolicAcid] The maximum amount of folic acid in micrograms the recipe can have.
     * @param {number} [minIodine] The minimum amount of iodine in micrograms the recipe must have.
     * @param {number} [maxIodine] The maximum amount of iodine in micrograms the recipe can have.
     * @param {number} [minIron] The minimum amount of iron in milligrams the recipe must have.
     * @param {number} [maxIron] The maximum amount of iron in milligrams the recipe can have.
     * @param {number} [minMagnesium] The minimum amount of magnesium in milligrams the recipe must have.
     * @param {number} [maxMagnesium] The maximum amount of magnesium in milligrams the recipe can have.
     * @param {number} [minManganese] The minimum amount of manganese in milligrams the recipe must have.
     * @param {number} [maxManganese] The maximum amount of manganese in milligrams the recipe can have.
     * @param {number} [minPhosphorus] The minimum amount of phosphorus in milligrams the recipe must have.
     * @param {number} [maxPhosphorus] The maximum amount of phosphorus in milligrams the recipe can have.
     * @param {number} [minPotassium] The minimum amount of potassium in milligrams the recipe must have.
     * @param {number} [maxPotassium] The maximum amount of potassium in milligrams the recipe can have.
     * @param {number} [minSelenium] The minimum amount of selenium in micrograms the recipe must have.
     * @param {number} [maxSelenium] The maximum amount of selenium in micrograms the recipe can have.
     * @param {number} [minSodium] The minimum amount of sodium in milligrams the recipe must have.
     * @param {number} [maxSodium] The maximum amount of sodium in milligrams the recipe can have.
     * @param {number} [minSugar] The minimum amount of sugar in grams the recipe must have.
     * @param {number} [maxSugar] The maximum amount of sugar in grams the recipe can have.
     * @param {number} [minZinc] The minimum amount of zinc in milligrams the recipe must have.
     * @param {number} [maxZinc] The maximum amount of zinc in milligrams the recipe can have.
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {boolean} [limitLicense] Whether the recipes should have an open license that allows display with proper attribution.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchRecipes: async (
      query?: string,
      cuisine?: string,
      excludeCuisine?: string,
      diet?: string,
      intolerances?: string,
      equipment?: string,
      includeIngredients?: string,
      excludeIngredients?: string,
      type?: string,
      instructionsRequired?: boolean,
      fillIngredients?: boolean,
      addRecipeInformation?: boolean,
      addRecipeNutrition?: boolean,
      author?: string,
      tags?: string,
      recipeBoxId?: number,
      titleMatch?: string,
      maxReadyTime?: number,
      ignorePantry?: boolean,
      sort?: string,
      sortDirection?: string,
      minCarbs?: number,
      maxCarbs?: number,
      minProtein?: number,
      maxProtein?: number,
      minCalories?: number,
      maxCalories?: number,
      minFat?: number,
      maxFat?: number,
      minAlcohol?: number,
      maxAlcohol?: number,
      minCaffeine?: number,
      maxCaffeine?: number,
      minCopper?: number,
      maxCopper?: number,
      minCalcium?: number,
      maxCalcium?: number,
      minCholine?: number,
      maxCholine?: number,
      minCholesterol?: number,
      maxCholesterol?: number,
      minFluoride?: number,
      maxFluoride?: number,
      minSaturatedFat?: number,
      maxSaturatedFat?: number,
      minVitaminA?: number,
      maxVitaminA?: number,
      minVitaminC?: number,
      maxVitaminC?: number,
      minVitaminD?: number,
      maxVitaminD?: number,
      minVitaminE?: number,
      maxVitaminE?: number,
      minVitaminK?: number,
      maxVitaminK?: number,
      minVitaminB1?: number,
      maxVitaminB1?: number,
      minVitaminB2?: number,
      maxVitaminB2?: number,
      minVitaminB5?: number,
      maxVitaminB5?: number,
      minVitaminB3?: number,
      maxVitaminB3?: number,
      minVitaminB6?: number,
      maxVitaminB6?: number,
      minVitaminB12?: number,
      maxVitaminB12?: number,
      minFiber?: number,
      maxFiber?: number,
      minFolate?: number,
      maxFolate?: number,
      minFolicAcid?: number,
      maxFolicAcid?: number,
      minIodine?: number,
      maxIodine?: number,
      minIron?: number,
      maxIron?: number,
      minMagnesium?: number,
      maxMagnesium?: number,
      minManganese?: number,
      maxManganese?: number,
      minPhosphorus?: number,
      maxPhosphorus?: number,
      minPotassium?: number,
      maxPotassium?: number,
      minSelenium?: number,
      maxSelenium?: number,
      minSodium?: number,
      maxSodium?: number,
      minSugar?: number,
      maxSugar?: number,
      minZinc?: number,
      maxZinc?: number,
      offset?: number,
      number?: number,
      limitLicense?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/recipes/complexSearch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (query !== undefined) {
        localVarQueryParameter["query"] = query;
      }

      if (cuisine !== undefined) {
        localVarQueryParameter["cuisine"] = cuisine;
      }

      if (excludeCuisine !== undefined) {
        localVarQueryParameter["excludeCuisine"] = excludeCuisine;
      }

      if (diet !== undefined) {
        localVarQueryParameter["diet"] = diet;
      }

      if (intolerances !== undefined) {
        localVarQueryParameter["intolerances"] = intolerances;
      }

      if (equipment !== undefined) {
        localVarQueryParameter["equipment"] = equipment;
      }

      if (includeIngredients !== undefined) {
        localVarQueryParameter["includeIngredients"] = includeIngredients;
      }

      if (excludeIngredients !== undefined) {
        localVarQueryParameter["excludeIngredients"] = excludeIngredients;
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type;
      }

      if (instructionsRequired !== undefined) {
        localVarQueryParameter["instructionsRequired"] = instructionsRequired;
      }

      if (fillIngredients !== undefined) {
        localVarQueryParameter["fillIngredients"] = fillIngredients;
      }

      if (addRecipeInformation !== undefined) {
        localVarQueryParameter["addRecipeInformation"] = addRecipeInformation;
      }

      if (addRecipeNutrition !== undefined) {
        localVarQueryParameter["addRecipeNutrition"] = addRecipeNutrition;
      }

      if (author !== undefined) {
        localVarQueryParameter["author"] = author;
      }

      if (tags !== undefined) {
        localVarQueryParameter["tags"] = tags;
      }

      if (recipeBoxId !== undefined) {
        localVarQueryParameter["recipeBoxId"] = recipeBoxId;
      }

      if (titleMatch !== undefined) {
        localVarQueryParameter["titleMatch"] = titleMatch;
      }

      if (maxReadyTime !== undefined) {
        localVarQueryParameter["maxReadyTime"] = maxReadyTime;
      }

      if (ignorePantry !== undefined) {
        localVarQueryParameter["ignorePantry"] = ignorePantry;
      }

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort;
      }

      if (sortDirection !== undefined) {
        localVarQueryParameter["sortDirection"] = sortDirection;
      }

      if (minCarbs !== undefined) {
        localVarQueryParameter["minCarbs"] = minCarbs;
      }

      if (maxCarbs !== undefined) {
        localVarQueryParameter["maxCarbs"] = maxCarbs;
      }

      if (minProtein !== undefined) {
        localVarQueryParameter["minProtein"] = minProtein;
      }

      if (maxProtein !== undefined) {
        localVarQueryParameter["maxProtein"] = maxProtein;
      }

      if (minCalories !== undefined) {
        localVarQueryParameter["minCalories"] = minCalories;
      }

      if (maxCalories !== undefined) {
        localVarQueryParameter["maxCalories"] = maxCalories;
      }

      if (minFat !== undefined) {
        localVarQueryParameter["minFat"] = minFat;
      }

      if (maxFat !== undefined) {
        localVarQueryParameter["maxFat"] = maxFat;
      }

      if (minAlcohol !== undefined) {
        localVarQueryParameter["minAlcohol"] = minAlcohol;
      }

      if (maxAlcohol !== undefined) {
        localVarQueryParameter["maxAlcohol"] = maxAlcohol;
      }

      if (minCaffeine !== undefined) {
        localVarQueryParameter["minCaffeine"] = minCaffeine;
      }

      if (maxCaffeine !== undefined) {
        localVarQueryParameter["maxCaffeine"] = maxCaffeine;
      }

      if (minCopper !== undefined) {
        localVarQueryParameter["minCopper"] = minCopper;
      }

      if (maxCopper !== undefined) {
        localVarQueryParameter["maxCopper"] = maxCopper;
      }

      if (minCalcium !== undefined) {
        localVarQueryParameter["minCalcium"] = minCalcium;
      }

      if (maxCalcium !== undefined) {
        localVarQueryParameter["maxCalcium"] = maxCalcium;
      }

      if (minCholine !== undefined) {
        localVarQueryParameter["minCholine"] = minCholine;
      }

      if (maxCholine !== undefined) {
        localVarQueryParameter["maxCholine"] = maxCholine;
      }

      if (minCholesterol !== undefined) {
        localVarQueryParameter["minCholesterol"] = minCholesterol;
      }

      if (maxCholesterol !== undefined) {
        localVarQueryParameter["maxCholesterol"] = maxCholesterol;
      }

      if (minFluoride !== undefined) {
        localVarQueryParameter["minFluoride"] = minFluoride;
      }

      if (maxFluoride !== undefined) {
        localVarQueryParameter["maxFluoride"] = maxFluoride;
      }

      if (minSaturatedFat !== undefined) {
        localVarQueryParameter["minSaturatedFat"] = minSaturatedFat;
      }

      if (maxSaturatedFat !== undefined) {
        localVarQueryParameter["maxSaturatedFat"] = maxSaturatedFat;
      }

      if (minVitaminA !== undefined) {
        localVarQueryParameter["minVitaminA"] = minVitaminA;
      }

      if (maxVitaminA !== undefined) {
        localVarQueryParameter["maxVitaminA"] = maxVitaminA;
      }

      if (minVitaminC !== undefined) {
        localVarQueryParameter["minVitaminC"] = minVitaminC;
      }

      if (maxVitaminC !== undefined) {
        localVarQueryParameter["maxVitaminC"] = maxVitaminC;
      }

      if (minVitaminD !== undefined) {
        localVarQueryParameter["minVitaminD"] = minVitaminD;
      }

      if (maxVitaminD !== undefined) {
        localVarQueryParameter["maxVitaminD"] = maxVitaminD;
      }

      if (minVitaminE !== undefined) {
        localVarQueryParameter["minVitaminE"] = minVitaminE;
      }

      if (maxVitaminE !== undefined) {
        localVarQueryParameter["maxVitaminE"] = maxVitaminE;
      }

      if (minVitaminK !== undefined) {
        localVarQueryParameter["minVitaminK"] = minVitaminK;
      }

      if (maxVitaminK !== undefined) {
        localVarQueryParameter["maxVitaminK"] = maxVitaminK;
      }

      if (minVitaminB1 !== undefined) {
        localVarQueryParameter["minVitaminB1"] = minVitaminB1;
      }

      if (maxVitaminB1 !== undefined) {
        localVarQueryParameter["maxVitaminB1"] = maxVitaminB1;
      }

      if (minVitaminB2 !== undefined) {
        localVarQueryParameter["minVitaminB2"] = minVitaminB2;
      }

      if (maxVitaminB2 !== undefined) {
        localVarQueryParameter["maxVitaminB2"] = maxVitaminB2;
      }

      if (minVitaminB5 !== undefined) {
        localVarQueryParameter["minVitaminB5"] = minVitaminB5;
      }

      if (maxVitaminB5 !== undefined) {
        localVarQueryParameter["maxVitaminB5"] = maxVitaminB5;
      }

      if (minVitaminB3 !== undefined) {
        localVarQueryParameter["minVitaminB3"] = minVitaminB3;
      }

      if (maxVitaminB3 !== undefined) {
        localVarQueryParameter["maxVitaminB3"] = maxVitaminB3;
      }

      if (minVitaminB6 !== undefined) {
        localVarQueryParameter["minVitaminB6"] = minVitaminB6;
      }

      if (maxVitaminB6 !== undefined) {
        localVarQueryParameter["maxVitaminB6"] = maxVitaminB6;
      }

      if (minVitaminB12 !== undefined) {
        localVarQueryParameter["minVitaminB12"] = minVitaminB12;
      }

      if (maxVitaminB12 !== undefined) {
        localVarQueryParameter["maxVitaminB12"] = maxVitaminB12;
      }

      if (minFiber !== undefined) {
        localVarQueryParameter["minFiber"] = minFiber;
      }

      if (maxFiber !== undefined) {
        localVarQueryParameter["maxFiber"] = maxFiber;
      }

      if (minFolate !== undefined) {
        localVarQueryParameter["minFolate"] = minFolate;
      }

      if (maxFolate !== undefined) {
        localVarQueryParameter["maxFolate"] = maxFolate;
      }

      if (minFolicAcid !== undefined) {
        localVarQueryParameter["minFolicAcid"] = minFolicAcid;
      }

      if (maxFolicAcid !== undefined) {
        localVarQueryParameter["maxFolicAcid"] = maxFolicAcid;
      }

      if (minIodine !== undefined) {
        localVarQueryParameter["minIodine"] = minIodine;
      }

      if (maxIodine !== undefined) {
        localVarQueryParameter["maxIodine"] = maxIodine;
      }

      if (minIron !== undefined) {
        localVarQueryParameter["minIron"] = minIron;
      }

      if (maxIron !== undefined) {
        localVarQueryParameter["maxIron"] = maxIron;
      }

      if (minMagnesium !== undefined) {
        localVarQueryParameter["minMagnesium"] = minMagnesium;
      }

      if (maxMagnesium !== undefined) {
        localVarQueryParameter["maxMagnesium"] = maxMagnesium;
      }

      if (minManganese !== undefined) {
        localVarQueryParameter["minManganese"] = minManganese;
      }

      if (maxManganese !== undefined) {
        localVarQueryParameter["maxManganese"] = maxManganese;
      }

      if (minPhosphorus !== undefined) {
        localVarQueryParameter["minPhosphorus"] = minPhosphorus;
      }

      if (maxPhosphorus !== undefined) {
        localVarQueryParameter["maxPhosphorus"] = maxPhosphorus;
      }

      if (minPotassium !== undefined) {
        localVarQueryParameter["minPotassium"] = minPotassium;
      }

      if (maxPotassium !== undefined) {
        localVarQueryParameter["maxPotassium"] = maxPotassium;
      }

      if (minSelenium !== undefined) {
        localVarQueryParameter["minSelenium"] = minSelenium;
      }

      if (maxSelenium !== undefined) {
        localVarQueryParameter["maxSelenium"] = maxSelenium;
      }

      if (minSodium !== undefined) {
        localVarQueryParameter["minSodium"] = minSodium;
      }

      if (maxSodium !== undefined) {
        localVarQueryParameter["maxSodium"] = maxSodium;
      }

      if (minSugar !== undefined) {
        localVarQueryParameter["minSugar"] = minSugar;
      }

      if (maxSugar !== undefined) {
        localVarQueryParameter["maxSugar"] = maxSugar;
      }

      if (minZinc !== undefined) {
        localVarQueryParameter["minZinc"] = minZinc;
      }

      if (maxZinc !== undefined) {
        localVarQueryParameter["maxZinc"] = maxZinc;
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
      }

      if (number !== undefined) {
        localVarQueryParameter["number"] = number;
      }

      if (limitLicense !== undefined) {
        localVarQueryParameter["limitLicense"] = limitLicense;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Ever wondered what recipes you can cook with the ingredients you have in your fridge or pantry? This endpoint lets you find recipes that either maximize the usage of ingredients you have at hand (pre shopping) or minimize the ingredients that you don\'t currently have (post shopping).
     * @summary Search Recipes by Ingredients
     * @param {string} [ingredients] A comma-separated list of ingredients that the recipes should contain.
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {boolean} [limitLicense] Whether the recipes should have an open license that allows display with proper attribution.
     * @param {number} [ranking] Whether to maximize used ingredients (1) or minimize missing ingredients (2) first.
     * @param {boolean} [ignorePantry] Whether to ignore typical pantry items, such as water, salt, flour, etc.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchRecipesByIngredients: async (
      ingredients?: string,
      number?: number,
      limitLicense?: boolean,
      ranking?: number,
      ignorePantry?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/recipes/findByIngredients`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (ingredients !== undefined) {
        localVarQueryParameter["ingredients"] = ingredients;
      }

      if (number !== undefined) {
        localVarQueryParameter["number"] = number;
      }

      if (limitLicense !== undefined) {
        localVarQueryParameter["limitLicense"] = limitLicense;
      }

      if (ranking !== undefined) {
        localVarQueryParameter["ranking"] = ranking;
      }

      if (ignorePantry !== undefined) {
        localVarQueryParameter["ignorePantry"] = ignorePantry;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Find a set of recipes that adhere to the given nutritional limits. You may set limits for macronutrients (calories, protein, fat, and carbohydrate) and/or many micronutrients.
     * @summary Search Recipes by Nutrients
     * @param {number} [minCarbs] The minimum amount of carbohydrates in grams the recipe must have.
     * @param {number} [maxCarbs] The maximum amount of carbohydrates in grams the recipe can have.
     * @param {number} [minProtein] The minimum amount of protein in grams the recipe must have.
     * @param {number} [maxProtein] The maximum amount of protein in grams the recipe can have.
     * @param {number} [minCalories] The minimum amount of calories the recipe must have.
     * @param {number} [maxCalories] The maximum amount of calories the recipe can have.
     * @param {number} [minFat] The minimum amount of fat in grams the recipe must have.
     * @param {number} [maxFat] The maximum amount of fat in grams the recipe can have.
     * @param {number} [minAlcohol] The minimum amount of alcohol in grams the recipe must have.
     * @param {number} [maxAlcohol] The maximum amount of alcohol in grams the recipe can have.
     * @param {number} [minCaffeine] The minimum amount of caffeine in milligrams the recipe must have.
     * @param {number} [maxCaffeine] The maximum amount of caffeine in milligrams the recipe can have.
     * @param {number} [minCopper] The minimum amount of copper in milligrams the recipe must have.
     * @param {number} [maxCopper] The maximum amount of copper in milligrams the recipe can have.
     * @param {number} [minCalcium] The minimum amount of calcium in milligrams the recipe must have.
     * @param {number} [maxCalcium] The maximum amount of calcium in milligrams the recipe can have.
     * @param {number} [minCholine] The minimum amount of choline in milligrams the recipe must have.
     * @param {number} [maxCholine] The maximum amount of choline in milligrams the recipe can have.
     * @param {number} [minCholesterol] The minimum amount of cholesterol in milligrams the recipe must have.
     * @param {number} [maxCholesterol] The maximum amount of cholesterol in milligrams the recipe can have.
     * @param {number} [minFluoride] The minimum amount of fluoride in milligrams the recipe must have.
     * @param {number} [maxFluoride] The maximum amount of fluoride in milligrams the recipe can have.
     * @param {number} [minSaturatedFat] The minimum amount of saturated fat in grams the recipe must have.
     * @param {number} [maxSaturatedFat] The maximum amount of saturated fat in grams the recipe can have.
     * @param {number} [minVitaminA] The minimum amount of Vitamin A in IU the recipe must have.
     * @param {number} [maxVitaminA] The maximum amount of Vitamin A in IU the recipe can have.
     * @param {number} [minVitaminC] The minimum amount of Vitamin C in milligrams the recipe must have.
     * @param {number} [maxVitaminC] The maximum amount of Vitamin C in milligrams the recipe can have.
     * @param {number} [minVitaminD] The minimum amount of Vitamin D in micrograms the recipe must have.
     * @param {number} [maxVitaminD] The maximum amount of Vitamin D in micrograms the recipe can have.
     * @param {number} [minVitaminE] The minimum amount of Vitamin E in milligrams the recipe must have.
     * @param {number} [maxVitaminE] The maximum amount of Vitamin E in milligrams the recipe can have.
     * @param {number} [minVitaminK] The minimum amount of Vitamin K in micrograms the recipe must have.
     * @param {number} [maxVitaminK] The maximum amount of Vitamin K in micrograms the recipe can have.
     * @param {number} [minVitaminB1] The minimum amount of Vitamin B1 in milligrams the recipe must have.
     * @param {number} [maxVitaminB1] The maximum amount of Vitamin B1 in milligrams the recipe can have.
     * @param {number} [minVitaminB2] The minimum amount of Vitamin B2 in milligrams the recipe must have.
     * @param {number} [maxVitaminB2] The maximum amount of Vitamin B2 in milligrams the recipe can have.
     * @param {number} [minVitaminB5] The minimum amount of Vitamin B5 in milligrams the recipe must have.
     * @param {number} [maxVitaminB5] The maximum amount of Vitamin B5 in milligrams the recipe can have.
     * @param {number} [minVitaminB3] The minimum amount of Vitamin B3 in milligrams the recipe must have.
     * @param {number} [maxVitaminB3] The maximum amount of Vitamin B3 in milligrams the recipe can have.
     * @param {number} [minVitaminB6] The minimum amount of Vitamin B6 in milligrams the recipe must have.
     * @param {number} [maxVitaminB6] The maximum amount of Vitamin B6 in milligrams the recipe can have.
     * @param {number} [minVitaminB12] The minimum amount of Vitamin B12 in micrograms the recipe must have.
     * @param {number} [maxVitaminB12] The maximum amount of Vitamin B12 in micrograms the recipe can have.
     * @param {number} [minFiber] The minimum amount of fiber in grams the recipe must have.
     * @param {number} [maxFiber] The maximum amount of fiber in grams the recipe can have.
     * @param {number} [minFolate] The minimum amount of folate in micrograms the recipe must have.
     * @param {number} [maxFolate] The maximum amount of folate in micrograms the recipe can have.
     * @param {number} [minFolicAcid] The minimum amount of folic acid in micrograms the recipe must have.
     * @param {number} [maxFolicAcid] The maximum amount of folic acid in micrograms the recipe can have.
     * @param {number} [minIodine] The minimum amount of iodine in micrograms the recipe must have.
     * @param {number} [maxIodine] The maximum amount of iodine in micrograms the recipe can have.
     * @param {number} [minIron] The minimum amount of iron in milligrams the recipe must have.
     * @param {number} [maxIron] The maximum amount of iron in milligrams the recipe can have.
     * @param {number} [minMagnesium] The minimum amount of magnesium in milligrams the recipe must have.
     * @param {number} [maxMagnesium] The maximum amount of magnesium in milligrams the recipe can have.
     * @param {number} [minManganese] The minimum amount of manganese in milligrams the recipe must have.
     * @param {number} [maxManganese] The maximum amount of manganese in milligrams the recipe can have.
     * @param {number} [minPhosphorus] The minimum amount of phosphorus in milligrams the recipe must have.
     * @param {number} [maxPhosphorus] The maximum amount of phosphorus in milligrams the recipe can have.
     * @param {number} [minPotassium] The minimum amount of potassium in milligrams the recipe must have.
     * @param {number} [maxPotassium] The maximum amount of potassium in milligrams the recipe can have.
     * @param {number} [minSelenium] The minimum amount of selenium in micrograms the recipe must have.
     * @param {number} [maxSelenium] The maximum amount of selenium in micrograms the recipe can have.
     * @param {number} [minSodium] The minimum amount of sodium in milligrams the recipe must have.
     * @param {number} [maxSodium] The maximum amount of sodium in milligrams the recipe can have.
     * @param {number} [minSugar] The minimum amount of sugar in grams the recipe must have.
     * @param {number} [maxSugar] The maximum amount of sugar in grams the recipe can have.
     * @param {number} [minZinc] The minimum amount of zinc in milligrams the recipe must have.
     * @param {number} [maxZinc] The maximum amount of zinc in milligrams the recipe can have.
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {boolean} [random] If true, every request will give you a random set of recipes within the requested limits.
     * @param {boolean} [limitLicense] Whether the recipes should have an open license that allows display with proper attribution.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchRecipesByNutrients: async (
      minCarbs?: number,
      maxCarbs?: number,
      minProtein?: number,
      maxProtein?: number,
      minCalories?: number,
      maxCalories?: number,
      minFat?: number,
      maxFat?: number,
      minAlcohol?: number,
      maxAlcohol?: number,
      minCaffeine?: number,
      maxCaffeine?: number,
      minCopper?: number,
      maxCopper?: number,
      minCalcium?: number,
      maxCalcium?: number,
      minCholine?: number,
      maxCholine?: number,
      minCholesterol?: number,
      maxCholesterol?: number,
      minFluoride?: number,
      maxFluoride?: number,
      minSaturatedFat?: number,
      maxSaturatedFat?: number,
      minVitaminA?: number,
      maxVitaminA?: number,
      minVitaminC?: number,
      maxVitaminC?: number,
      minVitaminD?: number,
      maxVitaminD?: number,
      minVitaminE?: number,
      maxVitaminE?: number,
      minVitaminK?: number,
      maxVitaminK?: number,
      minVitaminB1?: number,
      maxVitaminB1?: number,
      minVitaminB2?: number,
      maxVitaminB2?: number,
      minVitaminB5?: number,
      maxVitaminB5?: number,
      minVitaminB3?: number,
      maxVitaminB3?: number,
      minVitaminB6?: number,
      maxVitaminB6?: number,
      minVitaminB12?: number,
      maxVitaminB12?: number,
      minFiber?: number,
      maxFiber?: number,
      minFolate?: number,
      maxFolate?: number,
      minFolicAcid?: number,
      maxFolicAcid?: number,
      minIodine?: number,
      maxIodine?: number,
      minIron?: number,
      maxIron?: number,
      minMagnesium?: number,
      maxMagnesium?: number,
      minManganese?: number,
      maxManganese?: number,
      minPhosphorus?: number,
      maxPhosphorus?: number,
      minPotassium?: number,
      maxPotassium?: number,
      minSelenium?: number,
      maxSelenium?: number,
      minSodium?: number,
      maxSodium?: number,
      minSugar?: number,
      maxSugar?: number,
      minZinc?: number,
      maxZinc?: number,
      offset?: number,
      number?: number,
      random?: boolean,
      limitLicense?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/recipes/findByNutrients`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (minCarbs !== undefined) {
        localVarQueryParameter["minCarbs"] = minCarbs;
      }

      if (maxCarbs !== undefined) {
        localVarQueryParameter["maxCarbs"] = maxCarbs;
      }

      if (minProtein !== undefined) {
        localVarQueryParameter["minProtein"] = minProtein;
      }

      if (maxProtein !== undefined) {
        localVarQueryParameter["maxProtein"] = maxProtein;
      }

      if (minCalories !== undefined) {
        localVarQueryParameter["minCalories"] = minCalories;
      }

      if (maxCalories !== undefined) {
        localVarQueryParameter["maxCalories"] = maxCalories;
      }

      if (minFat !== undefined) {
        localVarQueryParameter["minFat"] = minFat;
      }

      if (maxFat !== undefined) {
        localVarQueryParameter["maxFat"] = maxFat;
      }

      if (minAlcohol !== undefined) {
        localVarQueryParameter["minAlcohol"] = minAlcohol;
      }

      if (maxAlcohol !== undefined) {
        localVarQueryParameter["maxAlcohol"] = maxAlcohol;
      }

      if (minCaffeine !== undefined) {
        localVarQueryParameter["minCaffeine"] = minCaffeine;
      }

      if (maxCaffeine !== undefined) {
        localVarQueryParameter["maxCaffeine"] = maxCaffeine;
      }

      if (minCopper !== undefined) {
        localVarQueryParameter["minCopper"] = minCopper;
      }

      if (maxCopper !== undefined) {
        localVarQueryParameter["maxCopper"] = maxCopper;
      }

      if (minCalcium !== undefined) {
        localVarQueryParameter["minCalcium"] = minCalcium;
      }

      if (maxCalcium !== undefined) {
        localVarQueryParameter["maxCalcium"] = maxCalcium;
      }

      if (minCholine !== undefined) {
        localVarQueryParameter["minCholine"] = minCholine;
      }

      if (maxCholine !== undefined) {
        localVarQueryParameter["maxCholine"] = maxCholine;
      }

      if (minCholesterol !== undefined) {
        localVarQueryParameter["minCholesterol"] = minCholesterol;
      }

      if (maxCholesterol !== undefined) {
        localVarQueryParameter["maxCholesterol"] = maxCholesterol;
      }

      if (minFluoride !== undefined) {
        localVarQueryParameter["minFluoride"] = minFluoride;
      }

      if (maxFluoride !== undefined) {
        localVarQueryParameter["maxFluoride"] = maxFluoride;
      }

      if (minSaturatedFat !== undefined) {
        localVarQueryParameter["minSaturatedFat"] = minSaturatedFat;
      }

      if (maxSaturatedFat !== undefined) {
        localVarQueryParameter["maxSaturatedFat"] = maxSaturatedFat;
      }

      if (minVitaminA !== undefined) {
        localVarQueryParameter["minVitaminA"] = minVitaminA;
      }

      if (maxVitaminA !== undefined) {
        localVarQueryParameter["maxVitaminA"] = maxVitaminA;
      }

      if (minVitaminC !== undefined) {
        localVarQueryParameter["minVitaminC"] = minVitaminC;
      }

      if (maxVitaminC !== undefined) {
        localVarQueryParameter["maxVitaminC"] = maxVitaminC;
      }

      if (minVitaminD !== undefined) {
        localVarQueryParameter["minVitaminD"] = minVitaminD;
      }

      if (maxVitaminD !== undefined) {
        localVarQueryParameter["maxVitaminD"] = maxVitaminD;
      }

      if (minVitaminE !== undefined) {
        localVarQueryParameter["minVitaminE"] = minVitaminE;
      }

      if (maxVitaminE !== undefined) {
        localVarQueryParameter["maxVitaminE"] = maxVitaminE;
      }

      if (minVitaminK !== undefined) {
        localVarQueryParameter["minVitaminK"] = minVitaminK;
      }

      if (maxVitaminK !== undefined) {
        localVarQueryParameter["maxVitaminK"] = maxVitaminK;
      }

      if (minVitaminB1 !== undefined) {
        localVarQueryParameter["minVitaminB1"] = minVitaminB1;
      }

      if (maxVitaminB1 !== undefined) {
        localVarQueryParameter["maxVitaminB1"] = maxVitaminB1;
      }

      if (minVitaminB2 !== undefined) {
        localVarQueryParameter["minVitaminB2"] = minVitaminB2;
      }

      if (maxVitaminB2 !== undefined) {
        localVarQueryParameter["maxVitaminB2"] = maxVitaminB2;
      }

      if (minVitaminB5 !== undefined) {
        localVarQueryParameter["minVitaminB5"] = minVitaminB5;
      }

      if (maxVitaminB5 !== undefined) {
        localVarQueryParameter["maxVitaminB5"] = maxVitaminB5;
      }

      if (minVitaminB3 !== undefined) {
        localVarQueryParameter["minVitaminB3"] = minVitaminB3;
      }

      if (maxVitaminB3 !== undefined) {
        localVarQueryParameter["maxVitaminB3"] = maxVitaminB3;
      }

      if (minVitaminB6 !== undefined) {
        localVarQueryParameter["minVitaminB6"] = minVitaminB6;
      }

      if (maxVitaminB6 !== undefined) {
        localVarQueryParameter["maxVitaminB6"] = maxVitaminB6;
      }

      if (minVitaminB12 !== undefined) {
        localVarQueryParameter["minVitaminB12"] = minVitaminB12;
      }

      if (maxVitaminB12 !== undefined) {
        localVarQueryParameter["maxVitaminB12"] = maxVitaminB12;
      }

      if (minFiber !== undefined) {
        localVarQueryParameter["minFiber"] = minFiber;
      }

      if (maxFiber !== undefined) {
        localVarQueryParameter["maxFiber"] = maxFiber;
      }

      if (minFolate !== undefined) {
        localVarQueryParameter["minFolate"] = minFolate;
      }

      if (maxFolate !== undefined) {
        localVarQueryParameter["maxFolate"] = maxFolate;
      }

      if (minFolicAcid !== undefined) {
        localVarQueryParameter["minFolicAcid"] = minFolicAcid;
      }

      if (maxFolicAcid !== undefined) {
        localVarQueryParameter["maxFolicAcid"] = maxFolicAcid;
      }

      if (minIodine !== undefined) {
        localVarQueryParameter["minIodine"] = minIodine;
      }

      if (maxIodine !== undefined) {
        localVarQueryParameter["maxIodine"] = maxIodine;
      }

      if (minIron !== undefined) {
        localVarQueryParameter["minIron"] = minIron;
      }

      if (maxIron !== undefined) {
        localVarQueryParameter["maxIron"] = maxIron;
      }

      if (minMagnesium !== undefined) {
        localVarQueryParameter["minMagnesium"] = minMagnesium;
      }

      if (maxMagnesium !== undefined) {
        localVarQueryParameter["maxMagnesium"] = maxMagnesium;
      }

      if (minManganese !== undefined) {
        localVarQueryParameter["minManganese"] = minManganese;
      }

      if (maxManganese !== undefined) {
        localVarQueryParameter["maxManganese"] = maxManganese;
      }

      if (minPhosphorus !== undefined) {
        localVarQueryParameter["minPhosphorus"] = minPhosphorus;
      }

      if (maxPhosphorus !== undefined) {
        localVarQueryParameter["maxPhosphorus"] = maxPhosphorus;
      }

      if (minPotassium !== undefined) {
        localVarQueryParameter["minPotassium"] = minPotassium;
      }

      if (maxPotassium !== undefined) {
        localVarQueryParameter["maxPotassium"] = maxPotassium;
      }

      if (minSelenium !== undefined) {
        localVarQueryParameter["minSelenium"] = minSelenium;
      }

      if (maxSelenium !== undefined) {
        localVarQueryParameter["maxSelenium"] = maxSelenium;
      }

      if (minSodium !== undefined) {
        localVarQueryParameter["minSodium"] = minSodium;
      }

      if (maxSodium !== undefined) {
        localVarQueryParameter["maxSodium"] = maxSodium;
      }

      if (minSugar !== undefined) {
        localVarQueryParameter["minSugar"] = minSugar;
      }

      if (maxSugar !== undefined) {
        localVarQueryParameter["maxSugar"] = maxSugar;
      }

      if (minZinc !== undefined) {
        localVarQueryParameter["minZinc"] = minZinc;
      }

      if (maxZinc !== undefined) {
        localVarQueryParameter["maxZinc"] = maxZinc;
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
      }

      if (number !== undefined) {
        localVarQueryParameter["number"] = number;
      }

      if (random !== undefined) {
        localVarQueryParameter["random"] = random;
      }

      if (limitLicense !== undefined) {
        localVarQueryParameter["limitLicense"] = limitLicense;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Automatically generate a short description that summarizes key information about the recipe.
     * @summary Summarize Recipe
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    summarizeRecipe: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("summarizeRecipe", "id", id);
      const localVarPath = `/recipes/{id}/summary`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Visualize the equipment used to make a recipe.
     * @summary Equipment Widget
     * @param {VisualizeEquipmentContentTypeEnum} [contentType] The content type.
     * @param {VisualizeEquipmentAcceptEnum} [accept] Accept header.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizeEquipment: async (
      contentType?: VisualizeEquipmentContentTypeEnum,
      accept?: VisualizeEquipmentAcceptEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/recipes/visualizeEquipment`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (contentType != null) {
        localVarHeaderParameter["Content-Type"] = String(contentType);
      }

      if (accept != null) {
        localVarHeaderParameter["Accept"] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Visualize the price breakdown of a recipe.
     * @summary Price Breakdown Widget
     * @param {VisualizePriceBreakdownContentTypeEnum} [contentType] The content type.
     * @param {VisualizePriceBreakdownAcceptEnum} [accept] Accept header.
     * @param {VisualizePriceBreakdownLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizePriceBreakdown: async (
      contentType?: VisualizePriceBreakdownContentTypeEnum,
      accept?: VisualizePriceBreakdownAcceptEnum,
      language?: VisualizePriceBreakdownLanguageEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/recipes/visualizePriceEstimator`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (contentType != null) {
        localVarHeaderParameter["Content-Type"] = String(contentType);
      }

      if (accept != null) {
        localVarHeaderParameter["Accept"] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Visualize a recipe\'s equipment list.
     * @summary Equipment by ID Widget
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizeRecipeEquipmentByID: async (
      id: number,
      defaultCss?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("visualizeRecipeEquipmentByID", "id", id);
      const localVarPath = `/recipes/{id}/equipmentWidget`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (defaultCss !== undefined) {
        localVarQueryParameter["defaultCss"] = defaultCss;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Visualize a recipe\'s ingredient list.
     * @summary Ingredients by ID Widget
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {VisualizeRecipeIngredientsByIDMeasureEnum} [measure] Whether the the measures should be \&#39;us\&#39; or \&#39;metric\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizeRecipeIngredientsByID: async (
      id: number,
      defaultCss?: boolean,
      measure?: VisualizeRecipeIngredientsByIDMeasureEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("visualizeRecipeIngredientsByID", "id", id);
      const localVarPath = `/recipes/{id}/ingredientWidget`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (defaultCss !== undefined) {
        localVarQueryParameter["defaultCss"] = defaultCss;
      }

      if (measure !== undefined) {
        localVarQueryParameter["measure"] = measure;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Visualize a recipe\'s nutritional information as HTML including CSS.
     * @summary Recipe Nutrition Widget
     * @param {VisualizeRecipeNutritionContentTypeEnum} [contentType] The content type.
     * @param {VisualizeRecipeNutritionAcceptEnum} [accept] Accept header.
     * @param {VisualizeRecipeNutritionLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizeRecipeNutrition: async (
      contentType?: VisualizeRecipeNutritionContentTypeEnum,
      accept?: VisualizeRecipeNutritionAcceptEnum,
      language?: VisualizeRecipeNutritionLanguageEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/recipes/visualizeNutrition`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (contentType != null) {
        localVarHeaderParameter["Content-Type"] = String(contentType);
      }

      if (accept != null) {
        localVarHeaderParameter["Accept"] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Visualize a recipe\'s nutritional information as HTML including CSS.
     * @summary Recipe Nutrition by ID Widget
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {VisualizeRecipeNutritionByIDAcceptEnum} [accept] Accept header.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizeRecipeNutritionByID: async (
      id: number,
      defaultCss?: boolean,
      accept?: VisualizeRecipeNutritionByIDAcceptEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("visualizeRecipeNutritionByID", "id", id);
      const localVarPath = `/recipes/{id}/nutritionWidget`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (defaultCss !== undefined) {
        localVarQueryParameter["defaultCss"] = defaultCss;
      }

      if (accept != null) {
        localVarHeaderParameter["Accept"] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Visualize a recipe\'s price breakdown.
     * @summary Price Breakdown by ID Widget
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizeRecipePriceBreakdownByID: async (
      id: number,
      defaultCss?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("visualizeRecipePriceBreakdownByID", "id", id);
      const localVarPath = `/recipes/{id}/priceBreakdownWidget`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (defaultCss !== undefined) {
        localVarQueryParameter["defaultCss"] = defaultCss;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Visualize a recipe\'s taste information as HTML including CSS. You can play around with that endpoint!
     * @summary Recipe Taste Widget
     * @param {VisualizeRecipeTasteLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {VisualizeRecipeTasteContentTypeEnum} [contentType] The content type.
     * @param {VisualizeRecipeTasteAcceptEnum} [accept] Accept header.
     * @param {boolean} [normalize] Whether to normalize to the strongest taste.
     * @param {string} [rgb] Red, green, blue values for the chart color.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizeRecipeTaste: async (
      language?: VisualizeRecipeTasteLanguageEnum,
      contentType?: VisualizeRecipeTasteContentTypeEnum,
      accept?: VisualizeRecipeTasteAcceptEnum,
      normalize?: boolean,
      rgb?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/recipes/visualizeTaste`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (normalize !== undefined) {
        localVarQueryParameter["normalize"] = normalize;
      }

      if (rgb !== undefined) {
        localVarQueryParameter["rgb"] = rgb;
      }

      if (contentType != null) {
        localVarHeaderParameter["Content-Type"] = String(contentType);
      }

      if (accept != null) {
        localVarHeaderParameter["Accept"] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a recipe\'s taste. The tastes supported are sweet, salty, sour, bitter, savory, and fatty.
     * @summary Recipe Taste by ID Widget
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [normalize] Whether to normalize to the strongest taste.
     * @param {string} [rgb] Red, green, blue values for the chart color.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizeRecipeTasteByID: async (
      id: number,
      normalize?: boolean,
      rgb?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("visualizeRecipeTasteByID", "id", id);
      const localVarPath = `/recipes/{id}/tasteWidget`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (normalize !== undefined) {
        localVarQueryParameter["normalize"] = normalize;
      }

      if (rgb !== undefined) {
        localVarQueryParameter["rgb"] = rgb;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RecipesApi - functional programming interface
 * @export
 */
export const RecipesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RecipesApiAxiosParamCreator(configuration);
  return {
    /**
     * Parse a recipe search query to find out its intention.
     * @summary Analyze a Recipe Search Query
     * @param {string} q The recipe search query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async analyzeARecipeSearchQuery(
      q: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AnalyzeARecipeSearchQuery200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.analyzeARecipeSearchQuery(q, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.analyzeARecipeSearchQuery"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * This endpoint allows you to break down instructions into atomic steps. Furthermore, each step will contain the ingredients and equipment required. Additionally, all ingredients and equipment from the recipe\'s instructions will be extracted independently of the step they\'re used in.
     * @summary Analyze Recipe Instructions
     * @param {AnalyzeRecipeInstructionsContentTypeEnum} [contentType] The content type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async analyzeRecipeInstructions(
      contentType?: AnalyzeRecipeInstructionsContentTypeEnum,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AnalyzeRecipeInstructions200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.analyzeRecipeInstructions(
          contentType,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.analyzeRecipeInstructions"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Autocomplete a partial input to suggest possible recipe names.
     * @summary Autocomplete Recipe Search
     * @param {string} [query] The (natural language) search query.
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autocompleteRecipeSearch(
      query?: string,
      number?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Set<AutocompleteRecipeSearch200ResponseInner>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.autocompleteRecipeSearch(
          query,
          number,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.autocompleteRecipeSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Classify the recipe\'s cuisine.
     * @summary Classify Cuisine
     * @param {ClassifyCuisineContentTypeEnum} [contentType] The content type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async classifyCuisine(
      contentType?: ClassifyCuisineContentTypeEnum,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ClassifyCuisine200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.classifyCuisine(
        contentType,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.classifyCuisine"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve the glycemic index for a list of ingredients and compute the individual and total glycemic load.
     * @summary Compute Glycemic Load
     * @param {ComputeGlycemicLoadRequest} computeGlycemicLoadRequest
     * @param {ComputeGlycemicLoadLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async computeGlycemicLoad(
      computeGlycemicLoadRequest: ComputeGlycemicLoadRequest,
      language?: ComputeGlycemicLoadLanguageEnum,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ComputeGlycemicLoad200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.computeGlycemicLoad(
          computeGlycemicLoadRequest,
          language,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.computeGlycemicLoad"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Convert amounts like \"2 cups of flour to grams\".
     * @summary Convert Amounts
     * @param {string} ingredientName The ingredient which you want to convert.
     * @param {number} sourceAmount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;.
     * @param {string} sourceUnit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot;
     * @param {string} targetUnit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async convertAmounts(
      ingredientName: string,
      sourceAmount: number,
      sourceUnit: string,
      targetUnit: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ConvertAmounts200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.convertAmounts(
        ingredientName,
        sourceAmount,
        sourceUnit,
        targetUnit,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.convertAmounts"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Generate a recipe card for a recipe.
     * @summary Create Recipe Card
     * @param {CreateRecipeCardContentTypeEnum} [contentType] The content type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRecipeCard(
      contentType?: CreateRecipeCardContentTypeEnum,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CreateRecipeCard200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createRecipeCard(contentType, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.createRecipeCard"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Visualize a recipe\'s equipment list as an image.
     * @summary Equipment by ID Image
     * @param {number} id The recipe id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async equipmentByIDImage(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.equipmentByIDImage(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.equipmentByIDImage"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * This endpoint lets you extract recipe data such as title, ingredients, and instructions from any properly formatted Website.
     * @summary Extract Recipe from Website
     * @param {string} url The URL of the recipe page.
     * @param {boolean} [forceExtraction] If true, the extraction will be triggered whether we already know the recipe or not. Use this only if information is missing as this operation is slower.
     * @param {boolean} [analyze] If true, the recipe will be analyzed and classified resolving in more data such as cuisines, dish types, and more.
     * @param {boolean} [includeNutrition] Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings.
     * @param {boolean} [includeTaste] Whether taste data should be added to correctly parsed ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async extractRecipeFromWebsite(
      url: string,
      forceExtraction?: boolean,
      analyze?: boolean,
      includeNutrition?: boolean,
      includeTaste?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetRecipeInformation200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.extractRecipeFromWebsite(
          url,
          forceExtraction,
          analyze,
          includeNutrition,
          includeTaste,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.extractRecipeFromWebsite"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get an analyzed breakdown of a recipe\'s instructions. Each step is enriched with the ingredients and equipment required.
     * @summary Get Analyzed Recipe Instructions
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [stepBreakdown] Whether to break down the recipe steps even more.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAnalyzedRecipeInstructions(
      id: number,
      stepBreakdown?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetAnalyzedRecipeInstructions200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAnalyzedRecipeInstructions(
          id,
          stepBreakdown,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.getAnalyzedRecipeInstructions"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Find random (popular) recipes. If you need to filter recipes by diet, nutrition etc. you might want to consider using the complex recipe search endpoint and set the sort request parameter to random.
     * @summary Get Random Recipes
     * @param {boolean} [limitLicense] Whether the recipes should have an open license that allows display with proper attribution.
     * @param {string} [tags] The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have.
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRandomRecipes(
      limitLicense?: boolean,
      tags?: string,
      number?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetRandomRecipes200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRandomRecipes(
          limitLicense,
          tags,
          number,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.getRandomRecipes"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a recipe\'s equipment list.
     * @summary Equipment by ID
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecipeEquipmentByID(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetRecipeEquipmentByID200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRecipeEquipmentByID(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.getRecipeEquipmentByID"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Use a recipe id to get full information about a recipe, such as ingredients, nutrition, diet and allergen information, etc.
     * @summary Get Recipe Information
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [includeNutrition] Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecipeInformation(
      id: number,
      includeNutrition?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetRecipeInformation200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRecipeInformation(
          id,
          includeNutrition,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.getRecipeInformation"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get information about multiple recipes at once. This is equivalent to calling the Get Recipe Information endpoint multiple times, but faster.
     * @summary Get Recipe Information Bulk
     * @param {string} ids A comma-separated list of recipe ids.
     * @param {boolean} [includeNutrition] Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecipeInformationBulk(
      ids: string,
      includeNutrition?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Set<GetRecipeInformationBulk200ResponseInner>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRecipeInformationBulk(
          ids,
          includeNutrition,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.getRecipeInformationBulk"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a recipe\'s ingredient list.
     * @summary Ingredients by ID
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecipeIngredientsByID(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetRecipeIngredientsByID200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRecipeIngredientsByID(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.getRecipeIngredientsByID"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a recipe\'s nutrition data.
     * @summary Nutrition by ID
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecipeNutritionWidgetByID(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetRecipeNutritionWidgetByID200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRecipeNutritionWidgetByID(
          id,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.getRecipeNutritionWidgetByID"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a recipe\'s price breakdown data.
     * @summary Price Breakdown by ID
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecipePriceBreakdownByID(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetRecipePriceBreakdownByID200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRecipePriceBreakdownByID(
          id,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.getRecipePriceBreakdownByID"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a recipe\'s taste. The tastes supported are sweet, salty, sour, bitter, savory, and fatty.
     * @summary Taste by ID
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [normalize] Normalize to the strongest taste.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecipeTasteByID(
      id: number,
      normalize?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetRecipeTasteByID200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRecipeTasteByID(
          id,
          normalize,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.getRecipeTasteByID"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Find recipes which are similar to the given one.
     * @summary Get Similar Recipes
     * @param {number} id The item\&#39;s id.
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {boolean} [limitLicense] Whether the recipes should have an open license that allows display with proper attribution.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSimilarRecipes(
      id: number,
      number?: number,
      limitLicense?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Set<GetSimilarRecipes200ResponseInner>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSimilarRecipes(
          id,
          number,
          limitLicense,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.getSimilarRecipes"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Estimate the macronutrients of a dish based on its title.
     * @summary Guess Nutrition by Dish Name
     * @param {string} title The title of the dish.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async guessNutritionByDishName(
      title: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GuessNutritionByDishName200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.guessNutritionByDishName(
          title,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.guessNutritionByDishName"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Visualize a recipe\'s ingredient list.
     * @summary Ingredients by ID Image
     * @param {number} id The recipe id.
     * @param {IngredientsByIDImageMeasureEnum} [measure] Whether the the measures should be \&#39;us\&#39; or \&#39;metric\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ingredientsByIDImage(
      id: number,
      measure?: IngredientsByIDImageMeasureEnum,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ingredientsByIDImage(
          id,
          measure,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.ingredientsByIDImage"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Extract an ingredient from plain text.
     * @summary Parse Ingredients
     * @param {ParseIngredientsContentTypeEnum} [contentType] The content type.
     * @param {ParseIngredientsLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async parseIngredients(
      contentType?: ParseIngredientsContentTypeEnum,
      language?: ParseIngredientsLanguageEnum,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Set<ParseIngredients200ResponseInner>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.parseIngredients(
          contentType,
          language,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.parseIngredients"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Visualize a recipe\'s price breakdown.
     * @summary Price Breakdown by ID Image
     * @param {number} id The recipe id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async priceBreakdownByIDImage(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.priceBreakdownByIDImage(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.priceBreakdownByIDImage"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Answer a nutrition related natural language question.
     * @summary Quick Answer
     * @param {string} q The nutrition related question.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async quickAnswer(
      q: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<QuickAnswer200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.quickAnswer(
        q,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.quickAnswer"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Visualize a recipe\'s nutritional information as an image.
     * @summary Recipe Nutrition by ID Image
     * @param {number} id The recipe id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async recipeNutritionByIDImage(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.recipeNutritionByIDImage(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.recipeNutritionByIDImage"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a recipe\'s nutrition label as an image.
     * @summary Recipe Nutrition Label Image
     * @param {number} id The recipe id.
     * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
     * @param {boolean} [showZeroValues] Whether to show zero values.
     * @param {boolean} [showIngredients] Whether to show a list of ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async recipeNutritionLabelImage(
      id: number,
      showOptionalNutrients?: boolean,
      showZeroValues?: boolean,
      showIngredients?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.recipeNutritionLabelImage(
          id,
          showOptionalNutrients,
          showZeroValues,
          showIngredients,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.recipeNutritionLabelImage"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a recipe\'s nutrition label as an HTML widget.
     * @summary Recipe Nutrition Label Widget
     * @param {number} id The recipe id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
     * @param {boolean} [showZeroValues] Whether to show zero values.
     * @param {boolean} [showIngredients] Whether to show a list of ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async recipeNutritionLabelWidget(
      id: number,
      defaultCss?: boolean,
      showOptionalNutrients?: boolean,
      showZeroValues?: boolean,
      showIngredients?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.recipeNutritionLabelWidget(
          id,
          defaultCss,
          showOptionalNutrients,
          showZeroValues,
          showIngredients,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.recipeNutritionLabelWidget"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a recipe\'s taste as an image. The tastes supported are sweet, salty, sour, bitter, savory, and fatty.
     * @summary Recipe Taste by ID Image
     * @param {number} id The recipe id.
     * @param {boolean} [normalize] Normalize to the strongest taste.
     * @param {string} [rgb] Red, green, blue values for the chart color.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async recipeTasteByIDImage(
      id: number,
      normalize?: boolean,
      rgb?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.recipeTasteByIDImage(
          id,
          normalize,
          rgb,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.recipeTasteByIDImage"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Search through hundreds of thousands of recipes using advanced filtering and ranking. NOTE: This method combines searching by query, by ingredients, and by nutrients into one endpoint.
     * @summary Search Recipes
     * @param {string} [query] The (natural language) search query.
     * @param {string} [cuisine] The cuisine(s) of the recipes. One or more, comma separated (will be interpreted as \&#39;OR\&#39;). See a full list of supported cuisines.
     * @param {string} [excludeCuisine] The cuisine(s) the recipes must not match. One or more, comma separated (will be interpreted as \&#39;AND\&#39;). See a full list of supported cuisines.
     * @param {string} [diet] The diet for which the recipes must be suitable. See a full list of supported diets.
     * @param {string} [intolerances] A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.
     * @param {string} [equipment] The equipment required. Multiple values will be interpreted as \&#39;or\&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;.
     * @param {string} [includeIngredients] A comma-separated list of ingredients that should/must be used in the recipes.
     * @param {string} [excludeIngredients] A comma-separated list of ingredients or ingredient types that the recipes must not contain.
     * @param {string} [type] The type of recipe. See a full list of supported meal types.
     * @param {boolean} [instructionsRequired] Whether the recipes must have instructions.
     * @param {boolean} [fillIngredients] Add information about the ingredients and whether they are used or missing in relation to the query.
     * @param {boolean} [addRecipeInformation] If set to true, you get more information about the recipes returned.
     * @param {boolean} [addRecipeNutrition] If set to true, you get nutritional information about each recipes returned.
     * @param {string} [author] The username of the recipe author.
     * @param {string} [tags] The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have.
     * @param {number} [recipeBoxId] The id of the recipe box to which the search should be limited to.
     * @param {string} [titleMatch] Enter text that must be found in the title of the recipes.
     * @param {number} [maxReadyTime] The maximum time in minutes it should take to prepare and cook the recipe.
     * @param {boolean} [ignorePantry] Whether to ignore typical pantry items, such as water, salt, flour, etc.
     * @param {string} [sort] The strategy to sort recipes by. See a full list of supported sorting options.
     * @param {string} [sortDirection] The direction in which to sort. Must be either \&#39;asc\&#39; (ascending) or \&#39;desc\&#39; (descending).
     * @param {number} [minCarbs] The minimum amount of carbohydrates in grams the recipe must have.
     * @param {number} [maxCarbs] The maximum amount of carbohydrates in grams the recipe can have.
     * @param {number} [minProtein] The minimum amount of protein in grams the recipe must have.
     * @param {number} [maxProtein] The maximum amount of protein in grams the recipe can have.
     * @param {number} [minCalories] The minimum amount of calories the recipe must have.
     * @param {number} [maxCalories] The maximum amount of calories the recipe can have.
     * @param {number} [minFat] The minimum amount of fat in grams the recipe must have.
     * @param {number} [maxFat] The maximum amount of fat in grams the recipe can have.
     * @param {number} [minAlcohol] The minimum amount of alcohol in grams the recipe must have.
     * @param {number} [maxAlcohol] The maximum amount of alcohol in grams the recipe can have.
     * @param {number} [minCaffeine] The minimum amount of caffeine in milligrams the recipe must have.
     * @param {number} [maxCaffeine] The maximum amount of caffeine in milligrams the recipe can have.
     * @param {number} [minCopper] The minimum amount of copper in milligrams the recipe must have.
     * @param {number} [maxCopper] The maximum amount of copper in milligrams the recipe can have.
     * @param {number} [minCalcium] The minimum amount of calcium in milligrams the recipe must have.
     * @param {number} [maxCalcium] The maximum amount of calcium in milligrams the recipe can have.
     * @param {number} [minCholine] The minimum amount of choline in milligrams the recipe must have.
     * @param {number} [maxCholine] The maximum amount of choline in milligrams the recipe can have.
     * @param {number} [minCholesterol] The minimum amount of cholesterol in milligrams the recipe must have.
     * @param {number} [maxCholesterol] The maximum amount of cholesterol in milligrams the recipe can have.
     * @param {number} [minFluoride] The minimum amount of fluoride in milligrams the recipe must have.
     * @param {number} [maxFluoride] The maximum amount of fluoride in milligrams the recipe can have.
     * @param {number} [minSaturatedFat] The minimum amount of saturated fat in grams the recipe must have.
     * @param {number} [maxSaturatedFat] The maximum amount of saturated fat in grams the recipe can have.
     * @param {number} [minVitaminA] The minimum amount of Vitamin A in IU the recipe must have.
     * @param {number} [maxVitaminA] The maximum amount of Vitamin A in IU the recipe can have.
     * @param {number} [minVitaminC] The minimum amount of Vitamin C milligrams the recipe must have.
     * @param {number} [maxVitaminC] The maximum amount of Vitamin C in milligrams the recipe can have.
     * @param {number} [minVitaminD] The minimum amount of Vitamin D in micrograms the recipe must have.
     * @param {number} [maxVitaminD] The maximum amount of Vitamin D in micrograms the recipe can have.
     * @param {number} [minVitaminE] The minimum amount of Vitamin E in milligrams the recipe must have.
     * @param {number} [maxVitaminE] The maximum amount of Vitamin E in milligrams the recipe can have.
     * @param {number} [minVitaminK] The minimum amount of Vitamin K in micrograms the recipe must have.
     * @param {number} [maxVitaminK] The maximum amount of Vitamin K in micrograms the recipe can have.
     * @param {number} [minVitaminB1] The minimum amount of Vitamin B1 in milligrams the recipe must have.
     * @param {number} [maxVitaminB1] The maximum amount of Vitamin B1 in milligrams the recipe can have.
     * @param {number} [minVitaminB2] The minimum amount of Vitamin B2 in milligrams the recipe must have.
     * @param {number} [maxVitaminB2] The maximum amount of Vitamin B2 in milligrams the recipe can have.
     * @param {number} [minVitaminB5] The minimum amount of Vitamin B5 in milligrams the recipe must have.
     * @param {number} [maxVitaminB5] The maximum amount of Vitamin B5 in milligrams the recipe can have.
     * @param {number} [minVitaminB3] The minimum amount of Vitamin B3 in milligrams the recipe must have.
     * @param {number} [maxVitaminB3] The maximum amount of Vitamin B3 in milligrams the recipe can have.
     * @param {number} [minVitaminB6] The minimum amount of Vitamin B6 in milligrams the recipe must have.
     * @param {number} [maxVitaminB6] The maximum amount of Vitamin B6 in milligrams the recipe can have.
     * @param {number} [minVitaminB12] The minimum amount of Vitamin B12 in micrograms the recipe must have.
     * @param {number} [maxVitaminB12] The maximum amount of Vitamin B12 in micrograms the recipe can have.
     * @param {number} [minFiber] The minimum amount of fiber in grams the recipe must have.
     * @param {number} [maxFiber] The maximum amount of fiber in grams the recipe can have.
     * @param {number} [minFolate] The minimum amount of folate in micrograms the recipe must have.
     * @param {number} [maxFolate] The maximum amount of folate in micrograms the recipe can have.
     * @param {number} [minFolicAcid] The minimum amount of folic acid in micrograms the recipe must have.
     * @param {number} [maxFolicAcid] The maximum amount of folic acid in micrograms the recipe can have.
     * @param {number} [minIodine] The minimum amount of iodine in micrograms the recipe must have.
     * @param {number} [maxIodine] The maximum amount of iodine in micrograms the recipe can have.
     * @param {number} [minIron] The minimum amount of iron in milligrams the recipe must have.
     * @param {number} [maxIron] The maximum amount of iron in milligrams the recipe can have.
     * @param {number} [minMagnesium] The minimum amount of magnesium in milligrams the recipe must have.
     * @param {number} [maxMagnesium] The maximum amount of magnesium in milligrams the recipe can have.
     * @param {number} [minManganese] The minimum amount of manganese in milligrams the recipe must have.
     * @param {number} [maxManganese] The maximum amount of manganese in milligrams the recipe can have.
     * @param {number} [minPhosphorus] The minimum amount of phosphorus in milligrams the recipe must have.
     * @param {number} [maxPhosphorus] The maximum amount of phosphorus in milligrams the recipe can have.
     * @param {number} [minPotassium] The minimum amount of potassium in milligrams the recipe must have.
     * @param {number} [maxPotassium] The maximum amount of potassium in milligrams the recipe can have.
     * @param {number} [minSelenium] The minimum amount of selenium in micrograms the recipe must have.
     * @param {number} [maxSelenium] The maximum amount of selenium in micrograms the recipe can have.
     * @param {number} [minSodium] The minimum amount of sodium in milligrams the recipe must have.
     * @param {number} [maxSodium] The maximum amount of sodium in milligrams the recipe can have.
     * @param {number} [minSugar] The minimum amount of sugar in grams the recipe must have.
     * @param {number} [maxSugar] The maximum amount of sugar in grams the recipe can have.
     * @param {number} [minZinc] The minimum amount of zinc in milligrams the recipe must have.
     * @param {number} [maxZinc] The maximum amount of zinc in milligrams the recipe can have.
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {boolean} [limitLicense] Whether the recipes should have an open license that allows display with proper attribution.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchRecipes(
      query?: string,
      cuisine?: string,
      excludeCuisine?: string,
      diet?: string,
      intolerances?: string,
      equipment?: string,
      includeIngredients?: string,
      excludeIngredients?: string,
      type?: string,
      instructionsRequired?: boolean,
      fillIngredients?: boolean,
      addRecipeInformation?: boolean,
      addRecipeNutrition?: boolean,
      author?: string,
      tags?: string,
      recipeBoxId?: number,
      titleMatch?: string,
      maxReadyTime?: number,
      ignorePantry?: boolean,
      sort?: string,
      sortDirection?: string,
      minCarbs?: number,
      maxCarbs?: number,
      minProtein?: number,
      maxProtein?: number,
      minCalories?: number,
      maxCalories?: number,
      minFat?: number,
      maxFat?: number,
      minAlcohol?: number,
      maxAlcohol?: number,
      minCaffeine?: number,
      maxCaffeine?: number,
      minCopper?: number,
      maxCopper?: number,
      minCalcium?: number,
      maxCalcium?: number,
      minCholine?: number,
      maxCholine?: number,
      minCholesterol?: number,
      maxCholesterol?: number,
      minFluoride?: number,
      maxFluoride?: number,
      minSaturatedFat?: number,
      maxSaturatedFat?: number,
      minVitaminA?: number,
      maxVitaminA?: number,
      minVitaminC?: number,
      maxVitaminC?: number,
      minVitaminD?: number,
      maxVitaminD?: number,
      minVitaminE?: number,
      maxVitaminE?: number,
      minVitaminK?: number,
      maxVitaminK?: number,
      minVitaminB1?: number,
      maxVitaminB1?: number,
      minVitaminB2?: number,
      maxVitaminB2?: number,
      minVitaminB5?: number,
      maxVitaminB5?: number,
      minVitaminB3?: number,
      maxVitaminB3?: number,
      minVitaminB6?: number,
      maxVitaminB6?: number,
      minVitaminB12?: number,
      maxVitaminB12?: number,
      minFiber?: number,
      maxFiber?: number,
      minFolate?: number,
      maxFolate?: number,
      minFolicAcid?: number,
      maxFolicAcid?: number,
      minIodine?: number,
      maxIodine?: number,
      minIron?: number,
      maxIron?: number,
      minMagnesium?: number,
      maxMagnesium?: number,
      minManganese?: number,
      maxManganese?: number,
      minPhosphorus?: number,
      maxPhosphorus?: number,
      minPotassium?: number,
      maxPotassium?: number,
      minSelenium?: number,
      maxSelenium?: number,
      minSodium?: number,
      maxSodium?: number,
      minSugar?: number,
      maxSugar?: number,
      minZinc?: number,
      maxZinc?: number,
      offset?: number,
      number?: number,
      limitLicense?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SearchRecipes200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchRecipes(
        query,
        cuisine,
        excludeCuisine,
        diet,
        intolerances,
        equipment,
        includeIngredients,
        excludeIngredients,
        type,
        instructionsRequired,
        fillIngredients,
        addRecipeInformation,
        addRecipeNutrition,
        author,
        tags,
        recipeBoxId,
        titleMatch,
        maxReadyTime,
        ignorePantry,
        sort,
        sortDirection,
        minCarbs,
        maxCarbs,
        minProtein,
        maxProtein,
        minCalories,
        maxCalories,
        minFat,
        maxFat,
        minAlcohol,
        maxAlcohol,
        minCaffeine,
        maxCaffeine,
        minCopper,
        maxCopper,
        minCalcium,
        maxCalcium,
        minCholine,
        maxCholine,
        minCholesterol,
        maxCholesterol,
        minFluoride,
        maxFluoride,
        minSaturatedFat,
        maxSaturatedFat,
        minVitaminA,
        maxVitaminA,
        minVitaminC,
        maxVitaminC,
        minVitaminD,
        maxVitaminD,
        minVitaminE,
        maxVitaminE,
        minVitaminK,
        maxVitaminK,
        minVitaminB1,
        maxVitaminB1,
        minVitaminB2,
        maxVitaminB2,
        minVitaminB5,
        maxVitaminB5,
        minVitaminB3,
        maxVitaminB3,
        minVitaminB6,
        maxVitaminB6,
        minVitaminB12,
        maxVitaminB12,
        minFiber,
        maxFiber,
        minFolate,
        maxFolate,
        minFolicAcid,
        maxFolicAcid,
        minIodine,
        maxIodine,
        minIron,
        maxIron,
        minMagnesium,
        maxMagnesium,
        minManganese,
        maxManganese,
        minPhosphorus,
        maxPhosphorus,
        minPotassium,
        maxPotassium,
        minSelenium,
        maxSelenium,
        minSodium,
        maxSodium,
        minSugar,
        maxSugar,
        minZinc,
        maxZinc,
        offset,
        number,
        limitLicense,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.searchRecipes"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *  Ever wondered what recipes you can cook with the ingredients you have in your fridge or pantry? This endpoint lets you find recipes that either maximize the usage of ingredients you have at hand (pre shopping) or minimize the ingredients that you don\'t currently have (post shopping).
     * @summary Search Recipes by Ingredients
     * @param {string} [ingredients] A comma-separated list of ingredients that the recipes should contain.
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {boolean} [limitLicense] Whether the recipes should have an open license that allows display with proper attribution.
     * @param {number} [ranking] Whether to maximize used ingredients (1) or minimize missing ingredients (2) first.
     * @param {boolean} [ignorePantry] Whether to ignore typical pantry items, such as water, salt, flour, etc.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchRecipesByIngredients(
      ingredients?: string,
      number?: number,
      limitLicense?: boolean,
      ranking?: number,
      ignorePantry?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Set<SearchRecipesByIngredients200ResponseInner>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.searchRecipesByIngredients(
          ingredients,
          number,
          limitLicense,
          ranking,
          ignorePantry,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.searchRecipesByIngredients"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Find a set of recipes that adhere to the given nutritional limits. You may set limits for macronutrients (calories, protein, fat, and carbohydrate) and/or many micronutrients.
     * @summary Search Recipes by Nutrients
     * @param {number} [minCarbs] The minimum amount of carbohydrates in grams the recipe must have.
     * @param {number} [maxCarbs] The maximum amount of carbohydrates in grams the recipe can have.
     * @param {number} [minProtein] The minimum amount of protein in grams the recipe must have.
     * @param {number} [maxProtein] The maximum amount of protein in grams the recipe can have.
     * @param {number} [minCalories] The minimum amount of calories the recipe must have.
     * @param {number} [maxCalories] The maximum amount of calories the recipe can have.
     * @param {number} [minFat] The minimum amount of fat in grams the recipe must have.
     * @param {number} [maxFat] The maximum amount of fat in grams the recipe can have.
     * @param {number} [minAlcohol] The minimum amount of alcohol in grams the recipe must have.
     * @param {number} [maxAlcohol] The maximum amount of alcohol in grams the recipe can have.
     * @param {number} [minCaffeine] The minimum amount of caffeine in milligrams the recipe must have.
     * @param {number} [maxCaffeine] The maximum amount of caffeine in milligrams the recipe can have.
     * @param {number} [minCopper] The minimum amount of copper in milligrams the recipe must have.
     * @param {number} [maxCopper] The maximum amount of copper in milligrams the recipe can have.
     * @param {number} [minCalcium] The minimum amount of calcium in milligrams the recipe must have.
     * @param {number} [maxCalcium] The maximum amount of calcium in milligrams the recipe can have.
     * @param {number} [minCholine] The minimum amount of choline in milligrams the recipe must have.
     * @param {number} [maxCholine] The maximum amount of choline in milligrams the recipe can have.
     * @param {number} [minCholesterol] The minimum amount of cholesterol in milligrams the recipe must have.
     * @param {number} [maxCholesterol] The maximum amount of cholesterol in milligrams the recipe can have.
     * @param {number} [minFluoride] The minimum amount of fluoride in milligrams the recipe must have.
     * @param {number} [maxFluoride] The maximum amount of fluoride in milligrams the recipe can have.
     * @param {number} [minSaturatedFat] The minimum amount of saturated fat in grams the recipe must have.
     * @param {number} [maxSaturatedFat] The maximum amount of saturated fat in grams the recipe can have.
     * @param {number} [minVitaminA] The minimum amount of Vitamin A in IU the recipe must have.
     * @param {number} [maxVitaminA] The maximum amount of Vitamin A in IU the recipe can have.
     * @param {number} [minVitaminC] The minimum amount of Vitamin C in milligrams the recipe must have.
     * @param {number} [maxVitaminC] The maximum amount of Vitamin C in milligrams the recipe can have.
     * @param {number} [minVitaminD] The minimum amount of Vitamin D in micrograms the recipe must have.
     * @param {number} [maxVitaminD] The maximum amount of Vitamin D in micrograms the recipe can have.
     * @param {number} [minVitaminE] The minimum amount of Vitamin E in milligrams the recipe must have.
     * @param {number} [maxVitaminE] The maximum amount of Vitamin E in milligrams the recipe can have.
     * @param {number} [minVitaminK] The minimum amount of Vitamin K in micrograms the recipe must have.
     * @param {number} [maxVitaminK] The maximum amount of Vitamin K in micrograms the recipe can have.
     * @param {number} [minVitaminB1] The minimum amount of Vitamin B1 in milligrams the recipe must have.
     * @param {number} [maxVitaminB1] The maximum amount of Vitamin B1 in milligrams the recipe can have.
     * @param {number} [minVitaminB2] The minimum amount of Vitamin B2 in milligrams the recipe must have.
     * @param {number} [maxVitaminB2] The maximum amount of Vitamin B2 in milligrams the recipe can have.
     * @param {number} [minVitaminB5] The minimum amount of Vitamin B5 in milligrams the recipe must have.
     * @param {number} [maxVitaminB5] The maximum amount of Vitamin B5 in milligrams the recipe can have.
     * @param {number} [minVitaminB3] The minimum amount of Vitamin B3 in milligrams the recipe must have.
     * @param {number} [maxVitaminB3] The maximum amount of Vitamin B3 in milligrams the recipe can have.
     * @param {number} [minVitaminB6] The minimum amount of Vitamin B6 in milligrams the recipe must have.
     * @param {number} [maxVitaminB6] The maximum amount of Vitamin B6 in milligrams the recipe can have.
     * @param {number} [minVitaminB12] The minimum amount of Vitamin B12 in micrograms the recipe must have.
     * @param {number} [maxVitaminB12] The maximum amount of Vitamin B12 in micrograms the recipe can have.
     * @param {number} [minFiber] The minimum amount of fiber in grams the recipe must have.
     * @param {number} [maxFiber] The maximum amount of fiber in grams the recipe can have.
     * @param {number} [minFolate] The minimum amount of folate in micrograms the recipe must have.
     * @param {number} [maxFolate] The maximum amount of folate in micrograms the recipe can have.
     * @param {number} [minFolicAcid] The minimum amount of folic acid in micrograms the recipe must have.
     * @param {number} [maxFolicAcid] The maximum amount of folic acid in micrograms the recipe can have.
     * @param {number} [minIodine] The minimum amount of iodine in micrograms the recipe must have.
     * @param {number} [maxIodine] The maximum amount of iodine in micrograms the recipe can have.
     * @param {number} [minIron] The minimum amount of iron in milligrams the recipe must have.
     * @param {number} [maxIron] The maximum amount of iron in milligrams the recipe can have.
     * @param {number} [minMagnesium] The minimum amount of magnesium in milligrams the recipe must have.
     * @param {number} [maxMagnesium] The maximum amount of magnesium in milligrams the recipe can have.
     * @param {number} [minManganese] The minimum amount of manganese in milligrams the recipe must have.
     * @param {number} [maxManganese] The maximum amount of manganese in milligrams the recipe can have.
     * @param {number} [minPhosphorus] The minimum amount of phosphorus in milligrams the recipe must have.
     * @param {number} [maxPhosphorus] The maximum amount of phosphorus in milligrams the recipe can have.
     * @param {number} [minPotassium] The minimum amount of potassium in milligrams the recipe must have.
     * @param {number} [maxPotassium] The maximum amount of potassium in milligrams the recipe can have.
     * @param {number} [minSelenium] The minimum amount of selenium in micrograms the recipe must have.
     * @param {number} [maxSelenium] The maximum amount of selenium in micrograms the recipe can have.
     * @param {number} [minSodium] The minimum amount of sodium in milligrams the recipe must have.
     * @param {number} [maxSodium] The maximum amount of sodium in milligrams the recipe can have.
     * @param {number} [minSugar] The minimum amount of sugar in grams the recipe must have.
     * @param {number} [maxSugar] The maximum amount of sugar in grams the recipe can have.
     * @param {number} [minZinc] The minimum amount of zinc in milligrams the recipe must have.
     * @param {number} [maxZinc] The maximum amount of zinc in milligrams the recipe can have.
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {boolean} [random] If true, every request will give you a random set of recipes within the requested limits.
     * @param {boolean} [limitLicense] Whether the recipes should have an open license that allows display with proper attribution.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchRecipesByNutrients(
      minCarbs?: number,
      maxCarbs?: number,
      minProtein?: number,
      maxProtein?: number,
      minCalories?: number,
      maxCalories?: number,
      minFat?: number,
      maxFat?: number,
      minAlcohol?: number,
      maxAlcohol?: number,
      minCaffeine?: number,
      maxCaffeine?: number,
      minCopper?: number,
      maxCopper?: number,
      minCalcium?: number,
      maxCalcium?: number,
      minCholine?: number,
      maxCholine?: number,
      minCholesterol?: number,
      maxCholesterol?: number,
      minFluoride?: number,
      maxFluoride?: number,
      minSaturatedFat?: number,
      maxSaturatedFat?: number,
      minVitaminA?: number,
      maxVitaminA?: number,
      minVitaminC?: number,
      maxVitaminC?: number,
      minVitaminD?: number,
      maxVitaminD?: number,
      minVitaminE?: number,
      maxVitaminE?: number,
      minVitaminK?: number,
      maxVitaminK?: number,
      minVitaminB1?: number,
      maxVitaminB1?: number,
      minVitaminB2?: number,
      maxVitaminB2?: number,
      minVitaminB5?: number,
      maxVitaminB5?: number,
      minVitaminB3?: number,
      maxVitaminB3?: number,
      minVitaminB6?: number,
      maxVitaminB6?: number,
      minVitaminB12?: number,
      maxVitaminB12?: number,
      minFiber?: number,
      maxFiber?: number,
      minFolate?: number,
      maxFolate?: number,
      minFolicAcid?: number,
      maxFolicAcid?: number,
      minIodine?: number,
      maxIodine?: number,
      minIron?: number,
      maxIron?: number,
      minMagnesium?: number,
      maxMagnesium?: number,
      minManganese?: number,
      maxManganese?: number,
      minPhosphorus?: number,
      maxPhosphorus?: number,
      minPotassium?: number,
      maxPotassium?: number,
      minSelenium?: number,
      maxSelenium?: number,
      minSodium?: number,
      maxSodium?: number,
      minSugar?: number,
      maxSugar?: number,
      minZinc?: number,
      maxZinc?: number,
      offset?: number,
      number?: number,
      random?: boolean,
      limitLicense?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Set<SearchRecipesByNutrients200ResponseInner>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.searchRecipesByNutrients(
          minCarbs,
          maxCarbs,
          minProtein,
          maxProtein,
          minCalories,
          maxCalories,
          minFat,
          maxFat,
          minAlcohol,
          maxAlcohol,
          minCaffeine,
          maxCaffeine,
          minCopper,
          maxCopper,
          minCalcium,
          maxCalcium,
          minCholine,
          maxCholine,
          minCholesterol,
          maxCholesterol,
          minFluoride,
          maxFluoride,
          minSaturatedFat,
          maxSaturatedFat,
          minVitaminA,
          maxVitaminA,
          minVitaminC,
          maxVitaminC,
          minVitaminD,
          maxVitaminD,
          minVitaminE,
          maxVitaminE,
          minVitaminK,
          maxVitaminK,
          minVitaminB1,
          maxVitaminB1,
          minVitaminB2,
          maxVitaminB2,
          minVitaminB5,
          maxVitaminB5,
          minVitaminB3,
          maxVitaminB3,
          minVitaminB6,
          maxVitaminB6,
          minVitaminB12,
          maxVitaminB12,
          minFiber,
          maxFiber,
          minFolate,
          maxFolate,
          minFolicAcid,
          maxFolicAcid,
          minIodine,
          maxIodine,
          minIron,
          maxIron,
          minMagnesium,
          maxMagnesium,
          minManganese,
          maxManganese,
          minPhosphorus,
          maxPhosphorus,
          minPotassium,
          maxPotassium,
          minSelenium,
          maxSelenium,
          minSodium,
          maxSodium,
          minSugar,
          maxSugar,
          minZinc,
          maxZinc,
          offset,
          number,
          random,
          limitLicense,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.searchRecipesByNutrients"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Automatically generate a short description that summarizes key information about the recipe.
     * @summary Summarize Recipe
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async summarizeRecipe(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SummarizeRecipe200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.summarizeRecipe(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.summarizeRecipe"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Visualize the equipment used to make a recipe.
     * @summary Equipment Widget
     * @param {VisualizeEquipmentContentTypeEnum} [contentType] The content type.
     * @param {VisualizeEquipmentAcceptEnum} [accept] Accept header.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async visualizeEquipment(
      contentType?: VisualizeEquipmentContentTypeEnum,
      accept?: VisualizeEquipmentAcceptEnum,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.visualizeEquipment(
          contentType,
          accept,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.visualizeEquipment"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Visualize the price breakdown of a recipe.
     * @summary Price Breakdown Widget
     * @param {VisualizePriceBreakdownContentTypeEnum} [contentType] The content type.
     * @param {VisualizePriceBreakdownAcceptEnum} [accept] Accept header.
     * @param {VisualizePriceBreakdownLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async visualizePriceBreakdown(
      contentType?: VisualizePriceBreakdownContentTypeEnum,
      accept?: VisualizePriceBreakdownAcceptEnum,
      language?: VisualizePriceBreakdownLanguageEnum,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.visualizePriceBreakdown(
          contentType,
          accept,
          language,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.visualizePriceBreakdown"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Visualize a recipe\'s equipment list.
     * @summary Equipment by ID Widget
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async visualizeRecipeEquipmentByID(
      id: number,
      defaultCss?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.visualizeRecipeEquipmentByID(
          id,
          defaultCss,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.visualizeRecipeEquipmentByID"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Visualize a recipe\'s ingredient list.
     * @summary Ingredients by ID Widget
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {VisualizeRecipeIngredientsByIDMeasureEnum} [measure] Whether the the measures should be \&#39;us\&#39; or \&#39;metric\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async visualizeRecipeIngredientsByID(
      id: number,
      defaultCss?: boolean,
      measure?: VisualizeRecipeIngredientsByIDMeasureEnum,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.visualizeRecipeIngredientsByID(
          id,
          defaultCss,
          measure,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.visualizeRecipeIngredientsByID"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Visualize a recipe\'s nutritional information as HTML including CSS.
     * @summary Recipe Nutrition Widget
     * @param {VisualizeRecipeNutritionContentTypeEnum} [contentType] The content type.
     * @param {VisualizeRecipeNutritionAcceptEnum} [accept] Accept header.
     * @param {VisualizeRecipeNutritionLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async visualizeRecipeNutrition(
      contentType?: VisualizeRecipeNutritionContentTypeEnum,
      accept?: VisualizeRecipeNutritionAcceptEnum,
      language?: VisualizeRecipeNutritionLanguageEnum,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.visualizeRecipeNutrition(
          contentType,
          accept,
          language,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.visualizeRecipeNutrition"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Visualize a recipe\'s nutritional information as HTML including CSS.
     * @summary Recipe Nutrition by ID Widget
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {VisualizeRecipeNutritionByIDAcceptEnum} [accept] Accept header.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async visualizeRecipeNutritionByID(
      id: number,
      defaultCss?: boolean,
      accept?: VisualizeRecipeNutritionByIDAcceptEnum,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.visualizeRecipeNutritionByID(
          id,
          defaultCss,
          accept,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.visualizeRecipeNutritionByID"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Visualize a recipe\'s price breakdown.
     * @summary Price Breakdown by ID Widget
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async visualizeRecipePriceBreakdownByID(
      id: number,
      defaultCss?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.visualizeRecipePriceBreakdownByID(
          id,
          defaultCss,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.visualizeRecipePriceBreakdownByID"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Visualize a recipe\'s taste information as HTML including CSS. You can play around with that endpoint!
     * @summary Recipe Taste Widget
     * @param {VisualizeRecipeTasteLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {VisualizeRecipeTasteContentTypeEnum} [contentType] The content type.
     * @param {VisualizeRecipeTasteAcceptEnum} [accept] Accept header.
     * @param {boolean} [normalize] Whether to normalize to the strongest taste.
     * @param {string} [rgb] Red, green, blue values for the chart color.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async visualizeRecipeTaste(
      language?: VisualizeRecipeTasteLanguageEnum,
      contentType?: VisualizeRecipeTasteContentTypeEnum,
      accept?: VisualizeRecipeTasteAcceptEnum,
      normalize?: boolean,
      rgb?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.visualizeRecipeTaste(
          language,
          contentType,
          accept,
          normalize,
          rgb,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.visualizeRecipeTaste"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a recipe\'s taste. The tastes supported are sweet, salty, sour, bitter, savory, and fatty.
     * @summary Recipe Taste by ID Widget
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [normalize] Whether to normalize to the strongest taste.
     * @param {string} [rgb] Red, green, blue values for the chart color.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async visualizeRecipeTasteByID(
      id: number,
      normalize?: boolean,
      rgb?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.visualizeRecipeTasteByID(
          id,
          normalize,
          rgb,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RecipesApi.visualizeRecipeTasteByID"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * RecipesApi - factory interface
 * @export
 */
export const RecipesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RecipesApiFp(configuration);
  return {
    /**
     * Parse a recipe search query to find out its intention.
     * @summary Analyze a Recipe Search Query
     * @param {string} q The recipe search query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    analyzeARecipeSearchQuery(
      q: string,
      options?: any
    ): AxiosPromise<AnalyzeARecipeSearchQuery200Response> {
      return localVarFp
        .analyzeARecipeSearchQuery(q, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint allows you to break down instructions into atomic steps. Furthermore, each step will contain the ingredients and equipment required. Additionally, all ingredients and equipment from the recipe\'s instructions will be extracted independently of the step they\'re used in.
     * @summary Analyze Recipe Instructions
     * @param {AnalyzeRecipeInstructionsContentTypeEnum} [contentType] The content type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    analyzeRecipeInstructions(
      contentType?: AnalyzeRecipeInstructionsContentTypeEnum,
      options?: any
    ): AxiosPromise<AnalyzeRecipeInstructions200Response> {
      return localVarFp
        .analyzeRecipeInstructions(contentType, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Autocomplete a partial input to suggest possible recipe names.
     * @summary Autocomplete Recipe Search
     * @param {string} [query] The (natural language) search query.
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autocompleteRecipeSearch(
      query?: string,
      number?: number,
      options?: any
    ): AxiosPromise<Set<AutocompleteRecipeSearch200ResponseInner>> {
      return localVarFp
        .autocompleteRecipeSearch(query, number, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Classify the recipe\'s cuisine.
     * @summary Classify Cuisine
     * @param {ClassifyCuisineContentTypeEnum} [contentType] The content type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    classifyCuisine(
      contentType?: ClassifyCuisineContentTypeEnum,
      options?: any
    ): AxiosPromise<ClassifyCuisine200Response> {
      return localVarFp
        .classifyCuisine(contentType, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve the glycemic index for a list of ingredients and compute the individual and total glycemic load.
     * @summary Compute Glycemic Load
     * @param {ComputeGlycemicLoadRequest} computeGlycemicLoadRequest
     * @param {ComputeGlycemicLoadLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    computeGlycemicLoad(
      computeGlycemicLoadRequest: ComputeGlycemicLoadRequest,
      language?: ComputeGlycemicLoadLanguageEnum,
      options?: any
    ): AxiosPromise<ComputeGlycemicLoad200Response> {
      return localVarFp
        .computeGlycemicLoad(computeGlycemicLoadRequest, language, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Convert amounts like \"2 cups of flour to grams\".
     * @summary Convert Amounts
     * @param {string} ingredientName The ingredient which you want to convert.
     * @param {number} sourceAmount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;.
     * @param {string} sourceUnit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot;
     * @param {string} targetUnit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    convertAmounts(
      ingredientName: string,
      sourceAmount: number,
      sourceUnit: string,
      targetUnit: string,
      options?: any
    ): AxiosPromise<ConvertAmounts200Response> {
      return localVarFp
        .convertAmounts(
          ingredientName,
          sourceAmount,
          sourceUnit,
          targetUnit,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Generate a recipe card for a recipe.
     * @summary Create Recipe Card
     * @param {CreateRecipeCardContentTypeEnum} [contentType] The content type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRecipeCard(
      contentType?: CreateRecipeCardContentTypeEnum,
      options?: any
    ): AxiosPromise<CreateRecipeCard200Response> {
      return localVarFp
        .createRecipeCard(contentType, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Visualize a recipe\'s equipment list as an image.
     * @summary Equipment by ID Image
     * @param {number} id The recipe id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    equipmentByIDImage(id: number, options?: any): AxiosPromise<object> {
      return localVarFp
        .equipmentByIDImage(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint lets you extract recipe data such as title, ingredients, and instructions from any properly formatted Website.
     * @summary Extract Recipe from Website
     * @param {string} url The URL of the recipe page.
     * @param {boolean} [forceExtraction] If true, the extraction will be triggered whether we already know the recipe or not. Use this only if information is missing as this operation is slower.
     * @param {boolean} [analyze] If true, the recipe will be analyzed and classified resolving in more data such as cuisines, dish types, and more.
     * @param {boolean} [includeNutrition] Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings.
     * @param {boolean} [includeTaste] Whether taste data should be added to correctly parsed ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    extractRecipeFromWebsite(
      url: string,
      forceExtraction?: boolean,
      analyze?: boolean,
      includeNutrition?: boolean,
      includeTaste?: boolean,
      options?: any
    ): AxiosPromise<GetRecipeInformation200Response> {
      return localVarFp
        .extractRecipeFromWebsite(
          url,
          forceExtraction,
          analyze,
          includeNutrition,
          includeTaste,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get an analyzed breakdown of a recipe\'s instructions. Each step is enriched with the ingredients and equipment required.
     * @summary Get Analyzed Recipe Instructions
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [stepBreakdown] Whether to break down the recipe steps even more.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalyzedRecipeInstructions(
      id: number,
      stepBreakdown?: boolean,
      options?: any
    ): AxiosPromise<GetAnalyzedRecipeInstructions200Response> {
      return localVarFp
        .getAnalyzedRecipeInstructions(id, stepBreakdown, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Find random (popular) recipes. If you need to filter recipes by diet, nutrition etc. you might want to consider using the complex recipe search endpoint and set the sort request parameter to random.
     * @summary Get Random Recipes
     * @param {boolean} [limitLicense] Whether the recipes should have an open license that allows display with proper attribution.
     * @param {string} [tags] The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have.
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRandomRecipes(
      limitLicense?: boolean,
      tags?: string,
      number?: number,
      options?: any
    ): AxiosPromise<GetRandomRecipes200Response> {
      return localVarFp
        .getRandomRecipes(limitLicense, tags, number, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a recipe\'s equipment list.
     * @summary Equipment by ID
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecipeEquipmentByID(
      id: number,
      options?: any
    ): AxiosPromise<GetRecipeEquipmentByID200Response> {
      return localVarFp
        .getRecipeEquipmentByID(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Use a recipe id to get full information about a recipe, such as ingredients, nutrition, diet and allergen information, etc.
     * @summary Get Recipe Information
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [includeNutrition] Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecipeInformation(
      id: number,
      includeNutrition?: boolean,
      options?: any
    ): AxiosPromise<GetRecipeInformation200Response> {
      return localVarFp
        .getRecipeInformation(id, includeNutrition, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get information about multiple recipes at once. This is equivalent to calling the Get Recipe Information endpoint multiple times, but faster.
     * @summary Get Recipe Information Bulk
     * @param {string} ids A comma-separated list of recipe ids.
     * @param {boolean} [includeNutrition] Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecipeInformationBulk(
      ids: string,
      includeNutrition?: boolean,
      options?: any
    ): AxiosPromise<Set<GetRecipeInformationBulk200ResponseInner>> {
      return localVarFp
        .getRecipeInformationBulk(ids, includeNutrition, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a recipe\'s ingredient list.
     * @summary Ingredients by ID
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecipeIngredientsByID(
      id: number,
      options?: any
    ): AxiosPromise<GetRecipeIngredientsByID200Response> {
      return localVarFp
        .getRecipeIngredientsByID(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a recipe\'s nutrition data.
     * @summary Nutrition by ID
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecipeNutritionWidgetByID(
      id: number,
      options?: any
    ): AxiosPromise<GetRecipeNutritionWidgetByID200Response> {
      return localVarFp
        .getRecipeNutritionWidgetByID(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a recipe\'s price breakdown data.
     * @summary Price Breakdown by ID
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecipePriceBreakdownByID(
      id: number,
      options?: any
    ): AxiosPromise<GetRecipePriceBreakdownByID200Response> {
      return localVarFp
        .getRecipePriceBreakdownByID(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a recipe\'s taste. The tastes supported are sweet, salty, sour, bitter, savory, and fatty.
     * @summary Taste by ID
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [normalize] Normalize to the strongest taste.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecipeTasteByID(
      id: number,
      normalize?: boolean,
      options?: any
    ): AxiosPromise<GetRecipeTasteByID200Response> {
      return localVarFp
        .getRecipeTasteByID(id, normalize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Find recipes which are similar to the given one.
     * @summary Get Similar Recipes
     * @param {number} id The item\&#39;s id.
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {boolean} [limitLicense] Whether the recipes should have an open license that allows display with proper attribution.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSimilarRecipes(
      id: number,
      number?: number,
      limitLicense?: boolean,
      options?: any
    ): AxiosPromise<Set<GetSimilarRecipes200ResponseInner>> {
      return localVarFp
        .getSimilarRecipes(id, number, limitLicense, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Estimate the macronutrients of a dish based on its title.
     * @summary Guess Nutrition by Dish Name
     * @param {string} title The title of the dish.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    guessNutritionByDishName(
      title: string,
      options?: any
    ): AxiosPromise<GuessNutritionByDishName200Response> {
      return localVarFp
        .guessNutritionByDishName(title, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Visualize a recipe\'s ingredient list.
     * @summary Ingredients by ID Image
     * @param {number} id The recipe id.
     * @param {IngredientsByIDImageMeasureEnum} [measure] Whether the the measures should be \&#39;us\&#39; or \&#39;metric\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ingredientsByIDImage(
      id: number,
      measure?: IngredientsByIDImageMeasureEnum,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .ingredientsByIDImage(id, measure, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Extract an ingredient from plain text.
     * @summary Parse Ingredients
     * @param {ParseIngredientsContentTypeEnum} [contentType] The content type.
     * @param {ParseIngredientsLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    parseIngredients(
      contentType?: ParseIngredientsContentTypeEnum,
      language?: ParseIngredientsLanguageEnum,
      options?: any
    ): AxiosPromise<Set<ParseIngredients200ResponseInner>> {
      return localVarFp
        .parseIngredients(contentType, language, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Visualize a recipe\'s price breakdown.
     * @summary Price Breakdown by ID Image
     * @param {number} id The recipe id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    priceBreakdownByIDImage(id: number, options?: any): AxiosPromise<object> {
      return localVarFp
        .priceBreakdownByIDImage(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Answer a nutrition related natural language question.
     * @summary Quick Answer
     * @param {string} q The nutrition related question.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    quickAnswer(
      q: string,
      options?: any
    ): AxiosPromise<QuickAnswer200Response> {
      return localVarFp
        .quickAnswer(q, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Visualize a recipe\'s nutritional information as an image.
     * @summary Recipe Nutrition by ID Image
     * @param {number} id The recipe id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recipeNutritionByIDImage(id: number, options?: any): AxiosPromise<object> {
      return localVarFp
        .recipeNutritionByIDImage(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a recipe\'s nutrition label as an image.
     * @summary Recipe Nutrition Label Image
     * @param {number} id The recipe id.
     * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
     * @param {boolean} [showZeroValues] Whether to show zero values.
     * @param {boolean} [showIngredients] Whether to show a list of ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recipeNutritionLabelImage(
      id: number,
      showOptionalNutrients?: boolean,
      showZeroValues?: boolean,
      showIngredients?: boolean,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .recipeNutritionLabelImage(
          id,
          showOptionalNutrients,
          showZeroValues,
          showIngredients,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a recipe\'s nutrition label as an HTML widget.
     * @summary Recipe Nutrition Label Widget
     * @param {number} id The recipe id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
     * @param {boolean} [showZeroValues] Whether to show zero values.
     * @param {boolean} [showIngredients] Whether to show a list of ingredients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recipeNutritionLabelWidget(
      id: number,
      defaultCss?: boolean,
      showOptionalNutrients?: boolean,
      showZeroValues?: boolean,
      showIngredients?: boolean,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .recipeNutritionLabelWidget(
          id,
          defaultCss,
          showOptionalNutrients,
          showZeroValues,
          showIngredients,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a recipe\'s taste as an image. The tastes supported are sweet, salty, sour, bitter, savory, and fatty.
     * @summary Recipe Taste by ID Image
     * @param {number} id The recipe id.
     * @param {boolean} [normalize] Normalize to the strongest taste.
     * @param {string} [rgb] Red, green, blue values for the chart color.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recipeTasteByIDImage(
      id: number,
      normalize?: boolean,
      rgb?: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .recipeTasteByIDImage(id, normalize, rgb, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Search through hundreds of thousands of recipes using advanced filtering and ranking. NOTE: This method combines searching by query, by ingredients, and by nutrients into one endpoint.
     * @summary Search Recipes
     * @param {string} [query] The (natural language) search query.
     * @param {string} [cuisine] The cuisine(s) of the recipes. One or more, comma separated (will be interpreted as \&#39;OR\&#39;). See a full list of supported cuisines.
     * @param {string} [excludeCuisine] The cuisine(s) the recipes must not match. One or more, comma separated (will be interpreted as \&#39;AND\&#39;). See a full list of supported cuisines.
     * @param {string} [diet] The diet for which the recipes must be suitable. See a full list of supported diets.
     * @param {string} [intolerances] A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.
     * @param {string} [equipment] The equipment required. Multiple values will be interpreted as \&#39;or\&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;.
     * @param {string} [includeIngredients] A comma-separated list of ingredients that should/must be used in the recipes.
     * @param {string} [excludeIngredients] A comma-separated list of ingredients or ingredient types that the recipes must not contain.
     * @param {string} [type] The type of recipe. See a full list of supported meal types.
     * @param {boolean} [instructionsRequired] Whether the recipes must have instructions.
     * @param {boolean} [fillIngredients] Add information about the ingredients and whether they are used or missing in relation to the query.
     * @param {boolean} [addRecipeInformation] If set to true, you get more information about the recipes returned.
     * @param {boolean} [addRecipeNutrition] If set to true, you get nutritional information about each recipes returned.
     * @param {string} [author] The username of the recipe author.
     * @param {string} [tags] The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have.
     * @param {number} [recipeBoxId] The id of the recipe box to which the search should be limited to.
     * @param {string} [titleMatch] Enter text that must be found in the title of the recipes.
     * @param {number} [maxReadyTime] The maximum time in minutes it should take to prepare and cook the recipe.
     * @param {boolean} [ignorePantry] Whether to ignore typical pantry items, such as water, salt, flour, etc.
     * @param {string} [sort] The strategy to sort recipes by. See a full list of supported sorting options.
     * @param {string} [sortDirection] The direction in which to sort. Must be either \&#39;asc\&#39; (ascending) or \&#39;desc\&#39; (descending).
     * @param {number} [minCarbs] The minimum amount of carbohydrates in grams the recipe must have.
     * @param {number} [maxCarbs] The maximum amount of carbohydrates in grams the recipe can have.
     * @param {number} [minProtein] The minimum amount of protein in grams the recipe must have.
     * @param {number} [maxProtein] The maximum amount of protein in grams the recipe can have.
     * @param {number} [minCalories] The minimum amount of calories the recipe must have.
     * @param {number} [maxCalories] The maximum amount of calories the recipe can have.
     * @param {number} [minFat] The minimum amount of fat in grams the recipe must have.
     * @param {number} [maxFat] The maximum amount of fat in grams the recipe can have.
     * @param {number} [minAlcohol] The minimum amount of alcohol in grams the recipe must have.
     * @param {number} [maxAlcohol] The maximum amount of alcohol in grams the recipe can have.
     * @param {number} [minCaffeine] The minimum amount of caffeine in milligrams the recipe must have.
     * @param {number} [maxCaffeine] The maximum amount of caffeine in milligrams the recipe can have.
     * @param {number} [minCopper] The minimum amount of copper in milligrams the recipe must have.
     * @param {number} [maxCopper] The maximum amount of copper in milligrams the recipe can have.
     * @param {number} [minCalcium] The minimum amount of calcium in milligrams the recipe must have.
     * @param {number} [maxCalcium] The maximum amount of calcium in milligrams the recipe can have.
     * @param {number} [minCholine] The minimum amount of choline in milligrams the recipe must have.
     * @param {number} [maxCholine] The maximum amount of choline in milligrams the recipe can have.
     * @param {number} [minCholesterol] The minimum amount of cholesterol in milligrams the recipe must have.
     * @param {number} [maxCholesterol] The maximum amount of cholesterol in milligrams the recipe can have.
     * @param {number} [minFluoride] The minimum amount of fluoride in milligrams the recipe must have.
     * @param {number} [maxFluoride] The maximum amount of fluoride in milligrams the recipe can have.
     * @param {number} [minSaturatedFat] The minimum amount of saturated fat in grams the recipe must have.
     * @param {number} [maxSaturatedFat] The maximum amount of saturated fat in grams the recipe can have.
     * @param {number} [minVitaminA] The minimum amount of Vitamin A in IU the recipe must have.
     * @param {number} [maxVitaminA] The maximum amount of Vitamin A in IU the recipe can have.
     * @param {number} [minVitaminC] The minimum amount of Vitamin C milligrams the recipe must have.
     * @param {number} [maxVitaminC] The maximum amount of Vitamin C in milligrams the recipe can have.
     * @param {number} [minVitaminD] The minimum amount of Vitamin D in micrograms the recipe must have.
     * @param {number} [maxVitaminD] The maximum amount of Vitamin D in micrograms the recipe can have.
     * @param {number} [minVitaminE] The minimum amount of Vitamin E in milligrams the recipe must have.
     * @param {number} [maxVitaminE] The maximum amount of Vitamin E in milligrams the recipe can have.
     * @param {number} [minVitaminK] The minimum amount of Vitamin K in micrograms the recipe must have.
     * @param {number} [maxVitaminK] The maximum amount of Vitamin K in micrograms the recipe can have.
     * @param {number} [minVitaminB1] The minimum amount of Vitamin B1 in milligrams the recipe must have.
     * @param {number} [maxVitaminB1] The maximum amount of Vitamin B1 in milligrams the recipe can have.
     * @param {number} [minVitaminB2] The minimum amount of Vitamin B2 in milligrams the recipe must have.
     * @param {number} [maxVitaminB2] The maximum amount of Vitamin B2 in milligrams the recipe can have.
     * @param {number} [minVitaminB5] The minimum amount of Vitamin B5 in milligrams the recipe must have.
     * @param {number} [maxVitaminB5] The maximum amount of Vitamin B5 in milligrams the recipe can have.
     * @param {number} [minVitaminB3] The minimum amount of Vitamin B3 in milligrams the recipe must have.
     * @param {number} [maxVitaminB3] The maximum amount of Vitamin B3 in milligrams the recipe can have.
     * @param {number} [minVitaminB6] The minimum amount of Vitamin B6 in milligrams the recipe must have.
     * @param {number} [maxVitaminB6] The maximum amount of Vitamin B6 in milligrams the recipe can have.
     * @param {number} [minVitaminB12] The minimum amount of Vitamin B12 in micrograms the recipe must have.
     * @param {number} [maxVitaminB12] The maximum amount of Vitamin B12 in micrograms the recipe can have.
     * @param {number} [minFiber] The minimum amount of fiber in grams the recipe must have.
     * @param {number} [maxFiber] The maximum amount of fiber in grams the recipe can have.
     * @param {number} [minFolate] The minimum amount of folate in micrograms the recipe must have.
     * @param {number} [maxFolate] The maximum amount of folate in micrograms the recipe can have.
     * @param {number} [minFolicAcid] The minimum amount of folic acid in micrograms the recipe must have.
     * @param {number} [maxFolicAcid] The maximum amount of folic acid in micrograms the recipe can have.
     * @param {number} [minIodine] The minimum amount of iodine in micrograms the recipe must have.
     * @param {number} [maxIodine] The maximum amount of iodine in micrograms the recipe can have.
     * @param {number} [minIron] The minimum amount of iron in milligrams the recipe must have.
     * @param {number} [maxIron] The maximum amount of iron in milligrams the recipe can have.
     * @param {number} [minMagnesium] The minimum amount of magnesium in milligrams the recipe must have.
     * @param {number} [maxMagnesium] The maximum amount of magnesium in milligrams the recipe can have.
     * @param {number} [minManganese] The minimum amount of manganese in milligrams the recipe must have.
     * @param {number} [maxManganese] The maximum amount of manganese in milligrams the recipe can have.
     * @param {number} [minPhosphorus] The minimum amount of phosphorus in milligrams the recipe must have.
     * @param {number} [maxPhosphorus] The maximum amount of phosphorus in milligrams the recipe can have.
     * @param {number} [minPotassium] The minimum amount of potassium in milligrams the recipe must have.
     * @param {number} [maxPotassium] The maximum amount of potassium in milligrams the recipe can have.
     * @param {number} [minSelenium] The minimum amount of selenium in micrograms the recipe must have.
     * @param {number} [maxSelenium] The maximum amount of selenium in micrograms the recipe can have.
     * @param {number} [minSodium] The minimum amount of sodium in milligrams the recipe must have.
     * @param {number} [maxSodium] The maximum amount of sodium in milligrams the recipe can have.
     * @param {number} [minSugar] The minimum amount of sugar in grams the recipe must have.
     * @param {number} [maxSugar] The maximum amount of sugar in grams the recipe can have.
     * @param {number} [minZinc] The minimum amount of zinc in milligrams the recipe must have.
     * @param {number} [maxZinc] The maximum amount of zinc in milligrams the recipe can have.
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {boolean} [limitLicense] Whether the recipes should have an open license that allows display with proper attribution.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchRecipes(
      query?: string,
      cuisine?: string,
      excludeCuisine?: string,
      diet?: string,
      intolerances?: string,
      equipment?: string,
      includeIngredients?: string,
      excludeIngredients?: string,
      type?: string,
      instructionsRequired?: boolean,
      fillIngredients?: boolean,
      addRecipeInformation?: boolean,
      addRecipeNutrition?: boolean,
      author?: string,
      tags?: string,
      recipeBoxId?: number,
      titleMatch?: string,
      maxReadyTime?: number,
      ignorePantry?: boolean,
      sort?: string,
      sortDirection?: string,
      minCarbs?: number,
      maxCarbs?: number,
      minProtein?: number,
      maxProtein?: number,
      minCalories?: number,
      maxCalories?: number,
      minFat?: number,
      maxFat?: number,
      minAlcohol?: number,
      maxAlcohol?: number,
      minCaffeine?: number,
      maxCaffeine?: number,
      minCopper?: number,
      maxCopper?: number,
      minCalcium?: number,
      maxCalcium?: number,
      minCholine?: number,
      maxCholine?: number,
      minCholesterol?: number,
      maxCholesterol?: number,
      minFluoride?: number,
      maxFluoride?: number,
      minSaturatedFat?: number,
      maxSaturatedFat?: number,
      minVitaminA?: number,
      maxVitaminA?: number,
      minVitaminC?: number,
      maxVitaminC?: number,
      minVitaminD?: number,
      maxVitaminD?: number,
      minVitaminE?: number,
      maxVitaminE?: number,
      minVitaminK?: number,
      maxVitaminK?: number,
      minVitaminB1?: number,
      maxVitaminB1?: number,
      minVitaminB2?: number,
      maxVitaminB2?: number,
      minVitaminB5?: number,
      maxVitaminB5?: number,
      minVitaminB3?: number,
      maxVitaminB3?: number,
      minVitaminB6?: number,
      maxVitaminB6?: number,
      minVitaminB12?: number,
      maxVitaminB12?: number,
      minFiber?: number,
      maxFiber?: number,
      minFolate?: number,
      maxFolate?: number,
      minFolicAcid?: number,
      maxFolicAcid?: number,
      minIodine?: number,
      maxIodine?: number,
      minIron?: number,
      maxIron?: number,
      minMagnesium?: number,
      maxMagnesium?: number,
      minManganese?: number,
      maxManganese?: number,
      minPhosphorus?: number,
      maxPhosphorus?: number,
      minPotassium?: number,
      maxPotassium?: number,
      minSelenium?: number,
      maxSelenium?: number,
      minSodium?: number,
      maxSodium?: number,
      minSugar?: number,
      maxSugar?: number,
      minZinc?: number,
      maxZinc?: number,
      offset?: number,
      number?: number,
      limitLicense?: boolean,
      options?: any
    ): AxiosPromise<SearchRecipes200Response> {
      return localVarFp
        .searchRecipes(
          query,
          cuisine,
          excludeCuisine,
          diet,
          intolerances,
          equipment,
          includeIngredients,
          excludeIngredients,
          type,
          instructionsRequired,
          fillIngredients,
          addRecipeInformation,
          addRecipeNutrition,
          author,
          tags,
          recipeBoxId,
          titleMatch,
          maxReadyTime,
          ignorePantry,
          sort,
          sortDirection,
          minCarbs,
          maxCarbs,
          minProtein,
          maxProtein,
          minCalories,
          maxCalories,
          minFat,
          maxFat,
          minAlcohol,
          maxAlcohol,
          minCaffeine,
          maxCaffeine,
          minCopper,
          maxCopper,
          minCalcium,
          maxCalcium,
          minCholine,
          maxCholine,
          minCholesterol,
          maxCholesterol,
          minFluoride,
          maxFluoride,
          minSaturatedFat,
          maxSaturatedFat,
          minVitaminA,
          maxVitaminA,
          minVitaminC,
          maxVitaminC,
          minVitaminD,
          maxVitaminD,
          minVitaminE,
          maxVitaminE,
          minVitaminK,
          maxVitaminK,
          minVitaminB1,
          maxVitaminB1,
          minVitaminB2,
          maxVitaminB2,
          minVitaminB5,
          maxVitaminB5,
          minVitaminB3,
          maxVitaminB3,
          minVitaminB6,
          maxVitaminB6,
          minVitaminB12,
          maxVitaminB12,
          minFiber,
          maxFiber,
          minFolate,
          maxFolate,
          minFolicAcid,
          maxFolicAcid,
          minIodine,
          maxIodine,
          minIron,
          maxIron,
          minMagnesium,
          maxMagnesium,
          minManganese,
          maxManganese,
          minPhosphorus,
          maxPhosphorus,
          minPotassium,
          maxPotassium,
          minSelenium,
          maxSelenium,
          minSodium,
          maxSodium,
          minSugar,
          maxSugar,
          minZinc,
          maxZinc,
          offset,
          number,
          limitLicense,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *  Ever wondered what recipes you can cook with the ingredients you have in your fridge or pantry? This endpoint lets you find recipes that either maximize the usage of ingredients you have at hand (pre shopping) or minimize the ingredients that you don\'t currently have (post shopping).
     * @summary Search Recipes by Ingredients
     * @param {string} [ingredients] A comma-separated list of ingredients that the recipes should contain.
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {boolean} [limitLicense] Whether the recipes should have an open license that allows display with proper attribution.
     * @param {number} [ranking] Whether to maximize used ingredients (1) or minimize missing ingredients (2) first.
     * @param {boolean} [ignorePantry] Whether to ignore typical pantry items, such as water, salt, flour, etc.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchRecipesByIngredients(
      ingredients?: string,
      number?: number,
      limitLicense?: boolean,
      ranking?: number,
      ignorePantry?: boolean,
      options?: any
    ): AxiosPromise<Set<SearchRecipesByIngredients200ResponseInner>> {
      return localVarFp
        .searchRecipesByIngredients(
          ingredients,
          number,
          limitLicense,
          ranking,
          ignorePantry,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Find a set of recipes that adhere to the given nutritional limits. You may set limits for macronutrients (calories, protein, fat, and carbohydrate) and/or many micronutrients.
     * @summary Search Recipes by Nutrients
     * @param {number} [minCarbs] The minimum amount of carbohydrates in grams the recipe must have.
     * @param {number} [maxCarbs] The maximum amount of carbohydrates in grams the recipe can have.
     * @param {number} [minProtein] The minimum amount of protein in grams the recipe must have.
     * @param {number} [maxProtein] The maximum amount of protein in grams the recipe can have.
     * @param {number} [minCalories] The minimum amount of calories the recipe must have.
     * @param {number} [maxCalories] The maximum amount of calories the recipe can have.
     * @param {number} [minFat] The minimum amount of fat in grams the recipe must have.
     * @param {number} [maxFat] The maximum amount of fat in grams the recipe can have.
     * @param {number} [minAlcohol] The minimum amount of alcohol in grams the recipe must have.
     * @param {number} [maxAlcohol] The maximum amount of alcohol in grams the recipe can have.
     * @param {number} [minCaffeine] The minimum amount of caffeine in milligrams the recipe must have.
     * @param {number} [maxCaffeine] The maximum amount of caffeine in milligrams the recipe can have.
     * @param {number} [minCopper] The minimum amount of copper in milligrams the recipe must have.
     * @param {number} [maxCopper] The maximum amount of copper in milligrams the recipe can have.
     * @param {number} [minCalcium] The minimum amount of calcium in milligrams the recipe must have.
     * @param {number} [maxCalcium] The maximum amount of calcium in milligrams the recipe can have.
     * @param {number} [minCholine] The minimum amount of choline in milligrams the recipe must have.
     * @param {number} [maxCholine] The maximum amount of choline in milligrams the recipe can have.
     * @param {number} [minCholesterol] The minimum amount of cholesterol in milligrams the recipe must have.
     * @param {number} [maxCholesterol] The maximum amount of cholesterol in milligrams the recipe can have.
     * @param {number} [minFluoride] The minimum amount of fluoride in milligrams the recipe must have.
     * @param {number} [maxFluoride] The maximum amount of fluoride in milligrams the recipe can have.
     * @param {number} [minSaturatedFat] The minimum amount of saturated fat in grams the recipe must have.
     * @param {number} [maxSaturatedFat] The maximum amount of saturated fat in grams the recipe can have.
     * @param {number} [minVitaminA] The minimum amount of Vitamin A in IU the recipe must have.
     * @param {number} [maxVitaminA] The maximum amount of Vitamin A in IU the recipe can have.
     * @param {number} [minVitaminC] The minimum amount of Vitamin C in milligrams the recipe must have.
     * @param {number} [maxVitaminC] The maximum amount of Vitamin C in milligrams the recipe can have.
     * @param {number} [minVitaminD] The minimum amount of Vitamin D in micrograms the recipe must have.
     * @param {number} [maxVitaminD] The maximum amount of Vitamin D in micrograms the recipe can have.
     * @param {number} [minVitaminE] The minimum amount of Vitamin E in milligrams the recipe must have.
     * @param {number} [maxVitaminE] The maximum amount of Vitamin E in milligrams the recipe can have.
     * @param {number} [minVitaminK] The minimum amount of Vitamin K in micrograms the recipe must have.
     * @param {number} [maxVitaminK] The maximum amount of Vitamin K in micrograms the recipe can have.
     * @param {number} [minVitaminB1] The minimum amount of Vitamin B1 in milligrams the recipe must have.
     * @param {number} [maxVitaminB1] The maximum amount of Vitamin B1 in milligrams the recipe can have.
     * @param {number} [minVitaminB2] The minimum amount of Vitamin B2 in milligrams the recipe must have.
     * @param {number} [maxVitaminB2] The maximum amount of Vitamin B2 in milligrams the recipe can have.
     * @param {number} [minVitaminB5] The minimum amount of Vitamin B5 in milligrams the recipe must have.
     * @param {number} [maxVitaminB5] The maximum amount of Vitamin B5 in milligrams the recipe can have.
     * @param {number} [minVitaminB3] The minimum amount of Vitamin B3 in milligrams the recipe must have.
     * @param {number} [maxVitaminB3] The maximum amount of Vitamin B3 in milligrams the recipe can have.
     * @param {number} [minVitaminB6] The minimum amount of Vitamin B6 in milligrams the recipe must have.
     * @param {number} [maxVitaminB6] The maximum amount of Vitamin B6 in milligrams the recipe can have.
     * @param {number} [minVitaminB12] The minimum amount of Vitamin B12 in micrograms the recipe must have.
     * @param {number} [maxVitaminB12] The maximum amount of Vitamin B12 in micrograms the recipe can have.
     * @param {number} [minFiber] The minimum amount of fiber in grams the recipe must have.
     * @param {number} [maxFiber] The maximum amount of fiber in grams the recipe can have.
     * @param {number} [minFolate] The minimum amount of folate in micrograms the recipe must have.
     * @param {number} [maxFolate] The maximum amount of folate in micrograms the recipe can have.
     * @param {number} [minFolicAcid] The minimum amount of folic acid in micrograms the recipe must have.
     * @param {number} [maxFolicAcid] The maximum amount of folic acid in micrograms the recipe can have.
     * @param {number} [minIodine] The minimum amount of iodine in micrograms the recipe must have.
     * @param {number} [maxIodine] The maximum amount of iodine in micrograms the recipe can have.
     * @param {number} [minIron] The minimum amount of iron in milligrams the recipe must have.
     * @param {number} [maxIron] The maximum amount of iron in milligrams the recipe can have.
     * @param {number} [minMagnesium] The minimum amount of magnesium in milligrams the recipe must have.
     * @param {number} [maxMagnesium] The maximum amount of magnesium in milligrams the recipe can have.
     * @param {number} [minManganese] The minimum amount of manganese in milligrams the recipe must have.
     * @param {number} [maxManganese] The maximum amount of manganese in milligrams the recipe can have.
     * @param {number} [minPhosphorus] The minimum amount of phosphorus in milligrams the recipe must have.
     * @param {number} [maxPhosphorus] The maximum amount of phosphorus in milligrams the recipe can have.
     * @param {number} [minPotassium] The minimum amount of potassium in milligrams the recipe must have.
     * @param {number} [maxPotassium] The maximum amount of potassium in milligrams the recipe can have.
     * @param {number} [minSelenium] The minimum amount of selenium in micrograms the recipe must have.
     * @param {number} [maxSelenium] The maximum amount of selenium in micrograms the recipe can have.
     * @param {number} [minSodium] The minimum amount of sodium in milligrams the recipe must have.
     * @param {number} [maxSodium] The maximum amount of sodium in milligrams the recipe can have.
     * @param {number} [minSugar] The minimum amount of sugar in grams the recipe must have.
     * @param {number} [maxSugar] The maximum amount of sugar in grams the recipe can have.
     * @param {number} [minZinc] The minimum amount of zinc in milligrams the recipe must have.
     * @param {number} [maxZinc] The maximum amount of zinc in milligrams the recipe can have.
     * @param {number} [offset] The number of results to skip (between 0 and 900).
     * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
     * @param {boolean} [random] If true, every request will give you a random set of recipes within the requested limits.
     * @param {boolean} [limitLicense] Whether the recipes should have an open license that allows display with proper attribution.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchRecipesByNutrients(
      minCarbs?: number,
      maxCarbs?: number,
      minProtein?: number,
      maxProtein?: number,
      minCalories?: number,
      maxCalories?: number,
      minFat?: number,
      maxFat?: number,
      minAlcohol?: number,
      maxAlcohol?: number,
      minCaffeine?: number,
      maxCaffeine?: number,
      minCopper?: number,
      maxCopper?: number,
      minCalcium?: number,
      maxCalcium?: number,
      minCholine?: number,
      maxCholine?: number,
      minCholesterol?: number,
      maxCholesterol?: number,
      minFluoride?: number,
      maxFluoride?: number,
      minSaturatedFat?: number,
      maxSaturatedFat?: number,
      minVitaminA?: number,
      maxVitaminA?: number,
      minVitaminC?: number,
      maxVitaminC?: number,
      minVitaminD?: number,
      maxVitaminD?: number,
      minVitaminE?: number,
      maxVitaminE?: number,
      minVitaminK?: number,
      maxVitaminK?: number,
      minVitaminB1?: number,
      maxVitaminB1?: number,
      minVitaminB2?: number,
      maxVitaminB2?: number,
      minVitaminB5?: number,
      maxVitaminB5?: number,
      minVitaminB3?: number,
      maxVitaminB3?: number,
      minVitaminB6?: number,
      maxVitaminB6?: number,
      minVitaminB12?: number,
      maxVitaminB12?: number,
      minFiber?: number,
      maxFiber?: number,
      minFolate?: number,
      maxFolate?: number,
      minFolicAcid?: number,
      maxFolicAcid?: number,
      minIodine?: number,
      maxIodine?: number,
      minIron?: number,
      maxIron?: number,
      minMagnesium?: number,
      maxMagnesium?: number,
      minManganese?: number,
      maxManganese?: number,
      minPhosphorus?: number,
      maxPhosphorus?: number,
      minPotassium?: number,
      maxPotassium?: number,
      minSelenium?: number,
      maxSelenium?: number,
      minSodium?: number,
      maxSodium?: number,
      minSugar?: number,
      maxSugar?: number,
      minZinc?: number,
      maxZinc?: number,
      offset?: number,
      number?: number,
      random?: boolean,
      limitLicense?: boolean,
      options?: any
    ): AxiosPromise<Set<SearchRecipesByNutrients200ResponseInner>> {
      return localVarFp
        .searchRecipesByNutrients(
          minCarbs,
          maxCarbs,
          minProtein,
          maxProtein,
          minCalories,
          maxCalories,
          minFat,
          maxFat,
          minAlcohol,
          maxAlcohol,
          minCaffeine,
          maxCaffeine,
          minCopper,
          maxCopper,
          minCalcium,
          maxCalcium,
          minCholine,
          maxCholine,
          minCholesterol,
          maxCholesterol,
          minFluoride,
          maxFluoride,
          minSaturatedFat,
          maxSaturatedFat,
          minVitaminA,
          maxVitaminA,
          minVitaminC,
          maxVitaminC,
          minVitaminD,
          maxVitaminD,
          minVitaminE,
          maxVitaminE,
          minVitaminK,
          maxVitaminK,
          minVitaminB1,
          maxVitaminB1,
          minVitaminB2,
          maxVitaminB2,
          minVitaminB5,
          maxVitaminB5,
          minVitaminB3,
          maxVitaminB3,
          minVitaminB6,
          maxVitaminB6,
          minVitaminB12,
          maxVitaminB12,
          minFiber,
          maxFiber,
          minFolate,
          maxFolate,
          minFolicAcid,
          maxFolicAcid,
          minIodine,
          maxIodine,
          minIron,
          maxIron,
          minMagnesium,
          maxMagnesium,
          minManganese,
          maxManganese,
          minPhosphorus,
          maxPhosphorus,
          minPotassium,
          maxPotassium,
          minSelenium,
          maxSelenium,
          minSodium,
          maxSodium,
          minSugar,
          maxSugar,
          minZinc,
          maxZinc,
          offset,
          number,
          random,
          limitLicense,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Automatically generate a short description that summarizes key information about the recipe.
     * @summary Summarize Recipe
     * @param {number} id The item\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    summarizeRecipe(
      id: number,
      options?: any
    ): AxiosPromise<SummarizeRecipe200Response> {
      return localVarFp
        .summarizeRecipe(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Visualize the equipment used to make a recipe.
     * @summary Equipment Widget
     * @param {VisualizeEquipmentContentTypeEnum} [contentType] The content type.
     * @param {VisualizeEquipmentAcceptEnum} [accept] Accept header.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizeEquipment(
      contentType?: VisualizeEquipmentContentTypeEnum,
      accept?: VisualizeEquipmentAcceptEnum,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .visualizeEquipment(contentType, accept, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Visualize the price breakdown of a recipe.
     * @summary Price Breakdown Widget
     * @param {VisualizePriceBreakdownContentTypeEnum} [contentType] The content type.
     * @param {VisualizePriceBreakdownAcceptEnum} [accept] Accept header.
     * @param {VisualizePriceBreakdownLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizePriceBreakdown(
      contentType?: VisualizePriceBreakdownContentTypeEnum,
      accept?: VisualizePriceBreakdownAcceptEnum,
      language?: VisualizePriceBreakdownLanguageEnum,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .visualizePriceBreakdown(contentType, accept, language, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Visualize a recipe\'s equipment list.
     * @summary Equipment by ID Widget
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizeRecipeEquipmentByID(
      id: number,
      defaultCss?: boolean,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .visualizeRecipeEquipmentByID(id, defaultCss, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Visualize a recipe\'s ingredient list.
     * @summary Ingredients by ID Widget
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {VisualizeRecipeIngredientsByIDMeasureEnum} [measure] Whether the the measures should be \&#39;us\&#39; or \&#39;metric\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizeRecipeIngredientsByID(
      id: number,
      defaultCss?: boolean,
      measure?: VisualizeRecipeIngredientsByIDMeasureEnum,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .visualizeRecipeIngredientsByID(id, defaultCss, measure, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Visualize a recipe\'s nutritional information as HTML including CSS.
     * @summary Recipe Nutrition Widget
     * @param {VisualizeRecipeNutritionContentTypeEnum} [contentType] The content type.
     * @param {VisualizeRecipeNutritionAcceptEnum} [accept] Accept header.
     * @param {VisualizeRecipeNutritionLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizeRecipeNutrition(
      contentType?: VisualizeRecipeNutritionContentTypeEnum,
      accept?: VisualizeRecipeNutritionAcceptEnum,
      language?: VisualizeRecipeNutritionLanguageEnum,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .visualizeRecipeNutrition(contentType, accept, language, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Visualize a recipe\'s nutritional information as HTML including CSS.
     * @summary Recipe Nutrition by ID Widget
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {VisualizeRecipeNutritionByIDAcceptEnum} [accept] Accept header.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizeRecipeNutritionByID(
      id: number,
      defaultCss?: boolean,
      accept?: VisualizeRecipeNutritionByIDAcceptEnum,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .visualizeRecipeNutritionByID(id, defaultCss, accept, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Visualize a recipe\'s price breakdown.
     * @summary Price Breakdown by ID Widget
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizeRecipePriceBreakdownByID(
      id: number,
      defaultCss?: boolean,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .visualizeRecipePriceBreakdownByID(id, defaultCss, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Visualize a recipe\'s taste information as HTML including CSS. You can play around with that endpoint!
     * @summary Recipe Taste Widget
     * @param {VisualizeRecipeTasteLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
     * @param {VisualizeRecipeTasteContentTypeEnum} [contentType] The content type.
     * @param {VisualizeRecipeTasteAcceptEnum} [accept] Accept header.
     * @param {boolean} [normalize] Whether to normalize to the strongest taste.
     * @param {string} [rgb] Red, green, blue values for the chart color.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizeRecipeTaste(
      language?: VisualizeRecipeTasteLanguageEnum,
      contentType?: VisualizeRecipeTasteContentTypeEnum,
      accept?: VisualizeRecipeTasteAcceptEnum,
      normalize?: boolean,
      rgb?: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .visualizeRecipeTaste(
          language,
          contentType,
          accept,
          normalize,
          rgb,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a recipe\'s taste. The tastes supported are sweet, salty, sour, bitter, savory, and fatty.
     * @summary Recipe Taste by ID Widget
     * @param {number} id The item\&#39;s id.
     * @param {boolean} [normalize] Whether to normalize to the strongest taste.
     * @param {string} [rgb] Red, green, blue values for the chart color.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    visualizeRecipeTasteByID(
      id: number,
      normalize?: boolean,
      rgb?: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .visualizeRecipeTasteByID(id, normalize, rgb, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RecipesApi - object-oriented interface
 * @export
 * @class RecipesApi
 * @extends {BaseAPI}
 */
export class RecipesApi extends BaseAPI {
  /**
   * Parse a recipe search query to find out its intention.
   * @summary Analyze a Recipe Search Query
   * @param {string} q The recipe search query.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public analyzeARecipeSearchQuery(q: string, options?: RawAxiosRequestConfig) {
    return RecipesApiFp(this.configuration)
      .analyzeARecipeSearchQuery(q, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint allows you to break down instructions into atomic steps. Furthermore, each step will contain the ingredients and equipment required. Additionally, all ingredients and equipment from the recipe\'s instructions will be extracted independently of the step they\'re used in.
   * @summary Analyze Recipe Instructions
   * @param {AnalyzeRecipeInstructionsContentTypeEnum} [contentType] The content type.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public analyzeRecipeInstructions(
    contentType?: AnalyzeRecipeInstructionsContentTypeEnum,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .analyzeRecipeInstructions(contentType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Autocomplete a partial input to suggest possible recipe names.
   * @summary Autocomplete Recipe Search
   * @param {string} [query] The (natural language) search query.
   * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public autocompleteRecipeSearch(
    query?: string,
    number?: number,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .autocompleteRecipeSearch(query, number, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Classify the recipe\'s cuisine.
   * @summary Classify Cuisine
   * @param {ClassifyCuisineContentTypeEnum} [contentType] The content type.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public classifyCuisine(
    contentType?: ClassifyCuisineContentTypeEnum,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .classifyCuisine(contentType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve the glycemic index for a list of ingredients and compute the individual and total glycemic load.
   * @summary Compute Glycemic Load
   * @param {ComputeGlycemicLoadRequest} computeGlycemicLoadRequest
   * @param {ComputeGlycemicLoadLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public computeGlycemicLoad(
    computeGlycemicLoadRequest: ComputeGlycemicLoadRequest,
    language?: ComputeGlycemicLoadLanguageEnum,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .computeGlycemicLoad(computeGlycemicLoadRequest, language, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Convert amounts like \"2 cups of flour to grams\".
   * @summary Convert Amounts
   * @param {string} ingredientName The ingredient which you want to convert.
   * @param {number} sourceAmount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;.
   * @param {string} sourceUnit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot;
   * @param {string} targetUnit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot;
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public convertAmounts(
    ingredientName: string,
    sourceAmount: number,
    sourceUnit: string,
    targetUnit: string,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .convertAmounts(
        ingredientName,
        sourceAmount,
        sourceUnit,
        targetUnit,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Generate a recipe card for a recipe.
   * @summary Create Recipe Card
   * @param {CreateRecipeCardContentTypeEnum} [contentType] The content type.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public createRecipeCard(
    contentType?: CreateRecipeCardContentTypeEnum,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .createRecipeCard(contentType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Visualize a recipe\'s equipment list as an image.
   * @summary Equipment by ID Image
   * @param {number} id The recipe id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public equipmentByIDImage(id: number, options?: RawAxiosRequestConfig) {
    return RecipesApiFp(this.configuration)
      .equipmentByIDImage(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint lets you extract recipe data such as title, ingredients, and instructions from any properly formatted Website.
   * @summary Extract Recipe from Website
   * @param {string} url The URL of the recipe page.
   * @param {boolean} [forceExtraction] If true, the extraction will be triggered whether we already know the recipe or not. Use this only if information is missing as this operation is slower.
   * @param {boolean} [analyze] If true, the recipe will be analyzed and classified resolving in more data such as cuisines, dish types, and more.
   * @param {boolean} [includeNutrition] Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings.
   * @param {boolean} [includeTaste] Whether taste data should be added to correctly parsed ingredients.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public extractRecipeFromWebsite(
    url: string,
    forceExtraction?: boolean,
    analyze?: boolean,
    includeNutrition?: boolean,
    includeTaste?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .extractRecipeFromWebsite(
        url,
        forceExtraction,
        analyze,
        includeNutrition,
        includeTaste,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get an analyzed breakdown of a recipe\'s instructions. Each step is enriched with the ingredients and equipment required.
   * @summary Get Analyzed Recipe Instructions
   * @param {number} id The item\&#39;s id.
   * @param {boolean} [stepBreakdown] Whether to break down the recipe steps even more.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public getAnalyzedRecipeInstructions(
    id: number,
    stepBreakdown?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .getAnalyzedRecipeInstructions(id, stepBreakdown, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Find random (popular) recipes. If you need to filter recipes by diet, nutrition etc. you might want to consider using the complex recipe search endpoint and set the sort request parameter to random.
   * @summary Get Random Recipes
   * @param {boolean} [limitLicense] Whether the recipes should have an open license that allows display with proper attribution.
   * @param {string} [tags] The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have.
   * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public getRandomRecipes(
    limitLicense?: boolean,
    tags?: string,
    number?: number,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .getRandomRecipes(limitLicense, tags, number, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a recipe\'s equipment list.
   * @summary Equipment by ID
   * @param {number} id The item\&#39;s id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public getRecipeEquipmentByID(id: number, options?: RawAxiosRequestConfig) {
    return RecipesApiFp(this.configuration)
      .getRecipeEquipmentByID(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Use a recipe id to get full information about a recipe, such as ingredients, nutrition, diet and allergen information, etc.
   * @summary Get Recipe Information
   * @param {number} id The item\&#39;s id.
   * @param {boolean} [includeNutrition] Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public getRecipeInformation(
    id: number,
    includeNutrition?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .getRecipeInformation(id, includeNutrition, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get information about multiple recipes at once. This is equivalent to calling the Get Recipe Information endpoint multiple times, but faster.
   * @summary Get Recipe Information Bulk
   * @param {string} ids A comma-separated list of recipe ids.
   * @param {boolean} [includeNutrition] Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public getRecipeInformationBulk(
    ids: string,
    includeNutrition?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .getRecipeInformationBulk(ids, includeNutrition, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a recipe\'s ingredient list.
   * @summary Ingredients by ID
   * @param {number} id The item\&#39;s id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public getRecipeIngredientsByID(id: number, options?: RawAxiosRequestConfig) {
    return RecipesApiFp(this.configuration)
      .getRecipeIngredientsByID(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a recipe\'s nutrition data.
   * @summary Nutrition by ID
   * @param {number} id The item\&#39;s id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public getRecipeNutritionWidgetByID(
    id: number,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .getRecipeNutritionWidgetByID(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a recipe\'s price breakdown data.
   * @summary Price Breakdown by ID
   * @param {number} id The item\&#39;s id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public getRecipePriceBreakdownByID(
    id: number,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .getRecipePriceBreakdownByID(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a recipe\'s taste. The tastes supported are sweet, salty, sour, bitter, savory, and fatty.
   * @summary Taste by ID
   * @param {number} id The item\&#39;s id.
   * @param {boolean} [normalize] Normalize to the strongest taste.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public getRecipeTasteByID(
    id: number,
    normalize?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .getRecipeTasteByID(id, normalize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Find recipes which are similar to the given one.
   * @summary Get Similar Recipes
   * @param {number} id The item\&#39;s id.
   * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
   * @param {boolean} [limitLicense] Whether the recipes should have an open license that allows display with proper attribution.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public getSimilarRecipes(
    id: number,
    number?: number,
    limitLicense?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .getSimilarRecipes(id, number, limitLicense, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Estimate the macronutrients of a dish based on its title.
   * @summary Guess Nutrition by Dish Name
   * @param {string} title The title of the dish.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public guessNutritionByDishName(
    title: string,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .guessNutritionByDishName(title, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Visualize a recipe\'s ingredient list.
   * @summary Ingredients by ID Image
   * @param {number} id The recipe id.
   * @param {IngredientsByIDImageMeasureEnum} [measure] Whether the the measures should be \&#39;us\&#39; or \&#39;metric\&#39;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public ingredientsByIDImage(
    id: number,
    measure?: IngredientsByIDImageMeasureEnum,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .ingredientsByIDImage(id, measure, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Extract an ingredient from plain text.
   * @summary Parse Ingredients
   * @param {ParseIngredientsContentTypeEnum} [contentType] The content type.
   * @param {ParseIngredientsLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public parseIngredients(
    contentType?: ParseIngredientsContentTypeEnum,
    language?: ParseIngredientsLanguageEnum,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .parseIngredients(contentType, language, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Visualize a recipe\'s price breakdown.
   * @summary Price Breakdown by ID Image
   * @param {number} id The recipe id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public priceBreakdownByIDImage(id: number, options?: RawAxiosRequestConfig) {
    return RecipesApiFp(this.configuration)
      .priceBreakdownByIDImage(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Answer a nutrition related natural language question.
   * @summary Quick Answer
   * @param {string} q The nutrition related question.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public quickAnswer(q: string, options?: RawAxiosRequestConfig) {
    return RecipesApiFp(this.configuration)
      .quickAnswer(q, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Visualize a recipe\'s nutritional information as an image.
   * @summary Recipe Nutrition by ID Image
   * @param {number} id The recipe id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public recipeNutritionByIDImage(id: number, options?: RawAxiosRequestConfig) {
    return RecipesApiFp(this.configuration)
      .recipeNutritionByIDImage(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a recipe\'s nutrition label as an image.
   * @summary Recipe Nutrition Label Image
   * @param {number} id The recipe id.
   * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
   * @param {boolean} [showZeroValues] Whether to show zero values.
   * @param {boolean} [showIngredients] Whether to show a list of ingredients.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public recipeNutritionLabelImage(
    id: number,
    showOptionalNutrients?: boolean,
    showZeroValues?: boolean,
    showIngredients?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .recipeNutritionLabelImage(
        id,
        showOptionalNutrients,
        showZeroValues,
        showIngredients,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a recipe\'s nutrition label as an HTML widget.
   * @summary Recipe Nutrition Label Widget
   * @param {number} id The recipe id.
   * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
   * @param {boolean} [showOptionalNutrients] Whether to show optional nutrients.
   * @param {boolean} [showZeroValues] Whether to show zero values.
   * @param {boolean} [showIngredients] Whether to show a list of ingredients.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public recipeNutritionLabelWidget(
    id: number,
    defaultCss?: boolean,
    showOptionalNutrients?: boolean,
    showZeroValues?: boolean,
    showIngredients?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .recipeNutritionLabelWidget(
        id,
        defaultCss,
        showOptionalNutrients,
        showZeroValues,
        showIngredients,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a recipe\'s taste as an image. The tastes supported are sweet, salty, sour, bitter, savory, and fatty.
   * @summary Recipe Taste by ID Image
   * @param {number} id The recipe id.
   * @param {boolean} [normalize] Normalize to the strongest taste.
   * @param {string} [rgb] Red, green, blue values for the chart color.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public recipeTasteByIDImage(
    id: number,
    normalize?: boolean,
    rgb?: string,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .recipeTasteByIDImage(id, normalize, rgb, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Search through hundreds of thousands of recipes using advanced filtering and ranking. NOTE: This method combines searching by query, by ingredients, and by nutrients into one endpoint.
   * @summary Search Recipes
   * @param {string} [query] The (natural language) search query.
   * @param {string} [cuisine] The cuisine(s) of the recipes. One or more, comma separated (will be interpreted as \&#39;OR\&#39;). See a full list of supported cuisines.
   * @param {string} [excludeCuisine] The cuisine(s) the recipes must not match. One or more, comma separated (will be interpreted as \&#39;AND\&#39;). See a full list of supported cuisines.
   * @param {string} [diet] The diet for which the recipes must be suitable. See a full list of supported diets.
   * @param {string} [intolerances] A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.
   * @param {string} [equipment] The equipment required. Multiple values will be interpreted as \&#39;or\&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;.
   * @param {string} [includeIngredients] A comma-separated list of ingredients that should/must be used in the recipes.
   * @param {string} [excludeIngredients] A comma-separated list of ingredients or ingredient types that the recipes must not contain.
   * @param {string} [type] The type of recipe. See a full list of supported meal types.
   * @param {boolean} [instructionsRequired] Whether the recipes must have instructions.
   * @param {boolean} [fillIngredients] Add information about the ingredients and whether they are used or missing in relation to the query.
   * @param {boolean} [addRecipeInformation] If set to true, you get more information about the recipes returned.
   * @param {boolean} [addRecipeNutrition] If set to true, you get nutritional information about each recipes returned.
   * @param {string} [author] The username of the recipe author.
   * @param {string} [tags] The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have.
   * @param {number} [recipeBoxId] The id of the recipe box to which the search should be limited to.
   * @param {string} [titleMatch] Enter text that must be found in the title of the recipes.
   * @param {number} [maxReadyTime] The maximum time in minutes it should take to prepare and cook the recipe.
   * @param {boolean} [ignorePantry] Whether to ignore typical pantry items, such as water, salt, flour, etc.
   * @param {string} [sort] The strategy to sort recipes by. See a full list of supported sorting options.
   * @param {string} [sortDirection] The direction in which to sort. Must be either \&#39;asc\&#39; (ascending) or \&#39;desc\&#39; (descending).
   * @param {number} [minCarbs] The minimum amount of carbohydrates in grams the recipe must have.
   * @param {number} [maxCarbs] The maximum amount of carbohydrates in grams the recipe can have.
   * @param {number} [minProtein] The minimum amount of protein in grams the recipe must have.
   * @param {number} [maxProtein] The maximum amount of protein in grams the recipe can have.
   * @param {number} [minCalories] The minimum amount of calories the recipe must have.
   * @param {number} [maxCalories] The maximum amount of calories the recipe can have.
   * @param {number} [minFat] The minimum amount of fat in grams the recipe must have.
   * @param {number} [maxFat] The maximum amount of fat in grams the recipe can have.
   * @param {number} [minAlcohol] The minimum amount of alcohol in grams the recipe must have.
   * @param {number} [maxAlcohol] The maximum amount of alcohol in grams the recipe can have.
   * @param {number} [minCaffeine] The minimum amount of caffeine in milligrams the recipe must have.
   * @param {number} [maxCaffeine] The maximum amount of caffeine in milligrams the recipe can have.
   * @param {number} [minCopper] The minimum amount of copper in milligrams the recipe must have.
   * @param {number} [maxCopper] The maximum amount of copper in milligrams the recipe can have.
   * @param {number} [minCalcium] The minimum amount of calcium in milligrams the recipe must have.
   * @param {number} [maxCalcium] The maximum amount of calcium in milligrams the recipe can have.
   * @param {number} [minCholine] The minimum amount of choline in milligrams the recipe must have.
   * @param {number} [maxCholine] The maximum amount of choline in milligrams the recipe can have.
   * @param {number} [minCholesterol] The minimum amount of cholesterol in milligrams the recipe must have.
   * @param {number} [maxCholesterol] The maximum amount of cholesterol in milligrams the recipe can have.
   * @param {number} [minFluoride] The minimum amount of fluoride in milligrams the recipe must have.
   * @param {number} [maxFluoride] The maximum amount of fluoride in milligrams the recipe can have.
   * @param {number} [minSaturatedFat] The minimum amount of saturated fat in grams the recipe must have.
   * @param {number} [maxSaturatedFat] The maximum amount of saturated fat in grams the recipe can have.
   * @param {number} [minVitaminA] The minimum amount of Vitamin A in IU the recipe must have.
   * @param {number} [maxVitaminA] The maximum amount of Vitamin A in IU the recipe can have.
   * @param {number} [minVitaminC] The minimum amount of Vitamin C milligrams the recipe must have.
   * @param {number} [maxVitaminC] The maximum amount of Vitamin C in milligrams the recipe can have.
   * @param {number} [minVitaminD] The minimum amount of Vitamin D in micrograms the recipe must have.
   * @param {number} [maxVitaminD] The maximum amount of Vitamin D in micrograms the recipe can have.
   * @param {number} [minVitaminE] The minimum amount of Vitamin E in milligrams the recipe must have.
   * @param {number} [maxVitaminE] The maximum amount of Vitamin E in milligrams the recipe can have.
   * @param {number} [minVitaminK] The minimum amount of Vitamin K in micrograms the recipe must have.
   * @param {number} [maxVitaminK] The maximum amount of Vitamin K in micrograms the recipe can have.
   * @param {number} [minVitaminB1] The minimum amount of Vitamin B1 in milligrams the recipe must have.
   * @param {number} [maxVitaminB1] The maximum amount of Vitamin B1 in milligrams the recipe can have.
   * @param {number} [minVitaminB2] The minimum amount of Vitamin B2 in milligrams the recipe must have.
   * @param {number} [maxVitaminB2] The maximum amount of Vitamin B2 in milligrams the recipe can have.
   * @param {number} [minVitaminB5] The minimum amount of Vitamin B5 in milligrams the recipe must have.
   * @param {number} [maxVitaminB5] The maximum amount of Vitamin B5 in milligrams the recipe can have.
   * @param {number} [minVitaminB3] The minimum amount of Vitamin B3 in milligrams the recipe must have.
   * @param {number} [maxVitaminB3] The maximum amount of Vitamin B3 in milligrams the recipe can have.
   * @param {number} [minVitaminB6] The minimum amount of Vitamin B6 in milligrams the recipe must have.
   * @param {number} [maxVitaminB6] The maximum amount of Vitamin B6 in milligrams the recipe can have.
   * @param {number} [minVitaminB12] The minimum amount of Vitamin B12 in micrograms the recipe must have.
   * @param {number} [maxVitaminB12] The maximum amount of Vitamin B12 in micrograms the recipe can have.
   * @param {number} [minFiber] The minimum amount of fiber in grams the recipe must have.
   * @param {number} [maxFiber] The maximum amount of fiber in grams the recipe can have.
   * @param {number} [minFolate] The minimum amount of folate in micrograms the recipe must have.
   * @param {number} [maxFolate] The maximum amount of folate in micrograms the recipe can have.
   * @param {number} [minFolicAcid] The minimum amount of folic acid in micrograms the recipe must have.
   * @param {number} [maxFolicAcid] The maximum amount of folic acid in micrograms the recipe can have.
   * @param {number} [minIodine] The minimum amount of iodine in micrograms the recipe must have.
   * @param {number} [maxIodine] The maximum amount of iodine in micrograms the recipe can have.
   * @param {number} [minIron] The minimum amount of iron in milligrams the recipe must have.
   * @param {number} [maxIron] The maximum amount of iron in milligrams the recipe can have.
   * @param {number} [minMagnesium] The minimum amount of magnesium in milligrams the recipe must have.
   * @param {number} [maxMagnesium] The maximum amount of magnesium in milligrams the recipe can have.
   * @param {number} [minManganese] The minimum amount of manganese in milligrams the recipe must have.
   * @param {number} [maxManganese] The maximum amount of manganese in milligrams the recipe can have.
   * @param {number} [minPhosphorus] The minimum amount of phosphorus in milligrams the recipe must have.
   * @param {number} [maxPhosphorus] The maximum amount of phosphorus in milligrams the recipe can have.
   * @param {number} [minPotassium] The minimum amount of potassium in milligrams the recipe must have.
   * @param {number} [maxPotassium] The maximum amount of potassium in milligrams the recipe can have.
   * @param {number} [minSelenium] The minimum amount of selenium in micrograms the recipe must have.
   * @param {number} [maxSelenium] The maximum amount of selenium in micrograms the recipe can have.
   * @param {number} [minSodium] The minimum amount of sodium in milligrams the recipe must have.
   * @param {number} [maxSodium] The maximum amount of sodium in milligrams the recipe can have.
   * @param {number} [minSugar] The minimum amount of sugar in grams the recipe must have.
   * @param {number} [maxSugar] The maximum amount of sugar in grams the recipe can have.
   * @param {number} [minZinc] The minimum amount of zinc in milligrams the recipe must have.
   * @param {number} [maxZinc] The maximum amount of zinc in milligrams the recipe can have.
   * @param {number} [offset] The number of results to skip (between 0 and 900).
   * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
   * @param {boolean} [limitLicense] Whether the recipes should have an open license that allows display with proper attribution.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public searchRecipes(
    query?: string,
    cuisine?: string,
    excludeCuisine?: string,
    diet?: string,
    intolerances?: string,
    equipment?: string,
    includeIngredients?: string,
    excludeIngredients?: string,
    type?: string,
    instructionsRequired?: boolean,
    fillIngredients?: boolean,
    addRecipeInformation?: boolean,
    addRecipeNutrition?: boolean,
    author?: string,
    tags?: string,
    recipeBoxId?: number,
    titleMatch?: string,
    maxReadyTime?: number,
    ignorePantry?: boolean,
    sort?: string,
    sortDirection?: string,
    minCarbs?: number,
    maxCarbs?: number,
    minProtein?: number,
    maxProtein?: number,
    minCalories?: number,
    maxCalories?: number,
    minFat?: number,
    maxFat?: number,
    minAlcohol?: number,
    maxAlcohol?: number,
    minCaffeine?: number,
    maxCaffeine?: number,
    minCopper?: number,
    maxCopper?: number,
    minCalcium?: number,
    maxCalcium?: number,
    minCholine?: number,
    maxCholine?: number,
    minCholesterol?: number,
    maxCholesterol?: number,
    minFluoride?: number,
    maxFluoride?: number,
    minSaturatedFat?: number,
    maxSaturatedFat?: number,
    minVitaminA?: number,
    maxVitaminA?: number,
    minVitaminC?: number,
    maxVitaminC?: number,
    minVitaminD?: number,
    maxVitaminD?: number,
    minVitaminE?: number,
    maxVitaminE?: number,
    minVitaminK?: number,
    maxVitaminK?: number,
    minVitaminB1?: number,
    maxVitaminB1?: number,
    minVitaminB2?: number,
    maxVitaminB2?: number,
    minVitaminB5?: number,
    maxVitaminB5?: number,
    minVitaminB3?: number,
    maxVitaminB3?: number,
    minVitaminB6?: number,
    maxVitaminB6?: number,
    minVitaminB12?: number,
    maxVitaminB12?: number,
    minFiber?: number,
    maxFiber?: number,
    minFolate?: number,
    maxFolate?: number,
    minFolicAcid?: number,
    maxFolicAcid?: number,
    minIodine?: number,
    maxIodine?: number,
    minIron?: number,
    maxIron?: number,
    minMagnesium?: number,
    maxMagnesium?: number,
    minManganese?: number,
    maxManganese?: number,
    minPhosphorus?: number,
    maxPhosphorus?: number,
    minPotassium?: number,
    maxPotassium?: number,
    minSelenium?: number,
    maxSelenium?: number,
    minSodium?: number,
    maxSodium?: number,
    minSugar?: number,
    maxSugar?: number,
    minZinc?: number,
    maxZinc?: number,
    offset?: number,
    number?: number,
    limitLicense?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .searchRecipes(
        query,
        cuisine,
        excludeCuisine,
        diet,
        intolerances,
        equipment,
        includeIngredients,
        excludeIngredients,
        type,
        instructionsRequired,
        fillIngredients,
        addRecipeInformation,
        addRecipeNutrition,
        author,
        tags,
        recipeBoxId,
        titleMatch,
        maxReadyTime,
        ignorePantry,
        sort,
        sortDirection,
        minCarbs,
        maxCarbs,
        minProtein,
        maxProtein,
        minCalories,
        maxCalories,
        minFat,
        maxFat,
        minAlcohol,
        maxAlcohol,
        minCaffeine,
        maxCaffeine,
        minCopper,
        maxCopper,
        minCalcium,
        maxCalcium,
        minCholine,
        maxCholine,
        minCholesterol,
        maxCholesterol,
        minFluoride,
        maxFluoride,
        minSaturatedFat,
        maxSaturatedFat,
        minVitaminA,
        maxVitaminA,
        minVitaminC,
        maxVitaminC,
        minVitaminD,
        maxVitaminD,
        minVitaminE,
        maxVitaminE,
        minVitaminK,
        maxVitaminK,
        minVitaminB1,
        maxVitaminB1,
        minVitaminB2,
        maxVitaminB2,
        minVitaminB5,
        maxVitaminB5,
        minVitaminB3,
        maxVitaminB3,
        minVitaminB6,
        maxVitaminB6,
        minVitaminB12,
        maxVitaminB12,
        minFiber,
        maxFiber,
        minFolate,
        maxFolate,
        minFolicAcid,
        maxFolicAcid,
        minIodine,
        maxIodine,
        minIron,
        maxIron,
        minMagnesium,
        maxMagnesium,
        minManganese,
        maxManganese,
        minPhosphorus,
        maxPhosphorus,
        minPotassium,
        maxPotassium,
        minSelenium,
        maxSelenium,
        minSodium,
        maxSodium,
        minSugar,
        maxSugar,
        minZinc,
        maxZinc,
        offset,
        number,
        limitLicense,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Ever wondered what recipes you can cook with the ingredients you have in your fridge or pantry? This endpoint lets you find recipes that either maximize the usage of ingredients you have at hand (pre shopping) or minimize the ingredients that you don\'t currently have (post shopping).
   * @summary Search Recipes by Ingredients
   * @param {string} [ingredients] A comma-separated list of ingredients that the recipes should contain.
   * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
   * @param {boolean} [limitLicense] Whether the recipes should have an open license that allows display with proper attribution.
   * @param {number} [ranking] Whether to maximize used ingredients (1) or minimize missing ingredients (2) first.
   * @param {boolean} [ignorePantry] Whether to ignore typical pantry items, such as water, salt, flour, etc.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public searchRecipesByIngredients(
    ingredients?: string,
    number?: number,
    limitLicense?: boolean,
    ranking?: number,
    ignorePantry?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .searchRecipesByIngredients(
        ingredients,
        number,
        limitLicense,
        ranking,
        ignorePantry,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Find a set of recipes that adhere to the given nutritional limits. You may set limits for macronutrients (calories, protein, fat, and carbohydrate) and/or many micronutrients.
   * @summary Search Recipes by Nutrients
   * @param {number} [minCarbs] The minimum amount of carbohydrates in grams the recipe must have.
   * @param {number} [maxCarbs] The maximum amount of carbohydrates in grams the recipe can have.
   * @param {number} [minProtein] The minimum amount of protein in grams the recipe must have.
   * @param {number} [maxProtein] The maximum amount of protein in grams the recipe can have.
   * @param {number} [minCalories] The minimum amount of calories the recipe must have.
   * @param {number} [maxCalories] The maximum amount of calories the recipe can have.
   * @param {number} [minFat] The minimum amount of fat in grams the recipe must have.
   * @param {number} [maxFat] The maximum amount of fat in grams the recipe can have.
   * @param {number} [minAlcohol] The minimum amount of alcohol in grams the recipe must have.
   * @param {number} [maxAlcohol] The maximum amount of alcohol in grams the recipe can have.
   * @param {number} [minCaffeine] The minimum amount of caffeine in milligrams the recipe must have.
   * @param {number} [maxCaffeine] The maximum amount of caffeine in milligrams the recipe can have.
   * @param {number} [minCopper] The minimum amount of copper in milligrams the recipe must have.
   * @param {number} [maxCopper] The maximum amount of copper in milligrams the recipe can have.
   * @param {number} [minCalcium] The minimum amount of calcium in milligrams the recipe must have.
   * @param {number} [maxCalcium] The maximum amount of calcium in milligrams the recipe can have.
   * @param {number} [minCholine] The minimum amount of choline in milligrams the recipe must have.
   * @param {number} [maxCholine] The maximum amount of choline in milligrams the recipe can have.
   * @param {number} [minCholesterol] The minimum amount of cholesterol in milligrams the recipe must have.
   * @param {number} [maxCholesterol] The maximum amount of cholesterol in milligrams the recipe can have.
   * @param {number} [minFluoride] The minimum amount of fluoride in milligrams the recipe must have.
   * @param {number} [maxFluoride] The maximum amount of fluoride in milligrams the recipe can have.
   * @param {number} [minSaturatedFat] The minimum amount of saturated fat in grams the recipe must have.
   * @param {number} [maxSaturatedFat] The maximum amount of saturated fat in grams the recipe can have.
   * @param {number} [minVitaminA] The minimum amount of Vitamin A in IU the recipe must have.
   * @param {number} [maxVitaminA] The maximum amount of Vitamin A in IU the recipe can have.
   * @param {number} [minVitaminC] The minimum amount of Vitamin C in milligrams the recipe must have.
   * @param {number} [maxVitaminC] The maximum amount of Vitamin C in milligrams the recipe can have.
   * @param {number} [minVitaminD] The minimum amount of Vitamin D in micrograms the recipe must have.
   * @param {number} [maxVitaminD] The maximum amount of Vitamin D in micrograms the recipe can have.
   * @param {number} [minVitaminE] The minimum amount of Vitamin E in milligrams the recipe must have.
   * @param {number} [maxVitaminE] The maximum amount of Vitamin E in milligrams the recipe can have.
   * @param {number} [minVitaminK] The minimum amount of Vitamin K in micrograms the recipe must have.
   * @param {number} [maxVitaminK] The maximum amount of Vitamin K in micrograms the recipe can have.
   * @param {number} [minVitaminB1] The minimum amount of Vitamin B1 in milligrams the recipe must have.
   * @param {number} [maxVitaminB1] The maximum amount of Vitamin B1 in milligrams the recipe can have.
   * @param {number} [minVitaminB2] The minimum amount of Vitamin B2 in milligrams the recipe must have.
   * @param {number} [maxVitaminB2] The maximum amount of Vitamin B2 in milligrams the recipe can have.
   * @param {number} [minVitaminB5] The minimum amount of Vitamin B5 in milligrams the recipe must have.
   * @param {number} [maxVitaminB5] The maximum amount of Vitamin B5 in milligrams the recipe can have.
   * @param {number} [minVitaminB3] The minimum amount of Vitamin B3 in milligrams the recipe must have.
   * @param {number} [maxVitaminB3] The maximum amount of Vitamin B3 in milligrams the recipe can have.
   * @param {number} [minVitaminB6] The minimum amount of Vitamin B6 in milligrams the recipe must have.
   * @param {number} [maxVitaminB6] The maximum amount of Vitamin B6 in milligrams the recipe can have.
   * @param {number} [minVitaminB12] The minimum amount of Vitamin B12 in micrograms the recipe must have.
   * @param {number} [maxVitaminB12] The maximum amount of Vitamin B12 in micrograms the recipe can have.
   * @param {number} [minFiber] The minimum amount of fiber in grams the recipe must have.
   * @param {number} [maxFiber] The maximum amount of fiber in grams the recipe can have.
   * @param {number} [minFolate] The minimum amount of folate in micrograms the recipe must have.
   * @param {number} [maxFolate] The maximum amount of folate in micrograms the recipe can have.
   * @param {number} [minFolicAcid] The minimum amount of folic acid in micrograms the recipe must have.
   * @param {number} [maxFolicAcid] The maximum amount of folic acid in micrograms the recipe can have.
   * @param {number} [minIodine] The minimum amount of iodine in micrograms the recipe must have.
   * @param {number} [maxIodine] The maximum amount of iodine in micrograms the recipe can have.
   * @param {number} [minIron] The minimum amount of iron in milligrams the recipe must have.
   * @param {number} [maxIron] The maximum amount of iron in milligrams the recipe can have.
   * @param {number} [minMagnesium] The minimum amount of magnesium in milligrams the recipe must have.
   * @param {number} [maxMagnesium] The maximum amount of magnesium in milligrams the recipe can have.
   * @param {number} [minManganese] The minimum amount of manganese in milligrams the recipe must have.
   * @param {number} [maxManganese] The maximum amount of manganese in milligrams the recipe can have.
   * @param {number} [minPhosphorus] The minimum amount of phosphorus in milligrams the recipe must have.
   * @param {number} [maxPhosphorus] The maximum amount of phosphorus in milligrams the recipe can have.
   * @param {number} [minPotassium] The minimum amount of potassium in milligrams the recipe must have.
   * @param {number} [maxPotassium] The maximum amount of potassium in milligrams the recipe can have.
   * @param {number} [minSelenium] The minimum amount of selenium in micrograms the recipe must have.
   * @param {number} [maxSelenium] The maximum amount of selenium in micrograms the recipe can have.
   * @param {number} [minSodium] The minimum amount of sodium in milligrams the recipe must have.
   * @param {number} [maxSodium] The maximum amount of sodium in milligrams the recipe can have.
   * @param {number} [minSugar] The minimum amount of sugar in grams the recipe must have.
   * @param {number} [maxSugar] The maximum amount of sugar in grams the recipe can have.
   * @param {number} [minZinc] The minimum amount of zinc in milligrams the recipe must have.
   * @param {number} [maxZinc] The maximum amount of zinc in milligrams the recipe can have.
   * @param {number} [offset] The number of results to skip (between 0 and 900).
   * @param {number} [number] The maximum number of items to return (between 1 and 100). Defaults to 10.
   * @param {boolean} [random] If true, every request will give you a random set of recipes within the requested limits.
   * @param {boolean} [limitLicense] Whether the recipes should have an open license that allows display with proper attribution.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public searchRecipesByNutrients(
    minCarbs?: number,
    maxCarbs?: number,
    minProtein?: number,
    maxProtein?: number,
    minCalories?: number,
    maxCalories?: number,
    minFat?: number,
    maxFat?: number,
    minAlcohol?: number,
    maxAlcohol?: number,
    minCaffeine?: number,
    maxCaffeine?: number,
    minCopper?: number,
    maxCopper?: number,
    minCalcium?: number,
    maxCalcium?: number,
    minCholine?: number,
    maxCholine?: number,
    minCholesterol?: number,
    maxCholesterol?: number,
    minFluoride?: number,
    maxFluoride?: number,
    minSaturatedFat?: number,
    maxSaturatedFat?: number,
    minVitaminA?: number,
    maxVitaminA?: number,
    minVitaminC?: number,
    maxVitaminC?: number,
    minVitaminD?: number,
    maxVitaminD?: number,
    minVitaminE?: number,
    maxVitaminE?: number,
    minVitaminK?: number,
    maxVitaminK?: number,
    minVitaminB1?: number,
    maxVitaminB1?: number,
    minVitaminB2?: number,
    maxVitaminB2?: number,
    minVitaminB5?: number,
    maxVitaminB5?: number,
    minVitaminB3?: number,
    maxVitaminB3?: number,
    minVitaminB6?: number,
    maxVitaminB6?: number,
    minVitaminB12?: number,
    maxVitaminB12?: number,
    minFiber?: number,
    maxFiber?: number,
    minFolate?: number,
    maxFolate?: number,
    minFolicAcid?: number,
    maxFolicAcid?: number,
    minIodine?: number,
    maxIodine?: number,
    minIron?: number,
    maxIron?: number,
    minMagnesium?: number,
    maxMagnesium?: number,
    minManganese?: number,
    maxManganese?: number,
    minPhosphorus?: number,
    maxPhosphorus?: number,
    minPotassium?: number,
    maxPotassium?: number,
    minSelenium?: number,
    maxSelenium?: number,
    minSodium?: number,
    maxSodium?: number,
    minSugar?: number,
    maxSugar?: number,
    minZinc?: number,
    maxZinc?: number,
    offset?: number,
    number?: number,
    random?: boolean,
    limitLicense?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .searchRecipesByNutrients(
        minCarbs,
        maxCarbs,
        minProtein,
        maxProtein,
        minCalories,
        maxCalories,
        minFat,
        maxFat,
        minAlcohol,
        maxAlcohol,
        minCaffeine,
        maxCaffeine,
        minCopper,
        maxCopper,
        minCalcium,
        maxCalcium,
        minCholine,
        maxCholine,
        minCholesterol,
        maxCholesterol,
        minFluoride,
        maxFluoride,
        minSaturatedFat,
        maxSaturatedFat,
        minVitaminA,
        maxVitaminA,
        minVitaminC,
        maxVitaminC,
        minVitaminD,
        maxVitaminD,
        minVitaminE,
        maxVitaminE,
        minVitaminK,
        maxVitaminK,
        minVitaminB1,
        maxVitaminB1,
        minVitaminB2,
        maxVitaminB2,
        minVitaminB5,
        maxVitaminB5,
        minVitaminB3,
        maxVitaminB3,
        minVitaminB6,
        maxVitaminB6,
        minVitaminB12,
        maxVitaminB12,
        minFiber,
        maxFiber,
        minFolate,
        maxFolate,
        minFolicAcid,
        maxFolicAcid,
        minIodine,
        maxIodine,
        minIron,
        maxIron,
        minMagnesium,
        maxMagnesium,
        minManganese,
        maxManganese,
        minPhosphorus,
        maxPhosphorus,
        minPotassium,
        maxPotassium,
        minSelenium,
        maxSelenium,
        minSodium,
        maxSodium,
        minSugar,
        maxSugar,
        minZinc,
        maxZinc,
        offset,
        number,
        random,
        limitLicense,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Automatically generate a short description that summarizes key information about the recipe.
   * @summary Summarize Recipe
   * @param {number} id The item\&#39;s id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public summarizeRecipe(id: number, options?: RawAxiosRequestConfig) {
    return RecipesApiFp(this.configuration)
      .summarizeRecipe(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Visualize the equipment used to make a recipe.
   * @summary Equipment Widget
   * @param {VisualizeEquipmentContentTypeEnum} [contentType] The content type.
   * @param {VisualizeEquipmentAcceptEnum} [accept] Accept header.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public visualizeEquipment(
    contentType?: VisualizeEquipmentContentTypeEnum,
    accept?: VisualizeEquipmentAcceptEnum,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .visualizeEquipment(contentType, accept, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Visualize the price breakdown of a recipe.
   * @summary Price Breakdown Widget
   * @param {VisualizePriceBreakdownContentTypeEnum} [contentType] The content type.
   * @param {VisualizePriceBreakdownAcceptEnum} [accept] Accept header.
   * @param {VisualizePriceBreakdownLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public visualizePriceBreakdown(
    contentType?: VisualizePriceBreakdownContentTypeEnum,
    accept?: VisualizePriceBreakdownAcceptEnum,
    language?: VisualizePriceBreakdownLanguageEnum,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .visualizePriceBreakdown(contentType, accept, language, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Visualize a recipe\'s equipment list.
   * @summary Equipment by ID Widget
   * @param {number} id The item\&#39;s id.
   * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public visualizeRecipeEquipmentByID(
    id: number,
    defaultCss?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .visualizeRecipeEquipmentByID(id, defaultCss, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Visualize a recipe\'s ingredient list.
   * @summary Ingredients by ID Widget
   * @param {number} id The item\&#39;s id.
   * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
   * @param {VisualizeRecipeIngredientsByIDMeasureEnum} [measure] Whether the the measures should be \&#39;us\&#39; or \&#39;metric\&#39;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public visualizeRecipeIngredientsByID(
    id: number,
    defaultCss?: boolean,
    measure?: VisualizeRecipeIngredientsByIDMeasureEnum,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .visualizeRecipeIngredientsByID(id, defaultCss, measure, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Visualize a recipe\'s nutritional information as HTML including CSS.
   * @summary Recipe Nutrition Widget
   * @param {VisualizeRecipeNutritionContentTypeEnum} [contentType] The content type.
   * @param {VisualizeRecipeNutritionAcceptEnum} [accept] Accept header.
   * @param {VisualizeRecipeNutritionLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public visualizeRecipeNutrition(
    contentType?: VisualizeRecipeNutritionContentTypeEnum,
    accept?: VisualizeRecipeNutritionAcceptEnum,
    language?: VisualizeRecipeNutritionLanguageEnum,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .visualizeRecipeNutrition(contentType, accept, language, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Visualize a recipe\'s nutritional information as HTML including CSS.
   * @summary Recipe Nutrition by ID Widget
   * @param {number} id The item\&#39;s id.
   * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
   * @param {VisualizeRecipeNutritionByIDAcceptEnum} [accept] Accept header.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public visualizeRecipeNutritionByID(
    id: number,
    defaultCss?: boolean,
    accept?: VisualizeRecipeNutritionByIDAcceptEnum,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .visualizeRecipeNutritionByID(id, defaultCss, accept, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Visualize a recipe\'s price breakdown.
   * @summary Price Breakdown by ID Widget
   * @param {number} id The item\&#39;s id.
   * @param {boolean} [defaultCss] Whether the default CSS should be added to the response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public visualizeRecipePriceBreakdownByID(
    id: number,
    defaultCss?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .visualizeRecipePriceBreakdownByID(id, defaultCss, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Visualize a recipe\'s taste information as HTML including CSS. You can play around with that endpoint!
   * @summary Recipe Taste Widget
   * @param {VisualizeRecipeTasteLanguageEnum} [language] The language of the input. Either \&#39;en\&#39; or \&#39;de\&#39;.
   * @param {VisualizeRecipeTasteContentTypeEnum} [contentType] The content type.
   * @param {VisualizeRecipeTasteAcceptEnum} [accept] Accept header.
   * @param {boolean} [normalize] Whether to normalize to the strongest taste.
   * @param {string} [rgb] Red, green, blue values for the chart color.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public visualizeRecipeTaste(
    language?: VisualizeRecipeTasteLanguageEnum,
    contentType?: VisualizeRecipeTasteContentTypeEnum,
    accept?: VisualizeRecipeTasteAcceptEnum,
    normalize?: boolean,
    rgb?: string,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .visualizeRecipeTaste(
        language,
        contentType,
        accept,
        normalize,
        rgb,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a recipe\'s taste. The tastes supported are sweet, salty, sour, bitter, savory, and fatty.
   * @summary Recipe Taste by ID Widget
   * @param {number} id The item\&#39;s id.
   * @param {boolean} [normalize] Whether to normalize to the strongest taste.
   * @param {string} [rgb] Red, green, blue values for the chart color.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecipesApi
   */
  public visualizeRecipeTasteByID(
    id: number,
    normalize?: boolean,
    rgb?: string,
    options?: RawAxiosRequestConfig
  ) {
    return RecipesApiFp(this.configuration)
      .visualizeRecipeTasteByID(id, normalize, rgb, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const AnalyzeRecipeInstructionsContentTypeEnum = {
  ApplicationXWwwFormUrlencoded: "application/x-www-form-urlencoded",
  ApplicationJson: "application/json",
  MultipartFormData: "multipart/form-data",
} as const;
export type AnalyzeRecipeInstructionsContentTypeEnum =
  (typeof AnalyzeRecipeInstructionsContentTypeEnum)[keyof typeof AnalyzeRecipeInstructionsContentTypeEnum];
/**
 * @export
 */
export const ClassifyCuisineContentTypeEnum = {
  ApplicationXWwwFormUrlencoded: "application/x-www-form-urlencoded",
  ApplicationJson: "application/json",
  MultipartFormData: "multipart/form-data",
} as const;
export type ClassifyCuisineContentTypeEnum =
  (typeof ClassifyCuisineContentTypeEnum)[keyof typeof ClassifyCuisineContentTypeEnum];
/**
 * @export
 */
export const ComputeGlycemicLoadLanguageEnum = {
  En: "en",
  De: "de",
} as const;
export type ComputeGlycemicLoadLanguageEnum =
  (typeof ComputeGlycemicLoadLanguageEnum)[keyof typeof ComputeGlycemicLoadLanguageEnum];
/**
 * @export
 */
export const CreateRecipeCardContentTypeEnum = {
  ApplicationXWwwFormUrlencoded: "application/x-www-form-urlencoded",
  ApplicationJson: "application/json",
  MultipartFormData: "multipart/form-data",
} as const;
export type CreateRecipeCardContentTypeEnum =
  (typeof CreateRecipeCardContentTypeEnum)[keyof typeof CreateRecipeCardContentTypeEnum];
/**
 * @export
 */
/**
 * @export
 */
export const ParseIngredientsContentTypeEnum = {
  ApplicationXWwwFormUrlencoded: "application/x-www-form-urlencoded",
  ApplicationJson: "application/json",
  MultipartFormData: "multipart/form-data",
} as const;
export type ParseIngredientsContentTypeEnum =
  (typeof ParseIngredientsContentTypeEnum)[keyof typeof ParseIngredientsContentTypeEnum];
/**
 * @export
 */
export const ParseIngredientsLanguageEnum = {
  En: "en",
  De: "de",
} as const;
export type ParseIngredientsLanguageEnum =
  (typeof ParseIngredientsLanguageEnum)[keyof typeof ParseIngredientsLanguageEnum];
/**
 * @export
 */
export const VisualizeEquipmentContentTypeEnum = {
  ApplicationXWwwFormUrlencoded: "application/x-www-form-urlencoded",
  ApplicationJson: "application/json",
  MultipartFormData: "multipart/form-data",
} as const;
export type VisualizeEquipmentContentTypeEnum =
  (typeof VisualizeEquipmentContentTypeEnum)[keyof typeof VisualizeEquipmentContentTypeEnum];
/**
 * @export
 */
export const VisualizeEquipmentAcceptEnum = {
  ApplicationJson: "application/json",
  TextHtml: "text/html",
  Media: "media/_*",
} as const;
export type VisualizeEquipmentAcceptEnum =
  (typeof VisualizeEquipmentAcceptEnum)[keyof typeof VisualizeEquipmentAcceptEnum];
/**
 * @export
 */
export const VisualizePriceBreakdownContentTypeEnum = {
  ApplicationXWwwFormUrlencoded: "application/x-www-form-urlencoded",
  ApplicationJson: "application/json",
  MultipartFormData: "multipart/form-data",
} as const;
export type VisualizePriceBreakdownContentTypeEnum =
  (typeof VisualizePriceBreakdownContentTypeEnum)[keyof typeof VisualizePriceBreakdownContentTypeEnum];
/**
 * @export
 */
export const VisualizePriceBreakdownAcceptEnum = {
  ApplicationJson: "application/json",
  TextHtml: "text/html",
  Media: "media/_*",
} as const;
export type VisualizePriceBreakdownAcceptEnum =
  (typeof VisualizePriceBreakdownAcceptEnum)[keyof typeof VisualizePriceBreakdownAcceptEnum];
/**
 * @export
 */
export const VisualizePriceBreakdownLanguageEnum = {
  En: "en",
  De: "de",
} as const;
export type VisualizePriceBreakdownLanguageEnum =
  (typeof VisualizePriceBreakdownLanguageEnum)[keyof typeof VisualizePriceBreakdownLanguageEnum];
/**
 * @export
 */
export const VisualizeRecipeIngredientsByIDMeasureEnum = {
  Us: "us",
  Metric: "metric",
} as const;
export type VisualizeRecipeIngredientsByIDMeasureEnum =
  (typeof VisualizeRecipeIngredientsByIDMeasureEnum)[keyof typeof VisualizeRecipeIngredientsByIDMeasureEnum];
/**
 * @export
 */
export const VisualizeRecipeNutritionContentTypeEnum = {
  ApplicationXWwwFormUrlencoded: "application/x-www-form-urlencoded",
  ApplicationJson: "application/json",
  MultipartFormData: "multipart/form-data",
} as const;
export type VisualizeRecipeNutritionContentTypeEnum =
  (typeof VisualizeRecipeNutritionContentTypeEnum)[keyof typeof VisualizeRecipeNutritionContentTypeEnum];
/**
 * @export
 */
export const VisualizeRecipeNutritionAcceptEnum = {
  ApplicationJson: "application/json",
  TextHtml: "text/html",
  Media: "media/_*",
} as const;
export type VisualizeRecipeNutritionAcceptEnum =
  (typeof VisualizeRecipeNutritionAcceptEnum)[keyof typeof VisualizeRecipeNutritionAcceptEnum];
/**
 * @export
 */
export const VisualizeRecipeNutritionLanguageEnum = {
  En: "en",
  De: "de",
} as const;
export type VisualizeRecipeNutritionLanguageEnum =
  (typeof VisualizeRecipeNutritionLanguageEnum)[keyof typeof VisualizeRecipeNutritionLanguageEnum];
/**
 * @export
 */
export const VisualizeRecipeNutritionByIDAcceptEnum = {
  ApplicationJson: "application/json",
  TextHtml: "text/html",
  Media: "media/_*",
} as const;
export type VisualizeRecipeNutritionByIDAcceptEnum =
  (typeof VisualizeRecipeNutritionByIDAcceptEnum)[keyof typeof VisualizeRecipeNutritionByIDAcceptEnum];
/**
 * @export
 */
export const VisualizeRecipeTasteLanguageEnum = {
  En: "en",
  De: "de",
} as const;
export type VisualizeRecipeTasteLanguageEnum =
  (typeof VisualizeRecipeTasteLanguageEnum)[keyof typeof VisualizeRecipeTasteLanguageEnum];
/**
 * @export
 */
export const VisualizeRecipeTasteContentTypeEnum = {
  ApplicationXWwwFormUrlencoded: "application/x-www-form-urlencoded",
  ApplicationJson: "application/json",
  MultipartFormData: "multipart/form-data",
} as const;
export type VisualizeRecipeTasteContentTypeEnum =
  (typeof VisualizeRecipeTasteContentTypeEnum)[keyof typeof VisualizeRecipeTasteContentTypeEnum];
/**
 * @export
 */
export const VisualizeRecipeTasteAcceptEnum = {
  ApplicationJson: "application/json",
  TextHtml: "text/html",
  Media: "media/_*",
} as const;
export type VisualizeRecipeTasteAcceptEnum =
  (typeof VisualizeRecipeTasteAcceptEnum)[keyof typeof VisualizeRecipeTasteAcceptEnum];

/**
 * WineApi - axios parameter creator
 * @export
 */
export const WineApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Find a dish that goes well with a given wine.
     * @summary Dish Pairing for Wine
     * @param {string} wine The type of wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDishPairingForWine: async (
      wine: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'wine' is not null or undefined
      assertParamExists("getDishPairingForWine", "wine", wine);
      const localVarPath = `/food/wine/dishes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (wine !== undefined) {
        localVarQueryParameter["wine"] = wine;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a simple description of a certain wine, e.g. \"malbec\", \"riesling\", or \"merlot\".
     * @summary Wine Description
     * @param {string} wine The name of the wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWineDescription: async (
      wine: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'wine' is not null or undefined
      assertParamExists("getWineDescription", "wine", wine);
      const localVarPath = `/food/wine/description`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (wine !== undefined) {
        localVarQueryParameter["wine"] = wine;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Find a wine that goes well with a food. Food can be a dish name (\"steak\"), an ingredient name (\"salmon\"), or a cuisine (\"italian\").
     * @summary Wine Pairing
     * @param {string} food The food to get a pairing for. This can be a dish (\&quot;steak\&quot;), an ingredient (\&quot;salmon\&quot;), or a cuisine (\&quot;italian\&quot;).
     * @param {number} [maxPrice] The maximum price for the specific wine recommendation in USD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWinePairing: async (
      food: string,
      maxPrice?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'food' is not null or undefined
      assertParamExists("getWinePairing", "food", food);
      const localVarPath = `/food/wine/pairing`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (food !== undefined) {
        localVarQueryParameter["food"] = food;
      }

      if (maxPrice !== undefined) {
        localVarQueryParameter["maxPrice"] = maxPrice;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a specific wine recommendation (concrete product) for a given wine type, e.g. \"merlot\".
     * @summary Wine Recommendation
     * @param {string} wine The type of wine to get a specific product recommendation for.
     * @param {number} [maxPrice] The maximum price for the specific wine recommendation in USD.
     * @param {number} [minRating] The minimum rating of the recommended wine between 0 and 1. For example, 0.8 equals 4 out of 5 stars.
     * @param {number} [number] The number of wine recommendations expected (between 1 and 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWineRecommendation: async (
      wine: string,
      maxPrice?: number,
      minRating?: number,
      number?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'wine' is not null or undefined
      assertParamExists("getWineRecommendation", "wine", wine);
      const localVarPath = `/food/wine/recommendation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyScheme required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-api-key",
        configuration
      );

      if (wine !== undefined) {
        localVarQueryParameter["wine"] = wine;
      }

      if (maxPrice !== undefined) {
        localVarQueryParameter["maxPrice"] = maxPrice;
      }

      if (minRating !== undefined) {
        localVarQueryParameter["minRating"] = minRating;
      }

      if (number !== undefined) {
        localVarQueryParameter["number"] = number;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WineApi - functional programming interface
 * @export
 */
export const WineApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WineApiAxiosParamCreator(configuration);
  return {
    /**
     * Find a dish that goes well with a given wine.
     * @summary Dish Pairing for Wine
     * @param {string} wine The type of wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDishPairingForWine(
      wine: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetDishPairingForWine200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDishPairingForWine(wine, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["WineApi.getDishPairingForWine"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a simple description of a certain wine, e.g. \"malbec\", \"riesling\", or \"merlot\".
     * @summary Wine Description
     * @param {string} wine The name of the wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWineDescription(
      wine: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetWineDescription200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getWineDescription(wine, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["WineApi.getWineDescription"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Find a wine that goes well with a food. Food can be a dish name (\"steak\"), an ingredient name (\"salmon\"), or a cuisine (\"italian\").
     * @summary Wine Pairing
     * @param {string} food The food to get a pairing for. This can be a dish (\&quot;steak\&quot;), an ingredient (\&quot;salmon\&quot;), or a cuisine (\&quot;italian\&quot;).
     * @param {number} [maxPrice] The maximum price for the specific wine recommendation in USD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWinePairing(
      food: string,
      maxPrice?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetWinePairing200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getWinePairing(
        food,
        maxPrice,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["WineApi.getWinePairing"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a specific wine recommendation (concrete product) for a given wine type, e.g. \"merlot\".
     * @summary Wine Recommendation
     * @param {string} wine The type of wine to get a specific product recommendation for.
     * @param {number} [maxPrice] The maximum price for the specific wine recommendation in USD.
     * @param {number} [minRating] The minimum rating of the recommended wine between 0 and 1. For example, 0.8 equals 4 out of 5 stars.
     * @param {number} [number] The number of wine recommendations expected (between 1 and 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWineRecommendation(
      wine: string,
      maxPrice?: number,
      minRating?: number,
      number?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetWineRecommendation200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getWineRecommendation(
          wine,
          maxPrice,
          minRating,
          number,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["WineApi.getWineRecommendation"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * WineApi - factory interface
 * @export
 */
export const WineApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = WineApiFp(configuration);
  return {
    /**
     * Find a dish that goes well with a given wine.
     * @summary Dish Pairing for Wine
     * @param {string} wine The type of wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDishPairingForWine(
      wine: string,
      options?: any
    ): AxiosPromise<GetDishPairingForWine200Response> {
      return localVarFp
        .getDishPairingForWine(wine, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a simple description of a certain wine, e.g. \"malbec\", \"riesling\", or \"merlot\".
     * @summary Wine Description
     * @param {string} wine The name of the wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWineDescription(
      wine: string,
      options?: any
    ): AxiosPromise<GetWineDescription200Response> {
      return localVarFp
        .getWineDescription(wine, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Find a wine that goes well with a food. Food can be a dish name (\"steak\"), an ingredient name (\"salmon\"), or a cuisine (\"italian\").
     * @summary Wine Pairing
     * @param {string} food The food to get a pairing for. This can be a dish (\&quot;steak\&quot;), an ingredient (\&quot;salmon\&quot;), or a cuisine (\&quot;italian\&quot;).
     * @param {number} [maxPrice] The maximum price for the specific wine recommendation in USD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWinePairing(
      food: string,
      maxPrice?: number,
      options?: any
    ): AxiosPromise<GetWinePairing200Response> {
      return localVarFp
        .getWinePairing(food, maxPrice, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a specific wine recommendation (concrete product) for a given wine type, e.g. \"merlot\".
     * @summary Wine Recommendation
     * @param {string} wine The type of wine to get a specific product recommendation for.
     * @param {number} [maxPrice] The maximum price for the specific wine recommendation in USD.
     * @param {number} [minRating] The minimum rating of the recommended wine between 0 and 1. For example, 0.8 equals 4 out of 5 stars.
     * @param {number} [number] The number of wine recommendations expected (between 1 and 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWineRecommendation(
      wine: string,
      maxPrice?: number,
      minRating?: number,
      number?: number,
      options?: any
    ): AxiosPromise<GetWineRecommendation200Response> {
      return localVarFp
        .getWineRecommendation(wine, maxPrice, minRating, number, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * WineApi - object-oriented interface
 * @export
 * @class WineApi
 * @extends {BaseAPI}
 */
export class WineApi extends BaseAPI {
  /**
   * Find a dish that goes well with a given wine.
   * @summary Dish Pairing for Wine
   * @param {string} wine The type of wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WineApi
   */
  public getDishPairingForWine(wine: string, options?: RawAxiosRequestConfig) {
    return WineApiFp(this.configuration)
      .getDishPairingForWine(wine, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a simple description of a certain wine, e.g. \"malbec\", \"riesling\", or \"merlot\".
   * @summary Wine Description
   * @param {string} wine The name of the wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WineApi
   */
  public getWineDescription(wine: string, options?: RawAxiosRequestConfig) {
    return WineApiFp(this.configuration)
      .getWineDescription(wine, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Find a wine that goes well with a food. Food can be a dish name (\"steak\"), an ingredient name (\"salmon\"), or a cuisine (\"italian\").
   * @summary Wine Pairing
   * @param {string} food The food to get a pairing for. This can be a dish (\&quot;steak\&quot;), an ingredient (\&quot;salmon\&quot;), or a cuisine (\&quot;italian\&quot;).
   * @param {number} [maxPrice] The maximum price for the specific wine recommendation in USD.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WineApi
   */
  public getWinePairing(
    food: string,
    maxPrice?: number,
    options?: RawAxiosRequestConfig
  ) {
    return WineApiFp(this.configuration)
      .getWinePairing(food, maxPrice, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a specific wine recommendation (concrete product) for a given wine type, e.g. \"merlot\".
   * @summary Wine Recommendation
   * @param {string} wine The type of wine to get a specific product recommendation for.
   * @param {number} [maxPrice] The maximum price for the specific wine recommendation in USD.
   * @param {number} [minRating] The minimum rating of the recommended wine between 0 and 1. For example, 0.8 equals 4 out of 5 stars.
   * @param {number} [number] The number of wine recommendations expected (between 1 and 100).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WineApi
   */
  public getWineRecommendation(
    wine: string,
    maxPrice?: number,
    minRating?: number,
    number?: number,
    options?: RawAxiosRequestConfig
  ) {
    return WineApiFp(this.configuration)
      .getWineRecommendation(wine, maxPrice, minRating, number, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
